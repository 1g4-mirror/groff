.\" Copyright (c) 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed by the University of
.\"      California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)doc 5.8 (Berkeley) 8/5/91
.\" Modified by jjc@jclark.com as follows: the doc-* files are assumed to be
.\" installed as mdoc/doc-* rather than tmac.doc-* (the filename
.\" `tmac.doc-common' would be too long); when using groff, the doc-* files
.\" are loaded using the `mso' request.
.\"
.\" Modified by wl@gnu.org to make it more readable: using long names and
.\" many groff features, updating and extending documentation.
.
.
.if !\n(.g .ab This version of mdoc can be run with groff only!
.
.
.cp 0
.
.eo
.
.
.\" Load start-up files
.if t .mso mdoc/doc-ditroff.new
.if n .mso mdoc/doc-nroff.new
.
.mso mdoc/doc-common.new
.mso mdoc/doc-syms.new
.
.
.\" NS doc-inline-debug register (bool)
.\" NS   DEBUG MODE (inline if 1, to stderr if 0 (default))
.
.nr doc-inline-debug 0
.
.
.\" NS   doc-debug register (bool)
.\" NS     DEBUG MODE (1 if active, 0 otherwise (default))
.
.nr doc-debug 0
.
.
.\" NS Db macro
.\" NS   start/stop DEBUG MODE (`.Db'/`.Db on'/`.Db off')
.\" NS
.\" NS   without argument, toggle debug status
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-debug
.
.de Db
.  ie !\n[.$] \{\
.    ie !\n[doc-debug] \{\
.      tm DEBUGGING ON
.      nr doc-debug 1
.    \}
.    el \{\
.      tm DEBUGGING OFF
.      nr doc-debug 0
.    \}
.  \}
.  el \{\
.    if "\$1"on" \{\
.      tm DEBUGGING ON
.      nr doc-debug 1
.    \}
.    if "\$1"off" \{\
.      tm DEBUGGING OFF
.      nr doc-debug 0
.    \}
.  \}
..
.
.
.\" NS doc-macro-name string
.\" NS   name of calling request (set in each user requestable macro)
.
.ds doc-macro-name
.
.
.\" NS doc-args-processed register
.\" NS   arguments processed so far
.
.nr doc-args-processed 0
.
.
.\" NS doc-num-args register
.\" NS   number of arguments (must set to \n[.$] prior to
.\" NS   doc-parse-arg-vector request)
.
.nr doc-num-args 0
.
.
.\" NS doc-arg-ptr register
.\" NS   argument pointer (used by doc-parse-args)
.
.nr doc-arg-ptr 0
.
.
.\" NS doc-argXXX string
.\" NS   argument vector
.
.
.\" NS doc-typeXXX string
.\" NS   argument type vector (`macro', `string', `punct-suffix',
.\" NS   `punct-prefix')
.
.
.\" NS doc-spaceXXX string
.\" NS   space vector
.
.
.\" NS doc-parse-args macro
.\" NS   parse arguments (recursive) (`.doc-parse-args arg ...')
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-argXXX, doc-typeXXX, doc-spaceXXX
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpa, doc-reg-dpa, doc-reg-dpa1
.
.de doc-parse-args
.  nr doc-args-processed +1
.
.  ie "\$1"|" \{\
.    if "\*[doc-macro-name]"Op" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"Ar" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"Fl" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"Cm" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"It" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.  \}
.  el .ds doc-arg\n[doc-args-processed] "\$1
.
.  doc-get-arg-type* \n[doc-args-processed]
.  ds doc-type\n[doc-args-processed] \*[doc-arg-type]
.  doc-set-spacing-for-\*[doc-arg-type]
.
.  if \n[doc-debug] \{\
.    if "\*[doc-arg-type]"macro" \{\
.      ds doc-str-dpa macro
.    \}
.    if "\*[doc-arg-type]"string" \{\
.      ds doc-str-dpa string
.    \}
.    if "\*[doc-arg-type]"punct-suffix" \{\
.      ds doc-str-dpa closing punctuation or suffix
.    \}
.    if "\*[doc-arg-type]"punct-prefix" \{\
.      ds doc-str-dpa opening punctuation or prefix
.    \}
.
.    ie \n[doc-inline-debug] \{\
.      br
.      nr doc-reg-dpa \n[.i]u
.      in -\n[doc-reg-dpa]u
.
.      if (\n[doc-args-processed] == 1) \{\
.        nop \f[B]DEBUG(doc-parse-args) MACRO:\f[P] `.\*[doc-macro-name]'
.        nop \f[B]Line #:\f[P] \n[.c]
.      \}
.      nop \t\f[B]Argc:\f[P] \n[doc-args-processed]
.      nop \ \f[B]Argv:\f[P] `\*[doc-arg\n[doc-args-processed]]'
.      nop \ \f[B]Length:\f[P] \n[doc-width]
.      nop \t\f[B]Space:\f[P] `\*[doc-space\n[doc-args-processed]]'
.      nop \ \f[B]Type:\f[P] \*[doc-str-dpa]
.    \}
.    el \{\
.      if (\n[doc-args-processed] == 1) \{\
.        tmc "DEBUG (doc-parse-args)
.        tm1 " MACRO: `.\*[doc-macro-name]'  Line #: \n[.c]
.      \}
.      tmc "  Argc: \n[doc-args-processed]
.      tmc "  Argv: `\*[doc-arg\n[doc-args-processed]]'
.      tm1 "  Length: \n[doc-width]
.      tmc "  Space: `\*[doc-space\n[doc-args-processed]]'
.      tm1 "  Type: \*[doc-str-dpa]
.    \}
.  \}
.
.  ie (\n[.$] == 1) \{\
.    nr doc-arg-ptr 0
.    ie (\n[doc-diversion-level] == 1) \{\
.      if (\n[doc-nesting-level] > 1) .as doc-out-string \*[doc-curr-space]
.    \}
.    el \{\
.      if \n[doc-nesting-level] \{\
.        if !\n[doc-func-arg-count] .as doc-out-string \*[doc-curr-space]
.      \}
.    \}
.
.    ie ddoc-space\n[doc-args-processed] \{\
.      ds doc-curr-space \*[doc-space\n[doc-args-processed]]
.    \}
.    el .ds doc-curr-space
.
.    if \n[doc-debug] \{\
.      nr doc-reg-dpa1 1
.
.      ie \n[doc-inline-debug] \{\
.        nop MACRO REQUEST: \t.\*[doc-macro-name]
.        while (\n[doc-reg-dpa1] <= \n[doc-args-processed]) \{\
.          nop \*[doc-arg\n[doc-reg-dpa1]]
.          nr doc-reg-dpa1 +1
.        \}
.        br
.        in \n[doc-reg-dpa]u
.      \}
.      el \{\
.        tmc "  MACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpa1] <= \n[doc-args-processed]) \{\
.          tmc " \*[doc-arg\n[doc-reg-dpa1]]
.          nr doc-reg-dpa1 +1
.        \}
.        tm
.      \}
.    \}
.  \}
.  el \{\
.    shift
.    doc-parse-args \$@
.  \}
..
.
.
.\" NS doc-parse-arg-vector macro
.\" NS   parse argument vector (recursive): set up doc-typeX, doc-spaceX
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-argXXX, doc-typeXXX, doc-spaceXXX
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpav, doc-reg-dpav, doc-reg-dpav1
.
.de doc-parse-arg-vector
.  nr doc-args-processed +1
.
.  if "\*[doc-arg\n[doc-args-processed]]"|" \{\
.    if "\*[doc-macro-name]"Op" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"Ar" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"Fl" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"Cm" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.    if "\*[doc-macro-name]"It" \{\
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    \}
.  \}
.
.  doc-get-arg-type* \n[doc-args-processed]
.  ds doc-type\n[doc-args-processed] \*[doc-arg-type]
.  doc-set-spacing-for-\*[doc-arg-type]
.
.  if \n[doc-debug] \{\
.    if "\*[doc-arg-type]"macro" \{\
.      ds doc-str-dpav macro
.    \}
.    if "\*[doc-arg-type]"string" \{\
.      ds doc-str-dpav string
.    \}
.    if "\*[doc-arg-type]"punct-suffix" \{\
.      ds doc-str-dpav closing punctuation or suffix
.    \}
.    if "\*[doc-arg-type]"punct-prefix" \{\
.      ds doc-str-dpav opening punctuation or prefix
.    \}
.
.    ie \n[doc-inline-debug] \{\
.      br
.      nr doc-reg-dpav \n[.i]u
.      in -\n[doc-reg-dpav]u
.
.      if (\n[doc-args-processed] == 1) \{\
.        nop \f[B]DEBUG(doc-parse-arg-vector)
.        nop MACRO:\f[P] `.\*[doc-macro-name]'
.        nop \ \f[B]Line #:\f[P] \n[.c]
.      \}
.      nop \t\f[B]Argc:\f[P] \n[doc-args-processed]
.      nop \ \f[B]Argv:\f[P] `\*[doc-arg\n[doc-args-processed]]'
.      nop \ \f[B]Length:\f[P] \n[doc-width]
.      nop \t\f[B]Space:\f[P] `\*[doc-space\n[doc-args-processed]]'
.      nop \ \f[B]Type:\f[P] \*[doc-str-dpav]
.    \}
.    el \{\
.      if (\n[doc-args-processed] == 1) \{\
.        tmc "DEBUG(doc-parse-arg-vector)
.        tm1 " MACRO: `.\*[doc-macro-name]'  Line #: \n[.c]
.      \}
.      tmc "  Argc: \n[doc-args-processed]
.      tmc "  Argv: `\*[doc-arg\n[doc-args-processed]]'
.      tm1 "  Length: \n[doc-width]
.      tmc "  Space: `\*[doc-space\n[doc-args-processed]]'
.      tm1 "  Type: \*[doc-str-dpav]
.    \}
.  \}
.
.  ie (\n[doc-num-args] == 1) \{\
.    nr doc-arg-ptr 0
.    ie (\n[doc-diversion-level] == 1) \{\
.      if (\n[doc-nesting-level] > 1) .as doc-out-string \*[doc-curr-space]
.    \}
.    el \{\
.      if \n[doc-nesting-level] \{\
.        if !\n[doc-func-arg-count] .as doc-out-string \*[doc-curr-space]
.      \}
.    \}
.
.    ie ddoc-space\n[doc-args-processed] \{\
.      ds doc-curr-space \*[doc-space\n[doc-args-processed]]
.    \}
.    el .ds doc-curr-space
.
.    nr doc-num-args 0
.
.    if \n[doc-debug] \{\
.      nr doc-reg-dpav1 1
.
.      ie \n[doc-inline-debug] \{\
.        nop \tMACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpav1] <= \n[doc-args-processed]) \{\
.          nop \*[doc-arg\n[doc-reg-dpav1]]
.          nr doc-reg-dpav1 +1
.        \}
.        br
.        in \n[doc-reg-dpav]u
.      \}
.      el \{\
.        tmc "  MACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpav1] <= \n[doc-args-processed]) \{\
.          tmc " \*[doc-arg\n[doc-reg-dpav1]]
.          nr doc-reg-dpav1 +1
.        \}
.        tm
.      \}
.    \}
.  \}
.  el \{\
.    nr doc-num-args -1
.    doc-parse-arg-vector
.  \}
..
.
.
.\" NS doc-remaining-args macro
.\" NS   output remaining arguments as-is (until `doc-num-args' is zero) to
.\" NS   `doc-out-string' (used by -diag list type)
.
.de doc-remaining-args
.  nr doc-arg-ptr +1
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.
.  ie (\n[doc-num-args] == 1) \{\
.    nr doc-arg-ptr 0
.    nr doc-num-args 0
.  \}
.  el \{\
.    as doc-out-string \*[doc-space]
.    nr doc-num-args -1
.    doc-remaining-args
.  \}
..
.
.
.\" NS doc-append-arg macro
.\" NS   append one argument to argument vector:
.\" NS   `.doc-append-arg [arg] [type]' (used by `.doc-enclose-string')
.
.de doc-append-arg
.  nr doc-args-processed +1
.  ds doc-arg\n[doc-args-processed] "\$1
.  ds doc-type\n[doc-args-processed] \$2
.  doc-set-spacing-for-\$2
..
.
.
.\" NS doc-print-and-reset macro
.\" NS   print doc-out-string and clean up argument vectors
.
.de doc-print-and-reset
.  doc-print-out-string
.  doc-reset-args
..
.
.
.\" NS doc-reset-args macro
.\" NS   reset argument counters
.
.de doc-reset-args
.  nr doc-args-processed 0
.  nr doc-arg-ptr 0
..
.
.
.\" NS doc-print-out-string macro
.\" NS   test for end of vector (i.e. end of line) and print
.\" NS   `doc-out-string' or divert
.
.de doc-print-out-string
.  ie (\n[doc-diversion-level] == 1) \{\
.    if (\n[doc-nesting-level] == 1) \{\
.      nop \&\*[doc-out-string]
.      ds doc-curr-space
.      ds doc-out-string
.    \}
.    if !\n[doc-nesting-level] \{\
.      doc-end-diversion-and-print
.    \}
.  \}
.  el \{\
.    ie !\n[doc-nesting-level] \{\
.      nop \&\*[doc-out-string]
.      ds doc-curr-space
.      ds doc-out-string
.    \}
.    el \{\
.      if \n[doc-space-mode] .if !\n[doc-list-immediate] \{\
.        doc-save-and-divert
.      \}
.    \}
.  \}
.
.  hy
..
.
.
.\" NS doc-diversion diversion
.\" NS   diversion string
.
.
.\" NS doc-saved-out-string string
.\" NS   saved doc-out-string
.
.
.\" NS doc-diversion-input-line-count register
.\" NS   count of lines read from input file
.
.
.\" NS doc-diversion-level register
.\" NS   diversion count
.
.nr doc-diversion-level 0
.
.
.\" NS doc-save-and-divert macro
.\" NS   save doc-out-string and divert
.
.de doc-save-and-divert
.  nr doc-diversion-level +1
.  ds doc-saved-out-string \&\*[doc-out-string]
.  ds doc-out-string
.  nr doc-diversion-input-line-count \n[.c]
.  ev doc-divert-environment
.  fi
.  di doc-diversion
..
.
.
.\" NS doc-end-diversion-and-print macro
.\" NS   end diversion and print
.
.de doc-end-diversion-and-print
.  br
.  di
.  ev
.
.  ie ((\n[.c] - \n[doc-diversion-input-line-count]) > 1) \{\
.    ds doc-str-dedap \&\*[doc-diversion]\c
.    ds doc-out-string \*[doc-saved-out-string]\*[doc-str-dedap]\*[doc-out-string]
.  \}
.  el .ds doc-out-string \*[doc-saved-out-string]\*[doc-out-string]
.
.  nop \&\*[doc-out-string]
.
.  ds doc-out-string
.  nr doc-diversion-level -1
..
.
.
.\" NS doc-curr-font register
.\" NS   saved current font
.\" NS doc-curr-size register
.\" NS   saved current font size
.
.ec
.nr doc-curr-font \n[.f]
.nr doc-curr-size \n[.s]
.eo
.
.
.\" NS Fl user macro
.\" NS   handle flags (appends - and prints flags): `.Fl arg ...'
.\" NS
.\" NS width register `.Fl' set in doc-common
.
.de Fl
.  as doc-out-string \&\*[doc-Fl-font]
.
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      as doc-out-string \|\-\|\f[P]\s[0]
.      doc-print-out-string
.    \}
.    el \{\
.      ds doc-macro-name Fl
.      doc-parse-args \$@
.    \}
.  \}
.
.  if \n[doc-args-processed] \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      as doc-out-string \|\-\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        as doc-out-string \|\-\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.
.        if "\*[doc-type\n[doc-arg-ptr]]"punct-suffix" \{\
.          as doc-out-string \|\-\|
.        \}
.        doc-flag-recursion
.      \}
.    \}
.  \}
..
.
.
.\" NS doc-flag-recursion macro
.\" NS   `Fl' flag recursion routine (special handling)
.\" NS
.\" NS local variables:
.\" NS   doc-str-dfr, doc-reg-dfr
.
.de doc-flag-recursion
.  ds doc-str-dfr \*[doc-type\n[doc-arg-ptr]]
.
.  hy 0
.
.  ie "\*[doc-str-dfr]"macro" \{\
.    as doc-out-string \&\f[P]\s[0]
.    \*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    nr doc-reg-dfr \n[doc-arg-ptr]
.    ie "\*[doc-str-dfr]"string" \{\
.      ie !"\*[doc-arg\n[doc-arg-ptr]]"\*[Ba]" \{\
.        ie !"\*[doc-arg\n[doc-arg-ptr]]"\f[R]|\f[P]" \{\
.          ie "\*[doc-arg\n[doc-arg-ptr]]"-" \{\
.            as doc-out-string \|\-\^\-\|
.          \}
.          el .as doc-out-string \|\-\*[doc-arg\n[doc-arg-ptr]]
.        \}
.        el .as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el .as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    \}
.
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      if "\*[doc-str-dfr]"punct-prefix" .as doc-out-string \|\-
.      as doc-out-string \&\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"punct-suffix" \{\
.        ie "\*[doc-type\n[doc-reg-dfr]]"punct-prefix" \{\
.          as doc-out-string \|\-
.        \}
.        el .as doc-out-string \*[doc-space\n[doc-reg-dfr]]
.      \}
.      el .as doc-out-string \*[doc-space\n[doc-reg-dfr]]
.
.      shift
.      doc-flag-recursion \$@
.    \}
.  \}
..
.
.
.\" NS doc-print-recursive macro
.\" NS   general name recursion routine (print remaining arguments)
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpr, doc-reg-dpr
.
.de doc-print-recursive
.  ds doc-str-dpr \*[doc-type\n[doc-arg-ptr]]
.
.  hy 0
.
.  ie "\*[doc-str-dpr]"macro" \{\
.    as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    nr doc-reg-dpr \n[doc-arg-ptr]
.
.    ie "\*[doc-str-dpr]"string" \{\
.      as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    \}
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      doc-print-and-reset
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      as doc-out-string \*[doc-space\n[doc-reg-dpr]]
.      doc-print-recursive
.    \}
.  \}
..
.
.
.\" NS Ar user macro
.\" NS   command line `argument' macro: `.Ar [args ...]'
.\" NS
.\" NS width register `.Ar' set in doc-common
.
.de Ar
.  as doc-out-string \&\*[doc-Ar-font]
.
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      as doc-out-string \&file\ ...\f[P]\s[0]
.      doc-print-out-string
.    \}
.    el \{\
.      ds doc-macro-name Ar
.      doc-parse-args \$@
.    \}
.  \}
.
.  if \n[doc-args-processed] \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      as doc-out-string \&file\ ...\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        as doc-out-string \&file\ ...\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.        if "\*[doc-type\n[doc-arg-ptr]]"punct-suffix" \{\
.          as doc-out-string \&file\ ...
.        \}
.        doc-print-recursive
.      \}
.    \}
.  \}
..
.
.
.\" NS Ad user macro
.\" NS   Addresses
.\" NS
.\" NS width register `.Ad' set in doc-common
.
.de Ad
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Ad address ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Ad
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Ad-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Cd user macro
.\" NS   Config declaration (for section 4 SYNOPSIS) (not callable)
.\" NS
.\" NS width register `.Cd' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Cd
.\"
.\" needs work - not very translatable
.
.de Cd
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] .tm Usage: .Cd Configuration file declaration (#\n[.c])
.    el \{\
.      ds doc-macro-name Cd
.
.      nr doc-reg-Cd 1
.      while (\n[doc-reg-Cd] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Cd] "\$[\n[doc-reg-Cd]]
.        nr doc-reg-Cd +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  br
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Nm-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    ie \n[doc-in-synopsis-section] \{\
.      if "\*[doc-macro-name]"Cd" \{\
.        rs
.        ie (\n[doc-in-synopsis-section] > 1) .br
.        el \{\
.          if !\n[doc-indent-synopsis] \{\
.            nr doc-indent-synopsis \n[doc-display-indent]u
.          \}
.        \}
.        in +\n[doc-indent-synopsis]u
.        ti -\n[doc-indent-synopsis]u
.        nr doc-in-synopsis-section +1
.      \}
.
.      doc-print-recursive
.      in -\n[doc-indent-synopsis]u
.    \}
.    el .doc-print-recursive
.  \}
..
.
.
.\" NS Cm user macro
.\" NS   Interactive command modifier (flag)
.\" NS
.\" NS width register `.Cm' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Cm
.
.de Cm
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tmc Usage: .Cm Interactive command modifier ...
.      tm1 " \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Cm
.
.      nr doc-reg-Cm 1
.      while (\n[doc-reg-Cm] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Cm] "\$[\n[doc-reg-Cm]]
.        nr doc-reg-Cm +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Cm-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Dv user macro
.\" NS   define variable
.\" NS
.\" NS width register `.Dv' set in doc-common
.
.de Dv
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Dv define_variable ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Dv
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Er-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Em user macro
.\" NS   emphasis
.\" NS
.\" NS width register `.Em' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Em
.
.de Em
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Em text ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Em
.
.      nr doc-reg-Em 1
.      while (\n[doc-reg-Em] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Em] "\$[\n[doc-reg-Em]]
.        nr doc-reg-Em +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Em-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.\}
..
.
.
.\" NS Er user macro
.\" NS   errno type
.\" NS
.\" NS width register `.Em' set in doc-common
.
.de Er
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Er ERRNOTYPE ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Er
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Er-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ev user macro
.\" NS   environment variable
.\" NS
.\" NS width register `.Ev' set in doc-common
.
.de Ev
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Ev ENVIRONMENT_VARIABLE ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Ev
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Ev-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-declaration-count register
.\" NS   subroutine test (in synopsis only)
.
.nr doc-declaration-count 0
.
.
.\" NS Fd user macro
.\" NS   function declaration - not callable (& no err check)
.\" NS
.\" NS width register `.Fd' set in doc-common
.
.de Fd
.  ds doc-macro-name Fd
.
.  if \n[doc-in-synopsis-section] \{\
.    \" if a variable type was the last thing given, want vertical space
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.    \" if a subroutine was the last thing given, want vertical space
.    if \n[doc-function-count] \{\
.      ie !\n[doc-declaration-count] \{\
.        doc-paragraph
.        rs
.      \}
.      el .br
.    \}
.    nr doc-declaration-count +1
.  \}
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.  nop \&\*[doc-Fd-font]\$*
.  br
.  ft \n[doc-curr-font]
.  fs \n[doc-curr-size]
..
.
.
.\" NS Fr user macro
.\" NS   function return value - not callable (at the moment)
.\" NS
.\" NS width register `.Fr' set in doc-common
.
.de Fr
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Fr Function_return_value... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Fr
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Ar-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ic user macro
.\" NS   interactive command
.\" NS
.\" NS width register `.Ic' set in doc-common
.
.de Ic
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Ic Interactive command ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Ic
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Ic-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Li user macro
.\" NS   literals
.\" NS
.\" NS width register `.Li' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Li
.
.de Li
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage .Li argument ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Li
.
.      nr doc-reg-Li 1
.      while (\n[doc-reg-Li] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Li] "\$[\n[doc-reg-Li]]
.        nr doc-reg-Li +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Li-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Or user macro
.\" NS   pipe symbol (OR)
.\" NS
.\" NS width register `.Or' set in doc-common
.
.de Or
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] .tm Usage: .Or ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name Or
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Ic-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ms user macro
.\" NS   math symbol
.\" NS
.\" NS width register `.Ms' set in doc-common
.
.de Ms
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Ms Math symbol ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Ms
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Sy-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-command-name string
.\" NS   save first invocation of .Nm
.
.ds doc-command-name
.
.
.\" NS Nm user macro
.\" NS   name of command or page topic
.\" NS
.\" NS width register `.Nm' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Nm
.
.de Nm
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      ie "\*[doc-command-name]"" \{\
.        tm Usage: .Nm Name(s) ... \*[doc-punct-chars] (#\n[.c])
.      \}
.      el \&\*[doc-Nm-font]\*[doc-command-name]\f[P]\s[0]
.    \}
.    el \{\
.      ds doc-macro-name Nm
.
.      nr doc-reg-Nm 1
.      while (\n[doc-reg-Nm] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Nm] "\$[\n[doc-reg-Nm]]
.        nr doc-reg-Nm +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if \n[doc-args-processed] \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      as doc-out-string \&\*[doc-Nm-font]\*[doc-command-name]\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      as doc-out-string \&\*[doc-Nm-font]
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        as doc-out-string \&\*[doc-command-name]\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.        if \n[doc-in-synopsis-section] \{\
.          if "\*[doc-macro-name]"Nm" \{\
.            rs
.            in -\n[doc-indent-synopsis]u
.            ie (\n[doc-in-synopsis-section] > 1) .br
.            el \{\
.              if !\n[doc-indent-synopsis] \{\
.                doc-get-width \$1
.                nr doc-indent-synopsis ((\n[doc-width]u + 1u) * \n[doc-fixed-width]u)
.              \}
.            \}
.            in +\n[doc-indent-synopsis]u
.            ti -\n[doc-indent-synopsis]u
.            nr doc-in-synopsis-section +1
.          \}
.        \}
.        if "\*[doc-command-name]"" \{\
.          ds doc-command-name "\*[doc-arg\n[doc-arg-ptr]]
.        \}
.        doc-print-recursive
.      \}
.    \}
.  \}
..
.
.
.\" NS Pa user macro
.\" NS   pathname: `.Pa [arg ...]'
.\" NS
.\" NS width register `.Pa' set in doc-common
.
.de Pa
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \&\*[doc-Pa-font]~\f[P]\s[0]
.    el \{\
.      ds doc-macro-name Pa
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Pa-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Sy user macro
.\" NS   symbolics
.\" NS
.\" NS width register `.Sy' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Sy
.
.de Sy
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Sy symbolic_text ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Sy
.
.      nr doc-reg-Sy 1
.      while (\n[doc-reg-Sy] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Sy] "\$[\n[doc-reg-Sy]]
.        nr doc-reg-Sy +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Sy-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Tn user macro
.\" NS   trade name
.\" NS
.\" NS width register `.Tn' set in doc-common
.
.de Tn
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Tn Trade_name(s) ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Tn
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Tn-font-shape]\*[doc-Tn-font-size]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS nN user macro
.\" NS   trade name for inside of reference
.\" NS
.\" NS width register `.nN' set in doc-common
.
.de nN
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .nN Trade_name(s) ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name nN
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Tn-font-size]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS Va user macro
.\" NS   variable name
.\" NS
.\" NS width register `.Va' set in doc-common
.
.de Va
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Va variable_name(s) ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Va
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Va-font]
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS No user macro
.\" NS   normal text macro (default text style if mess up)
.\" NS
.\" NS width register `.No' set in doc-common
.
.de No
.  as doc-out-string \*[doc-No-font]
.
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] .tm Usage: .No must be called with arguments (#\n[.c])
.    el \{\
.      ds doc-macro-name No
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.      \*[doc-arg\n[doc-arg-ptr]]
.    \}
.    el \{\
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      doc-print-recursive
.    \}
.  \}
..
.
.
.\" NS Op user macro
.\" NS   option expression
.\" NS
.\" NS width register `.Op' set in doc-common
.
.de Op
.  if !\n[doc-args-processed] \{\
.    ds doc-macro-name Op
.  \}
.
.  ds doc-quote-left "\*[doc-left-bracket]
.  ds doc-quote-right "\*[doc-right-bracket]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Aq user macro
.\" NS   enclose string in angle brackets
.\" NS
.\" NS width register `.Aq' set in doc-common
.
.de Aq
.  if !\n[doc-args-processed] .ds doc-macro-name Aq
.
.  ds doc-quote-left <
.  ds doc-quote-right >
.
.  doc-enclose-string \$@
..
.
.
.\" NS Bq user macro
.\" NS   enclose string in square brackets
.\" NS
.\" NS width register `.Bq' set in doc-common
.
.de Bq
.  if !\n[doc-args-processed] .ds doc-macro-name Bq
.
.  ds doc-quote-left "\*[doc-left-bracket]
.  ds doc-quote-right "\*[doc-right-bracket]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Dq macro
.\" NS   enclose string in double quotes
.\" NS
.\" NS width register `.Dq' set in doc-common
.
.de Dq
.  if !\n[doc-args-processed] .ds doc-macro-name Dq
.
.  ds doc-quote-left "\*[Lq]
.  ds doc-quote-right "\*[Rq]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Eq user macro
.\" NS   enclose string in user-defined quotes (args 1 and 2)
.\" NS
.\" NS width register `.Eq' set in doc-common
.
.de Eq
.  if !\n[doc-args-processed] .ds doc-macro-name Eq
.
.  ds doc-quote-left "\$1
.  ds doc-quote-right "\$2
.
.  shift 2
.  doc-enclose-string \$@
..
.
.
.\" NS Pq user macro
.\" NS   enclose string in parentheses
.\" NS
.\" NS width register `.Pq' set in doc-common
.
.de Pq
.  if !\n[doc-args-processed] .ds doc-macro-name Pq
.
.  ds doc-quote-left "\*[doc-left-parenthesis]
.  ds doc-quote-right "\*[doc-right-parenthesis]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Ql user macro
.\" NS   quoted literal
.\"
.\"   is in file doc-[dit|n]roff (too large an if-else to carry along
.\"   recursively for `if n ...')
.
.
.\" NS Qq macro
.\" NS   enclose string in straight double quotes
.\" NS
.\" NS width register `.Qq' set in doc-common
.
.de Qq
.  if !\n[doc-args-processed] .ds doc-macro-name Qq
.
.  ds doc-quote-left "\*[q]
.  ds doc-quote-right "\*[q]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Sq user macro
.\" NS   enclose string in single quotes
.\" NS
.\" NS width register `.Sq' set in doc-common
.
.de Sq
.  if !\n[doc-args-processed] .ds doc-macro-name Sq
.
.  ds doc-quote-left "\*[doc-left-singlequote]
.  ds doc-quote-right "\*[doc-right-singlequote]
.
.  doc-enclose-string \$@
..
.
.
.\" NS doc-temp-args-processed register
.\" NS   for data transfer to/from doc-skip-punct-backwards
.
.nr doc-temp-args-processed 0
.
.
.\" NS doc-enclose-string macro
.\" NS   enclose string with given args (e.g. [ and ])
.\" NS
.\" NS requires:
.\" NS   doc-quote-left (to be set by calling macro)
.\" NS   doc-quote-right (to be set by calling macro)
.
.de doc-enclose-string
.  \" .tm doc-enclose-string beg:
.  \" .tm1 "  arg(doc-arg[\n[doc-arg-ptr]])==\*[doc-arg\n[doc-arg-ptr]]
.  \" .tm1 "  doc-nesting-level==\n[doc-nesting-level]
.  \" .tm1 "  doc-diversion-level==\n[doc-diversion-level]
.  \" .tm1 "  doc-saved-list-immediate==\n[doc-saved-list-immediate]
.  \" .tm1 "  doc-args-processed==\n[doc-args-processed]
.
.  ie !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      as doc-out-string \&\*[doc-quote-left]\*[doc-quote-right]
.      doc-print-out-string
.    \}
.    el \{\
.      \".as doc-macro-name (doc-enclose-string)
.      doc-parse-args \$@
.      as doc-out-string \&\*[doc-quote-left]
.    \}
.  \}
.  el \{\
.    as doc-out-string \&\*[doc-quote-left]
.  \}
.
.  if \n[doc-args-processed] \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      as doc-out-string \&\*[doc-quote-right]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie "\*[doc-type\n[doc-args-processed]]"punct-suffix" \{\
.        nr doc-temp-args-processed (\n[doc-args-processed] - 1)
.        doc-skip-punct-backwards
.        nr doc-temp-args-processed +1
.        ds doc-arg\n[doc-temp-args-processed] \&\*[doc-quote-right]\*[doc-arg\n[doc-temp-args-processed]]
.        nr doc-temp-args-processed 0
.      \}
.      el .doc-append-arg "\*[doc-quote-right]" punct-suffix
.      nr doc-arg-ptr +1
.      if "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      if d doc-type\n[doc-arg-ptr] \{\
.        if !"\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.          nr doc-arg-ptr -1
.          No
.        \}
.      \}
.    \}
.  \}
..
.
.
.\" NS doc-skip-punct-backwards macro
.\" NS   vector routine (for `doc-enclose-string': trace backwards past
.\" NS   trailing punctuation)
.
.de doc-skip-punct-backwards
.  if "\*[doc-type\n[doc-temp-args-processed]]"punct-suffix" \{\
.    nr doc-temp-args-processed -1
.    doc-skip-punct-backwards
.  \}
..
.
.
.\" NS Ao user macro
.\" NS   angle open
.\" NS
.\" NS width register `.Ao' set in doc-common
.
.de Ao
.  if !\n[doc-args-processed] .ds doc-macro-name Ao
.
.  ds doc-quote-left <
.
.  doc-enclose-open \$@
..
.
.
.\" NS Ac user macro
.\" NS   angle close
.\" NS
.\" NS width register `.Ac' set in doc-common
.
.de Ac
.  if !\n[doc-args-processed] .ds doc-macro-name Ac
.
.  ds doc-quote-right >
.
.  doc-enclose-close \$@
..
.
.
.\" NS Bo user macro
.\" NS   bracket open
.\" NS
.\" NS width register `.Bo' set in doc-common
.
.de Bo
.  if !\n[doc-args-processed] .ds doc-macro-name Bo
.
.  ds doc-quote-left [
.
.  doc-enclose-open \$@
..
.
.
.\" NS Bc user macro
.\" NS   bracket close
.\" NS
.\" NS width register `.Bc' set in doc-common
.
.de Bc
.  if !\n[doc-args-processed] .ds doc-macro-name Bc
.
.  ds doc-quote-right ]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Do user macro
.\" NS   double quote open
.\" NS
.\" NS width register `.Do' set in doc-common
.
.de Do
.  if !\n[doc-args-processed] .ds doc-macro-name Do
.
.  ds doc-quote-left "\*[Lq]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Dc macro
.\" NS   double quote close
.\" NS
.\" NS width register `.Dc' set in doc-common
.
.de Dc
.  if !\n[doc-args-processed] .ds doc-macro-name Dc
.
.  ds doc-quote-right "\*[Rq]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Eo user macro
.\" NS   enclose open (using first argument as beginning of enclosion)
.\" NS
.\" NS width register `.Eo' set in doc-common
.
.de Eo
.  if !\n[doc-args-processed] .ds doc-macro-name Eo
.
.  ds doc-quote-left "\$1
.
.  shift
.  doc-enclose-open \$@
..
.
.
.\" NS Ec user macro
.\" NS   enclose close (using first argument as end of enclosion)
.\" NS
.\" NS width register `.Ec' set in doc-common
.
.de Ec
.  if !\n[doc-args-processed] .ds doc-macro-name Ec
.
.  ds doc-quote-right "\$1
.
.  shift
.  doc-enclose-close \$@
..
.
.
.\" NS Oo user macro
.\" NS   option open
.\" NS
.\" NS width register `.Oo' set in doc-common
.
.de Oo
.  if !\n[doc-args-processed] .ds doc-macro-name Oo
.
.  ds doc-quote-left [
.
.  doc-enclose-open \$@
..
.
.
.\" NS Oc user macro
.\" NS   option close
.\" NS
.\" NS width register `.Oc' set in doc-common
.
.de Oc
.  if !\n[doc-args-processed] .ds doc-macro-name Oc
.
.  ds doc-quote-right ]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Po user macro
.\" NS   parenthesis open
.\" NS
.\" NS width register `.Po' set in doc-common
.
.de Po
.  if !\n[doc-args-processed] .ds doc-macro-name Po
.
.  ds doc-quote-left (
.
.  doc-enclose-open \$@
..
.
.
.\" NS Pc user macro
.\" NS   parenthesis close
.\" NS
.\" NS width register `.Pc' set in doc-common
.
.de Pc
.  if !\n[doc-args-processed] .ds doc-macro-name Pc
.
.  ds doc-quote-right )
.
.  doc-enclose-close \$@
..
.
.
.\" NS Qo user macro
.\" NS   straight double quote open
.\" NS
.\" NS width register `.Qo' set in doc-common
.
.de Qo
.  if !\n[doc-args-processed] .ds doc-macro-name Qo
.
.  ds doc-quote-left "\*[q]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Qc user macro
.\" NS   straight double quote close
.\" NS
.\" NS width register `.Qc' set in doc-common
.
.de Qc
.  if !\n[doc-args-processed] .ds doc-macro-name Qc
.
.  ds doc-quote-right "\*[q]
.
.  doc-enclose-close \$@
..
.
.
.\" NS So user macro
.\" NS   single quote open
.\" NS
.\" NS width register `.So' set in doc-common
.
.de So
.  if !\n[doc-args-processed] .ds doc-macro-name So
.
.  ds doc-quote-left "\*[doc-left-singlequote]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Sc user macro
.\" NS   single quote close
.\" NS
.\" NS width register `.Sc' set in doc-common
.
.de Sc
.  if !\n[doc-args-processed] .ds doc-macro-name Sc
.
.  ds doc-quote-right "\*[doc-right-singlequote]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Xo user macro
.\" NS   extend open
.\" NS
.\" NS width register `.Xo' set in doc-common
.
.de Xo
.  if !\n[doc-args-processed] .ds doc-macro-name Xo
.  \" .nr doc-in-macro 1
.
.  ds doc-quote-left
.
.  doc-enclose-open \$@
..
.
.
.\" NS Xc user macro
.\" NS   extend close
.\" NS
.\" NS width register `.Xc' set in doc-common
.
.de Xc
.  \" .nr doc-in-macro 0
.  if !\n[doc-args-processed] .ds doc-macro-name Xc
.
.  ds doc-quote-right
.
.  doc-enclose-close \$@
..
.
.
.\" NS doc-nesting-level register
.\" NS   (extension possible)
.
.nr doc-nesting-level 0
.
.
.\" NS doc-enclose-open macro
.\" NS   enclose string open
.
.de doc-enclose-open
.  nr doc-nesting-level +1
.
.  \" .tm doc-enclose-open
.  \" .tmc "  last arg==
.  \" .tm doc-arg[\n[doc-args-processed]]==\*[doc-arg\n[doc-args-processed]]
.  \" .tm1 "  doc-arg-ptr==\n[doc-arg-ptr]
.  \" .tm1 "  doc-nesting-level==\n[doc-nesting-level]
.  \" .tm1 "  doc-diversion-level==\n[doc-diversion-level]
.
.  ie !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      doc-parse-args \$@
.      as doc-out-string \&\*[doc-quote-left]
.    \}
.    el \{\
.      as doc-out-string \&\*[doc-quote-left]
.
.      if !\n[doc-diversion-level] .if \n[doc-space-mode] \{\
.        nr doc-diversion-level +1
.        ds doc-saved-out-string \&\*[doc-out-string]
.        ds doc-out-string
.        nr doc-diversion-input-line-count \n[.c]
.        ev doc-divert-environment
.        fi
.        di doc-diversion
.      \}
.    \}
.  \}
.  el \{\
.    as doc-out-string \&\*[doc-quote-left]
.  \}
.
.  ie \n[doc-args-processed] \{\
.    if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-arg-ptr -1
.        No
.      \}
.    \}
.
.    if (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      if \n[doc-list-immediate] \{\
.        \" .tm SETTING doc-saved-list-immediate!
.        nr doc-saved-list-immediate 1
.      \}
.      \" .\" .ds doc-curr-space
.      \" CHANGED .ds doc-curr-space \*[doc-soft-space]
.      doc-reset-args
.    \}
.  \}
.  el \{\
.    if (\n[doc-nesting-level] > 1) .as doc-out-string \*[doc-space]
.  \}
..
.
.
.ds doc-saved-list-type
.
.
.\" NS doc-enclose-close macro
.\" NS   enclose string close
.\" NS
.\" NS local variable:
.\" NS   doc-str-dec
.
.de doc-enclose-close
.  nr doc-nesting-level -1
.
.  \" .tm doc-enclose-close
.  \" .tmc "  last arg==
.  \" .tm doc-arg[\n[doc-args-processed]]==\*[doc-arg\n[doc-args-processed]]
.  \" .tm1 "  doc-arg-ptr==\n[doc-arg-ptr]
.  \" .tm1 "  doc-nesting-level==\n[doc-nesting-level]
.  \" .tm1 "  doc-diversion-level==\n[doc-diversion-level]
.
.  as doc-out-string \&\*[doc-quote-right]
.
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      doc-parse-args \$@
.    \}
.    el \{\
.      doc-print-out-string
.      if !"\*[doc-saved-list-type]"" \{\
.        doc-\*[doc-list-stack\n[doc-list-depth]]
.        nr doc-saved-list-immediate 0
.        ds doc-saved-list-type
.      \}
.    \}
.  \}
.
.  if (\n[doc-args-processed] > 0) \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      ie !\n[doc-nesting-level] .doc-print-and-reset
.      el .doc-reset-args
.    \}
.    el \{\
.      nr doc-str-dec (\n[doc-arg-ptr] + 1)
.      if "\*[doc-type\n[doc-str-dec]]"string" \{\
.        as doc-out-string \*[doc-space\n[doc-args-processed]]
.      \}
.
.      \" .tm CURRENT
.      \" .tm1 "  doc-arg-ptr==\*[doc-arg\n[doc-arg-ptr]]
.      \" .tm1 "  ap+1==\*[doc-arg\n[doc-str-dec]]
.      \" .tm1 "  doc-list-immediate==\n[doc-list-immediate]
.      \" .tm1 "  doc-saved-list-immediate==\n[doc-saved-list-immediate]
.
.      if \n[doc-list-immediate] \{\
.        \" .tm UNSETTING doc-saved-list-immediate==\n[doc-saved-list-immediate]!
.        if \n[doc-saved-list-immediate] \{\
.          nr doc-saved-list-immediate 0
.        \}
.        \" .tm NOW doc-saved-list-immediate==\n[doc-saved-list-immediate]!
.      \}
.      No
.    \}
.  \}
..
.
.
.\" NS Pf user macro
.\" NS   prefix (calls .doc-make-prefix): `.Pf prefix arg ...'
.\" NS
.\" NS width register `.Pf' set in doc-common
.
.de Pf
.  if !\n[doc-args-processed] .ds doc-macro-name Pf
.
.  ds doc-quote-left "\$1
.
.  shift
.  doc-make-prefix \$@
..
.
.
.\" NS doc-make-prefix macro
.\" NS   prefix (for prefixing open quotes, brackets, etc.)
.
.de doc-make-prefix
.  ie !\n[doc-args-processed] \{\
.    as doc-out-string \&\*[doc-quote-left]
.    ie (\n[.$] < 2) \{\
.      tm mdoc warning: .Pf: missing arguments (#\n[.c])
.      doc-print-out-string
.    \}
.    el .doc-parse-args \$@
.  \}
.  el \{\
.    ie ((\n[doc-args-processed] - \n[doc-arg-ptr]) > 1) \{\
.      nr doc-arg-ptr +1
.      as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \}
.    el .tm mdoc warning: .Pf: trailing prefix (#\n[.c])
.  \}
.
.  if \n[doc-args-processed] \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) .doc-print-and-reset
.    el \{\
.      nr doc-arg-ptr +1
.      doc-do-\*[doc-type\n[doc-arg-ptr]]
.    \}
.  \}
..
.
.
.\" NS Ns user macro
.\" NS   remove space (space removal done by .doc-parse-args or
.\" NS   .doc-parse-arg-vector)
.\" NS
.\" NS width register `.Ns' set in doc-common
.
.de Ns
.  if !\n[doc-args-processed] \{\
.    ds doc-macro-name Ns
.    ie \n[.$] .doc-parse-args \$@
.    el .tm Usage: .Ns must be called with arguments (#\n[.c])
.  \}
.
.  No
..
.
.
.\" NS Ap user macro
.\" NS   append an apostrophe
.\" NS
.\" NS width register `.Ap' set in doc-common
.
.de Ap
.  if !\n[doc-args-processed] \{\
.    tm Usage: `Ap' cannot be first request on a line (no `.Ap') (#\n[.c])
.  \}
.
.  as doc-out-string \&'
.  No
..
.
.
.\" NS doc-space string
.\" NS   current inter-argument space
.
.ds doc-space \*[doc-soft-space]
.
.
.\" NS doc-soft-space string
.\" NS   soft (stretchable) space (defined in doc-common)
.
.\" NS doc-hard-space string
.\" NS   hard (unpaddable) space (defined in doc-common)
.
.
.\" NS doc-set-hard-space macro
.\" NS   set current space string to hard (unpaddable) space.
.
.de doc-set-hard-space
.  ds doc-space \*[doc-hard-space]
..
.
.
.\" NS doc-set-soft-space macro
.\" NS   set current space string to soft space (troff limitation)
.
.de doc-set-soft-space
.  ds doc-space \*[doc-soft-space]
..
.
.
.\" NS doc-space-mode register
.\" NS   default is one (space mode on)
.
.nr doc-space-mode 1
.
.
.\" NS Sm user macro
.\" NS   space mode
.\" NS
.\" NS width register `.Sm' set in doc-common
.
.de Sm
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] .tm Usage: .Sm [off | on] (#\n[.c])
.    el \{\
.      ds doc-macro-name Sm
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > 0) \{\
.    nr doc-arg-ptr +1
.    if "\*[doc-arg\n[doc-arg-ptr]]"on" \{\
.      ds doc-space \*[doc-soft-space]
.      nr doc-space-mode 1
.    \}
.    if "\*[doc-arg\n[doc-arg-ptr]]"off" \{\
.      ds doc-space
.      ds doc-curr-space
.\" XXX
.      rm doc-space1 doc-space2 doc-space3 doc-space4
.      rm doc-space5 doc-space6 doc-space7 doc-space8 doc-space9
.
.      nr doc-space-mode 0
.    \}
.
.    ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.      No
.    \}
.    el .doc-reset-args
.  \}
..
.
.
.\" NS   doc-arg-type string
.\" NS     argument type
.
.ds doc-arg-type
.
.
.\" NS doc-get-arg-type macro
.\" NS   get argument type (`macro', `string', `punct-suffix', or
.\" NS   `punct-prefix')
.\" NS
.\" NS modifies:
.\" NS   doc-arg-type
.
.de doc-get-arg-type
.  ds doc-arg-type
.  ie ((\n[doc-width] > 2) : (\A'\$1' == 0)) \{\
.    ds doc-arg-type string
.  \}
.  el \{\
.    if (\n[doc-width] == 1) \{\
.      ie dz\$1 \{\
.        ie "\*[z\$1]"punct-suffix" \{\
.          ds doc-arg-type punct-suffix
.        \}
.        el \{
.          ie "\*[z\$1]"punct-prefix" \{\
.            ds doc-arg-type punct-prefix
.          \}
.          el .ds doc-arg-type string
.        \}
.      \}
.      el .ds doc-arg-type string
.    \}
.    if (\n[doc-width] == 2) \{\
.      ie r\$1 \{\
.        ie \n[\$1] \{\
.          ds doc-arg-type macro
.        \}
.        el .ds doc-arg-type string
.      \}
.      el .ds doc-arg-type string
.    \}
.  \}
..
.
.
.\" NS doc-get-arg-type* macro
.\" NS   same as `.doc-get-arg-type' but uses doc-arg[1-9] strings
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-arg-type
.
.de doc-get-arg-type*
.  ds doc-arg-type
.  doc-get-arg-width \$1
.
.  ie ((\n[doc-width] > 2) : (\A'\*[doc-arg\$1]' == 0)) \{\
.    ds doc-arg-type string
.  \}
.  el \{\
.    if (\n[doc-width] == 1) \{\
.      ie dz\*[doc-arg\$1] \{\
.        ie "\*[z\*[doc-arg\$1]]"punct-suffix" \{\
.          ds doc-arg-type punct-suffix
.        \}
.        el \{\
.          ie "\*[z\*[doc-arg\$1]]"punct-prefix" \{\
.            ds doc-arg-type punct-prefix
.          \}
.          el .ds doc-arg-type string
.        \}
.      \}
.      el .ds doc-arg-type string
.    \}
.    if (\n[doc-width] == 2) \{\
.      ie r\*[doc-arg\$1] \{\
.        ie \n[\*[doc-arg\$1]] \{\
.          ds doc-arg-type macro
.        \}
.        el .ds doc-arg-type string
.      \}
.      el .ds doc-arg-type string
.    \}
.  \}
..
.
.
.\" NS doc-set-spacing-for- macro
.\" NS   catch errors (non-existent type)
.
.de doc-set-spacing-for-
.  tmc mdoc error: bogus type (can't set space
.  tm1 " `\*[doc-arg\n[doc-args-processed]]') (#\n[.c])
..
.
.
.\" NS doc-set-spacing-for-macro macro
.\" NS   set spacing for macros
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dssfm
.
.de doc-set-spacing-for-macro
.  \" closing macros like .Ac, Bc., etc. have value 3
.  if (\n[\*[doc-arg\n[doc-args-processed]]] == 3) \{\
.    nr doc-reg-dssfm (\n[doc-args-processed] - 1)
.    ds doc-space\n[doc-reg-dssfm]
.    ds doc-space\n[doc-args-processed] \*[doc-space]
.  \}
.
.  \" macros like .Ap and .Ns have value 2
.  if (\n[\*[doc-arg\n[doc-args-processed]]] == 2) \{\
.    nr doc-reg-dssfm (\n[doc-args-processed] - 1)
.    ds doc-space\n[doc-reg-dssfm]
.  \}
..
.
.
.\" NS doc-set-spacing-for-string macro
.\" NS   set spacing for strings
.
.de doc-set-spacing-for-string
.  ds doc-space\n[doc-args-processed] \*[doc-space]
..
.
.
.\" NS doc-set-spacing-for-punct-suffix macro
.\" NS   set spacing for punctuation suffixes
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dssfps
.
.de doc-set-spacing-for-punct-suffix
.  if (\n[doc-args-processed] > 1) \{\
.    nr doc-reg-dssfps (\n[doc-args-processed] - 1)
.    ds doc-space\n[doc-reg-dssfps]
.  \}
.
.  ds doc-space\n[doc-args-processed] \*[doc-space]
..
.
.
.\" NS doc-set-spacing-for-punct-prefix macro
.\" NS   set spacing for punctuation prefixes
.
.de doc-set-spacing-for-punct-prefix
..
.
.
.\" type switches (on current argument doc-arg-ptr)
.
.\" NS doc-do- macro
.\" NS   catch errors (non-existent type)
.
.de doc-do-
.  tmc mdoc error: bogus type (can't determine
.  tm1 " `\*[doc-arg\n[doc-args-processed]]') (#\n[.c])
..
.
.
.\" NS doc-do-macro macro
.\" NS   call request if macro
.
.de doc-do-macro
.  \*[doc-arg\n[doc-arg-ptr]]
..
.
.
.\" NS doc-do-string macro
.\" NS   call .No if string
.
.de doc-do-string
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-punct-suffix macro
.\" NS   call .No if punctuation suffix
.
.de doc-do-punct-suffix
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-punct-prefix macro
.\" NS   call .No if punctuation prefix
.
.de doc-do-punct-prefix
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-xref-macro macro
.\" NS   ignore if macro
.
.de doc-do-xref-macro
..
.
.
.\" NS doc-do-xref-string macro
.\" NS   ignore if string
.
.de doc-do-xref-string
..
.
.
.\" NS doc-do-xref-punct-suffix macro
.\" NS   append if punctuation suffix
.
.de doc-do-xref-punct-suffix
.  as doc-out-string \*[doc-arg\n[doc-arg-ptr]]
.  nr doc-arg-ptr +1
.  \" XXX ?
.  n\\C\\n(aP
..
.
.
.\" NS doc-do-xref-punct-prefix macro
.\" NS   append if punctuation prefix
.
.de doc-do-xref-punct-prefix
.  as doc-out-string \*[doc-arg\n[doc-arg-ptr]]
.  nr doc-arg-ptr +1
.  \" XXX ?
.  n\\C\\n(aP
..
.
.
.\" NS Bf user macro
.\" NS   begin font mode (will be begin-mode/end-mode in groff & TeX)
.\" NS
.\" NS width register `.Bf' set in doc-common
.
.de Bf
.  ds doc-macro-name Bf
.
.  ie \n[.$] \{\
.    nr bF \n[.f]
.    nr bZ \n[.s]
.
.    if "\$1"Em" \&\*[doc-Em-font]\c
.    if "\$1"Li" \&\*[doc-Li-font]\c
.    if "\$1"Sy" \&\*[doc-Sy-font]\c
.    if "\$1"-emphasis" \&\*[doc-Em-font]\c
.    if "\$1"-literal" \&\*[doc-Li-font]\c
.    if "\$1"-symbolic" \&\*[doc-Sy-font]\c
.  \}
.  el \{\
.    tm Usage .Bf [Em | -emphasis | Li | -literal | Sy | -symbolic] (#\n[.c])
.  \}
..
.
.
.\" NS Ef user macro
.\" NS   end font mode
.\" NS
.\" NS width register `.Ef' set in doc-common
.
.de Ef
.  ds doc-macro-name Ef
.
.  ie \n[.$] .tm Usage .Ef (does not take arguments) (#\n[.c])
.  el \&\f[\n[bF]]\s[\n[bZ]]
..
.
.
.\" NS Bk user macro
.\" NS   begin keep
.\" NS
.\" NS width register `.Bk' set in doc-common
.
.de Bk
.  ds doc-keep-type
.
.  ds doc-macro-name Bk
.
.  ie !\n[.$] \{\
.    tm Usage: .Bk [-lines | -words] (#\n[.c])
.  \}
.  el \{\
.    if !"\*[doc-keep-type]"" \{\
.      tm .Bk: nesting keeps not implemented yet. (#\n[.c])
.    \}
.    if "\$1"-lines" .tm .Bk -lines: Not implemented yet. (#\n[.c])
.    if "\$1"-words" .doc-set-hard-space
.
.    ds doc-keep-type \$1
.  \}
..
.
.
.\" NS Ek user macro
.\" NS   end keep
.\" NS
.\" NS width register `.Ek' set in doc-common
.
.de Ek
.  ds doc-macro-name Ek
.
.  ie \n[.$] .tm Usage .Ek (does not take arguments) (#\n[.c])
.  el \{\
.    if "\*[doc-keep-type]"-lines" \{\
.      tm .Bk -lines: Not implemented yet. (#\n[.c])
.    \}
.    if "\*[doc-keep-type]"-words" .doc-set-soft-space
.  \}
..
.
.
.\" NS Bd user macro
.\" NS   begin display
.\" NS
.\" NS width register `.Bd' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Bd
.
.nr doc-display-depth 0
.
.de Bd
.  ds doc-macro-name Bd
.
.  ie !\n[.$] \{\
.    tm1 "Usage: .Bd [-literal | -filled | -ragged | -unfilled]
.    tm1 "           [-offset [string]] [-compact] (#\n[.c])
.  \}
.  el \{\
.    nr doc-is-compact 0
.    nr doc-reg-Bd 0
.    nr doc-display-depth +1
.
.\" XXX how do avoid `if !r'?
.
.    if !r doc-indent-stack\n[doc-display-depth] \{\
.      nr doc-indent-stack\n[doc-display-depth] 0
.    \}
.
.    if "\$1"-literal" \{\
.      nr doc-reg-Bd +1
.      ds doc-display-type-stack\n[doc-display-depth] literal
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.
.      ie t \{\
.        nop \&\*[doc-Li-font]
'        ta T 9n
.      \}
.      el \{\
'        ta T 8n
.      \}
.      nf
.    \}
.
.    if "\$1"-filled" \{\
.      nr doc-reg-Bd +1
.      ds doc-display-type-stack\n[doc-display-depth] filled
.      br
.    \}
.
.    if "\$1"-ragged" \{\
.      nr doc-reg-Bd +1
.      ds doc-display-type-stack\n[doc-display-depth] ragged
.      na
.    \}
.
.    if "\$1"-unfilled" \{\
.      nr doc-reg-Bd +1
.      ds doc-display-type-stack\n[doc-display-depth] unfilled
.      nf
.    \}
.
.    \" .tm Here is argc: \n[.$] and here is doc-reg-Bd \n[doc-reg-Bd]
.    if ((\n[doc-reg-Bd] >= 1) & (\n[.$] > \n[doc-reg-Bd])) \{\
.      shift
.      doc-do-Bv-args \$@
.    \}
.
.    if \n[doc-indent-stack\n[doc-display-depth]] \{\
'      in (\n[.i]u + \n[doc-indent-stack\n[doc-display-depth]]u)
.    \}
.
.    if !\n[doc-is-compact] \{\
.      if !\n[doc-in-synopsis-section] \{\
.        ie "\*[doc-display-type-stack\n[doc-display-depth]]"ragged" \{\
.          sp \n[doc-display-vertical]u
.        \}
.        el 'sp \n[doc-display-vertical]u
.      \}
.    \}
.
.    if !\n[cR] .ne 2v
.
.    nr doc-is-compact 0
.\}
..
.
.
.\" NS doc-do-Bv-args macro
.\" NS   resolve remaining .Bd arguments
.\" NS
.\" NS local variables:
.\" NS   doc-str-ddBa, doc-reg-ddBa
.
.de doc-do-Bv-args
.  \" .tm in doc-do-Bv-args with args: \$@
.
.  nr doc-reg-ddBa 1
.  ds doc-str-ddBa
.
.  if "\$1"-offset" \{\
.    ds doc-str-ddBa \$2
.
.    if "\*[doc-str-ddBa]"left" \{\
.      nr doc-reg-ddBa +1
.      nr doc-indent-stack\n[doc-display-depth] 0
.    \}
.
.    if "\*[doc-str-ddBa]"right" \{\
.      nr doc-reg-ddBa +1
.      nr doc-indent-stack\n[doc-display-depth] (\n[.l]u / 3u)
.    \}
.
.    if "\*[doc-str-ddBa]"center" \{\
.      nr doc-reg-ddBa +1
.      nr doc-indent-stack\n[doc-display-depth] ((\n[.l]u - \n[.i]u) / 4u)
.    \}
.
.    if "\*[doc-str-ddBa]"indent" \{\
.      nr doc-reg-ddBa +1
.      nr doc-indent-stack\n[doc-display-depth] \n[doc-display-indent]u
.    \}
.
.    if "\*[doc-str-ddBa]"indent-two" \{\
.      nr doc-reg-ddBa +1
.      nr doc-indent-stack\n[doc-display-depth] (\n[doc-display-indent]u + \n[doc-display-indent]u)
.    \}
.
.    if (\n[doc-reg-ddBa] == 1) \{\
.      nr doc-reg-ddBa +1
.      doc-get-width "\*[doc-str-ddBa]"
.      ie (\n[doc-width] > 2) \{\
.        ie ((\*[doc-str-ddBa] > 9n) & (\*[doc-str-ddBa] < 100n)) \{\
.          nr doc-indent-stack\n[doc-display-depth] \*[doc-str-ddBa]
.        \}
.        el \{\
.          nr doc-indent-stack\n[doc-display-depth] (\n[doc-width] * \n[doc-fixed-width])
.        \}
.      \}
.      el \{\
.        if (\n[doc-width] == 2) .doc-get-arg-type \*[doc-str-ddBa]
.        ie "\*[doc-arg-type]"macro" \{\
.          nr doc-indent-stack\n[doc-display-depth] \n[\*[doc-str-ddBa]]
.        \}
.        el .nr doc-indent-stack\n[doc-display-depth] \*[doc-str-ddBa]
.      \}
.    \}
.  \}
.
.  if "\$1"-compact" \{\
.    nr doc-is-compact 1
.  \}
.
.\" XXX check number of arguments
.
.  if (\n[doc-reg-ddBa] < \n[.$]) \{\
.    ie "\*[doc-str-ddBa]"" \{\
.      shift
.      doc-do-Bv-args \$@
.    \}
.    el \{\
.      shift 2
.      doc-do-Bv-args \$@
.    \}
.  \}
..
.
.
.\" NS Ed user macro
.\" NS   end display
.\" NS
.\" NS width register `.Ed' set in doc-common
.
.de Ed
.  ds doc-macro-name Ed
.
.  br
.
.  if !\n[doc-display-depth] .tm mdoc: Extraneous .Ed
.
.  if "\*[doc-display-type-stack\n[doc-display-depth]]"literal" \{\
.    ft \n[doc-curr-font]
.    ps \n[doc-curr-size]
.  \}
.
.  in (\n[.i]u - \n[doc-indent-stack\n[doc-display-depth]]u)
.
.  rr doc-indent-stack\n[doc-display-depth]
.  rm doc-display-type-stack\n[doc-display-depth]
.  nr doc-display-depth -1
.
.  fi
.  if t .ad
..
.
.
.\" NS Bl user macro
.\" NS   begin list
.\" NS
.\" NS width register `.Bl' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-str-Bl, doc-reg-Bl
.
.de Bl
.  ie !\n[.$] \{\
.    tm1 "Usage: .Bl [[-hang | -tag] [-width]]
.    tm1 "           [ -item | -enum | -bullet | -diag] (#\n[.c])
.  \}
.  el \{\
.    ds doc-macro-name Bl
.
.    ds doc-str-Bl "\$1
.    nr doc-arg-ptr 0
.    nr doc-list-depth +1
.
.    shift
.    nr doc-reg-Bl 1
.    while (\n[doc-reg-Bl] <= \n[.$]) \{\
.      ds doc-arg\n[doc-reg-Bl] "\$[\n[doc-reg-Bl]]
.      nr doc-reg-Bl +1
.    \}
.
.    nr doc-num-args \n[.$]
.
.    if "\*[doc-str-Bl]"-hang" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] hang-list
.      nr doc-list-indent-stack\n[doc-list-depth] 6n
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-tag" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] tag-list
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-item" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] item-list
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-enum" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] enum-list
.      nr doc-list-indent-stack\n[doc-list-depth] 3n
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-bullet" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] bullet-list
.      nr doc-list-indent-stack\n[doc-list-depth] 2n
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-dash" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] dash-list
.      nr doc-list-indent-stack\n[doc-list-depth] 2n
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-hyphen" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] dash-list
.      nr doc-list-indent-stack\n[doc-list-depth] 2n
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-inset" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] inset-list
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-diag" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] diag-list
.      nr doc-have-diag-list 1
.    \}
.
.    if "\*[doc-str-Bl]"-ohang" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] ohang-list
.      nr doc-have-indent 1
.    \}
.
.    if "\*[doc-str-Bl]"-column" \{\
.      nr doc-arg-ptr +1
.      ds doc-list-stack\n[doc-list-depth] column-list
.    \}
.
.    ie !\n[doc-arg-ptr] \{\
.      tm1 "Usage: .Bl [[-hang | -tag] [-width]]
.      tm1 "           [ -item | -enum | -bullet | -diag] (#\n[.c])
.    \}
.    el \{\
.      doc-increment-list-stack
.      if ((\n[doc-arg-ptr] == 1) & (\n[doc-arg-ptr] <= \n[.$])) \{\
.        nr doc-arg-ptr 0
.        doc-do-Bl-args
.        if "\*[doc-list-stack\n[doc-list-depth]]"column-list" \{\
.          doc-set-column-tab\n[doc-column-depth]
.          nr doc-list-indent-stack\n[doc-list-depth] 0
'          in -\n[doc-column-indent-width]u
.          if !\n[doc-compact-list-stack\n[doc-list-depth]] \{\
.            sp \n[doc-display-vertical]u
.          \}
.
.          nf
.          nr doc-column-depth 0
.        \}
.      \}
.    \}
.
.    nr doc-arg-ptr 0
.    \" .ds doc-out-string
.    doc-reset-args
.    \" .tmc Here is
.    \" .tm1 " doc-list-stack[\n[doc-list-depth]]==\*[doc-list-stack\n[doc-list-depth]]
.  \}
..
.
.
.ec
.
.nr i 10
.while (\n[i] < 100) \{\
.  nr doc-width-\n[i]n 1
.  nr i +1
.\}
.
.eo
.
.
.\" NS doc-do-Bl-args macro
.\" NS   resolve remaining .Bl arguments
.\" NS
.\" NS local variable:
.\" NS   doc-str-dBla, doc-reg-dBla
.
.de doc-do-Bl-args
.  nr doc-arg-ptr +1
.  if (\n[doc-num-args] >= \n[doc-arg-ptr]) \{\
.    nr doc-reg-dBla 0
.
.    if "\*[doc-arg\n[doc-arg-ptr]]"-compact" \{\
.      nr doc-reg-dBla 1
.      nr doc-compact-list-stack\n[doc-list-depth] 1
.    \}
.
.    if "\*[doc-arg\n[doc-arg-ptr]]"-width" \{\
.      nr doc-reg-dBla 1
.      nr doc-arg-ptr +1
.      nr have-tag-width 1
.      ds doc-tag-width-stack\n[doc-list-depth] TagwidtH
.      ds doc-str-dBla \*[doc-arg\n[doc-arg-ptr]]
.
.      doc-get-arg-width \n[doc-arg-ptr]
.      ie (\n[doc-width] > 2) \{\
.        nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width] * \n[doc-fixed-width])
.        if (\n[doc-width] == 3) \{\
.          if \A'\*[doc-str-dBla]' .if r doc-width-\*[doc-str-dBla] \{\
.            nr doc-list-indent-stack\n[doc-list-depth] \*[doc-str-dBla]
.          \}
.        \}
.      \}
.      el \{\
.        doc-get-arg-type \*[doc-str-dBla]
.        ie "\*[doc-arg-type]"macro" \{\
.          nr doc-list-indent-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
.        \}
.        el \{\
.          nr doc-list-indent-stack\n[doc-list-depth] \*[doc-str-dBla]u
.        \}
.      \}
.    \}
.
.    if "\*[doc-arg\n[doc-arg-ptr]]"-offset" \{\
.      nr doc-reg-dBla 1
.      nr doc-arg-ptr +1
.
.      ie "\*[doc-arg\n[doc-arg-ptr]]"indent" \{\
.        nr doc-list-offset-stack\n[doc-list-depth] \n[doc-display-indent]u
.      \}
.      el \{\
.        ds doc-str-dBla \*[doc-arg\n[doc-arg-ptr]]
.
.        doc-get-arg-width \n[doc-arg-ptr]
.        ie (\n[doc-width] > 2) \{\
.          nr doc-list-offset-stack\n[doc-list-depth] (\n[doc-width] * \n[doc-fixed-width])
.          if \A'\*[doc-str-dBla]' .if r doc-width-\*[doc-str-dBla] \{\
.            nr doc-list-offset-stack\n[doc-list-depth] \*[doc-str-dBla]
.          \}
.        \}
.        el \{\
.          ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.            nr doc-list-offset-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
.          \}
.          el .nr doc-list-offset-stack\n[doc-list-depth] \*[doc-str-dBla]
.        \}
.      \}
.    \}
.
.    if !\n[doc-reg-dBla] \{\
.      if "\*[doc-list-stack\n[doc-list-depth]]"column-list" \{\
.        nr doc-column-depth +1
.        ds doc-arg\n[doc-column-depth] \*[doc-arg\n[doc-arg-ptr]]
.      \}
.    \}
.    if (\n[doc-num-args] > \n[doc-arg-ptr]) .doc-do-Bl-args
.  \}
..
.
.
.\" NS El user macro
.\" NS   end list
.\" NS
.\" NS width register `.El' set in doc-common
.\" NS
.\" NS local variables:
.\" NS   doc-str-El, doc-reg-El
.
.de El
.  ie \n[.$] \{\
.    tm Usage: .El (#\n[.c])
.  \}
.  el \{\
.    ds doc-macro-name El
.    nr doc-reg-El 0
.    ds doc-str-El \*[doc-list-stack\n[doc-list-depth]]
.
.    if "\*[doc-str-El]"column-list" \{\
.      nr doc-reg-El 1
.      doc-do-end-column-list
.    \}
.
.    if "\*[doc-str-El]"enum-list" \{\
.      nr doc-enum-list-count 0
.    \}
.
.    if \n[doc-have-diag-list] \{\
.      nr doc-reg-El 1
.      nr doc-have-diag-list 0
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.    \}
.
.    if "\*[doc-str-El]"item-list" \{\
'      in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u)
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.      nr doc-reg-El 1
.    \}
.
.    if "\*[doc-str-El]"ohang-list" \{\
'      in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u)
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.      nr doc-reg-El 1
.    \}
.
.    if "\*[doc-str-El]"inset-list" \{\
'      in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u)
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.      nr doc-reg-El 1
.    \}
.
.    if !\n[doc-reg-El] .doc-end-list
.
.    br
.  \}
..
.
.
.\" NS doc-save-Pa-font string
.\" NS   save doc-Pa-font font string for section FILES (no underline if
.\" NS   nroff)
.
.
.\" NS It user macro
.\" NS   list item
.\" NS
.\" NS local variable:
.\" NS   doc-str-It, doc-reg-It
.
.de It
.  ds doc-str-It \*[doc-list-stack\n[doc-list-depth]]
.
.  if "\*[doc-str-It]"" \{\
.    tm mdoc error: .It without preceding .Bl
.    tmc Usage .It -list-type [-width [string] | -compact | -offset [string]]
.    tm1 " (#\n[.c])
.    tm .It \$@
.  \}
.
.  \" .tmc Here is
.  \" .tm1 " doc-list-stack[\n[doc-list-depth]]==\*[doc-str-It]
.
.  if !\n[cR] .ne 3v
.
.  ie \n[.$] \{\
.    ds doc-macro-name It
.    ds doc-out-string
.
.    nr doc-reg-It 1
.    while (\n[doc-reg-It] <= \n[.$]) \{\
.      ds doc-arg\n[doc-reg-It] "\$[\n[doc-reg-It]]
.      nr doc-reg-It +1
.    \}
.
.    nr doc-reg-It 0
.    nr doc-num-args \n[.$]
.
.    if "\*[doc-str-It]"diag-list" \{\
.      nr doc-reg-It 1
.      nr doc-arg-ptr 0
.      doc-remaining-args
.      doc-diag-list
.    \}
.
.    if "\*[doc-str-It]"column-list" \{\
.      ds doc-out-string
.      nr doc-arg-ptr 0
.      nr doc-reg-It 1
.      doc-column-list
.    \}
.
.    if "\*[doc-str-It]"item-list" \{\
.      nr doc-arg-ptr 0
.      nr doc-reg-It 1
.      doc-item-list
.    \}
.
.    if !\n[doc-reg-It] \{\
.      doc-parse-arg-vector
.
.      \" tm1 "It list-type==\*[doc-str-It]
.      \" tm1 "   doc-arg-ptr==\n[doc-arg-ptr]
.      \" tm1 "   beg arg(doc-arg[1])==\*[doc-arg1]
.      \" tm1 "   doc-nesting-level==\n[doc-nesting-level]
.      \" tm1 "   doc-diversion-level==\n[doc-diversion-level]
.      \" tm1 "   doc-saved-list-immediate==\n[doc-saved-list-immediate]
.      \" tm1 "   doc-args-processed==\n[doc-args-processed]
.
.      nr doc-nesting-level +1
.      nr doc-list-immediate 1
.      nr doc-arg-ptr +1
.      ds doc-curr-type \*[doc-type\n[doc-arg-ptr]]
.      ds doc-curr-arg \*[doc-arg\n[doc-arg-ptr]]
.
.      if \n[doc-in-files-section] \{\
.        ds doc-save-Pa-font \*[doc-Pa-font]
.        if n .ds doc-Pa-font \*[doc-No-font]
.      \}
.
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-arg-ptr -1
.        No
.      \}
.
.      \" tm in It here is doc-out-string==\*[doc-out-string]
.      \" tm It mid arg(doc-arg[1])==\*[doc-arg1]; doc-nesting-level==\n[doc-nesting-level]; doc-diversion-level==\n[doc-diversion-level]; doc-saved-list-immediate==\n[doc-saved-list-immediate]; doc-args-processed==\n[doc-args-processed]
.      ie \n[doc-saved-list-immediate] \{\
.        ds doc-saved-list-type "\*[doc-str-It]
.      \}
.      el .doc-\*[doc-str-It]
.    \}
.  \}
.  el .doc-\*[doc-str-It]
..
.
.
.\" NS doc-inset-list macro
.\" NS   .It item of list-type inset
.
.de doc-inset-list
.  doc-set-vertical-and-indent
.  br
.  nop \&\*[doc-out-string]
.
.  nr doc-nesting-level -1
.  nr doc-list-immediate 0
.  ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-hang-list macro
.\" NS   .It item of list-type hanging tag (as opposed to tagged)
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dhl
.
.de doc-hang-list
.  doc-set-vertical-and-indent-and-offset
.  nr doc-reg-dhl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-dhl]u
.
.  ie (\w\*[doc-out-string]u >= \n[doc-list-indent-stack\n[doc-list-depth]]u) \{\
.    nop \&\*[doc-out-string]
.  \}
.  el \&\*[doc-out-string]\h'|\n[doc-reg-dhl]u'\c
.
.  nr doc-nesting-level -1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-ohang-list macro
.\" NS   .It item of list-type overhanging tag
.
.de doc-ohang-list
.  doc-set-vertical-and-indent
.  nop \&\*[doc-out-string]
.  br
.
.  nr doc-nesting-level -1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-item-list macro
.\" NS   .It item of list-type [empty tag]
.
.de doc-item-list
.  doc-set-vertical-and-indent
.  br
.
.  \" .ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-enum-list-count register
.\" NS   contains current enum count value
.
.nr doc-enum-list-count 0
.
.
.\" NS doc-enum-list macro
.\" NS   enumerated list
.
.de doc-enum-list
.  nr doc-nesting-level +1
.  nr doc-enum-list-count +1
.  ds doc-out-string \&\n[doc-enum-list-count].
.  doc-do-list
..
.
.
.\" NS doc-bullet-list macro
.\" NS   bullet paragraph list
.
.de doc-bullet-list
.  nr doc-nesting-level +1
.  ds doc-out-string \&\*[doc-Sy-font]\[bu]\f[P]
.  doc-do-list
..
.
.
.\" NS doc-dash-list macro
.\" NS   hyphen paragraph list (sub bullet list)
.
.de doc-dash-list
.  nr doc-nesting-level +1
.  ds doc-out-string \&\*[doc-Sy-font]\-\f[P]
.  doc-do-list
..
.
.
.\" NS doc-do-list macro
.\" NS   .It item of list-type enum/bullet/hyphen
.\" NS
.\" NS local variable:
.\" NS   doc-reg-ddl
.
.de doc-do-list
.  doc-set-vertical-and-indent-and-offset
.  nr doc-reg-ddl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-ddl]u
.
.  ie (\w\*[doc-out-string]u >= \n[doc-list-indent-stack\n[doc-list-depth]]u) \{\
.    nop \&\*[doc-out-string]
.  \}
.  el \&\*[doc-out-string]\h'|\n[doc-reg-ddl]u'\c
.
.  nr doc-nesting-level -1
.  \" .nr doc-diversion-level +1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-diag-list macro
.\" NS   .It item of list-type diagnostic-message
.
.nr doc-have-diag-list 0
.nr doc-diag-list-input-line-count 0
.
.de doc-diag-list
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  ie \n[doc-have-diag-list] \{\
.    ie ((\n[.c] - \n[doc-diag-list-input-line-count]) > 1) .doc-paragraph
.    el .br
.  \}
.  el .br
.  nr doc-diag-list-input-line-count \n[.c]
.
.  nop \&\*[doc-Sy-font]\*[doc-out-string]\c
.  nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\*[doc-digit-string]\c
.
.  doc-reset-args
.  ds doc-out-string
'  fi
..
.
.
.\" NS doc-tag-list macro
.\" NS   .It item of list-type `tag'
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dtl
.
.de doc-tag-list
.  \" tm in doc-tag-list here is doc-out-string==\*[doc-out-string]
.  if !\n[have-tag-width] .doc-get-tag-width
.  doc-set-vertical-and-indent-and-offset
.  nr doc-reg-dtl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-dtl]u
.
.  ie (\w\*[doc-out-string]u > \n[doc-list-indent-stack\n[doc-list-depth]]u) \{\
.    nop \&\*[doc-out-string]
.    br
.  \}
.  el \&\*[doc-out-string]\h'|\n[doc-reg-dtl]u'\c
.
.  if \n[doc-in-files-section] \{\
.    if n .ds doc-Pa-font \*[doc-save-Pa-font]
.  \}
.
.  nr doc-nesting-level -1
.  nr doc-list-immediate 0
.  \" .nr doc-diversion-level +1
.  ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-get-tag-width macro
.\" NS   resolve unknown tag width (if .Bl [inset | tag] only)
.
.de doc-get-tag-width
.  if !"TagwidtH"\*[doc-tag-width-stack\n[doc-list-depth]]" \{\
.    ie "\*[doc-curr-type]"macro" \{\
.
.\" XXX what is `lN'?
.
.      ds doc-tag-width-stack\n[lN] \*[doc-curr-arg]
.      nr doc-list-indent-stack\n[lN] \n[\*[doc-curr-arg]]
.    \}
.    el \{\
.      ds doc-tag-width-stack\n[lN] No
.      nr doc-list-indent-stack\n[lN] \n[No]
.    \}
.    if !"\*[doc-tag-width-stack\n[doc-list-depth]]"\*[doc-tag-width-stack\n[lN]]" \{\
.      nr doc-have-indent 1
.    \}
.  \}
..
.
.
.\" NS doc-set-vertical-and-indent-and-offset macro
.\" NS   set up vertical spacing (if compact) and indent (with offset)
.
.de doc-set-vertical-and-indent-and-offset
.  ie \n[doc-have-indent] \{\
.    nr doc-have-indent 0
.    nr have-tag-width 0
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \{\
.      sp \n[doc-display-vertical]u
.    \}
.    in (\n[.i]u + \n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-list-offset-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  \}
.  el \{\
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \{\
.      sp \n[doc-display-vertical]u
.    \}
.  \}
.
.  if !\n[cR] .ne 2v
..
.
.
.\" NS doc-set-vertical-and-indent macro
.\" NS   set up vertical spacing (if compact) and indent (without offset)
.
.de doc-set-vertical-and-indent
.  ie \n[doc-have-indent] \{\
.    nr doc-have-indent 0
.    nr have-tag-width 0
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \{\
.      sp \n[doc-display-vertical]u
.    \}
.    in (\n[.i]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
.  \}
.  el \{\
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \{\
.      sp \n[doc-display-vertical]u
.    \}
.  \}
.
.  if !\n[cR] .ne 2v
..
.
.
.\" NS doc-saved-list-immediate register (bool)
.\" NS   saved doc-list-immediate value
.
.nr doc-saved-list-immediate 0
.
.
.\" NS doc-list-depth register
.\" NS   list type stack counter
.
.nr doc-list-depth 0
.
.
.\" NS doc-list-immediate register (bool)
.\" NS   tag flag (for diversions)
.
.
.nr doc-column-depth 0
.nr doc-compact-list-stack1 0
.ds doc-tag-width-stack0
.ds doc-tag-width-stack1
.nr doc-list-offset-stack1 0
.
.
.\" NS doc-end-list macro
.\" NS   list end function
.
.de doc-end-list
.  \" .tm in doc-list-depth:
.  \" .tm1 "  doc-list-offset-stack[\n[doc-list-depth]]==\n[doc-list-offset-stack\n[doc-list-depth]]
.  \" .tm1 "  doc-list-indent-stack[\n[doc-list-depth]]==\n[doc-list-indent-stack\n[doc-list-depth]]
.
.  ie (\n[doc-list-offset-stack\n[doc-list-depth]] > 0) \{\
'    in (\n[.i]u - \n[doc-list-indent-stack\n[doc-list-depth]]u - \n[doc-list-offset-stack\n[doc-list-depth]]u - \n[doc-digit-width]u)
.    rr doc-list-offset-stack\n[doc-list-depth]
.  \}
.  el \{\
'    in (\n[.i]u - \n[doc-list-indent-stack\n[doc-list-depth]]u - \n[doc-digit-width]u)
.  \}
.
.  if (\n[doc-list-depth] <= 0) \{\
.    tm mdoc warning: extraneous .El call (#\n[.c])
.  \}
.  doc-decrement-list-stack
.  nr doc-list-depth -1
.  doc-increment-list-stack
..
.
.
.\" NS doc-next-list-depth register
.\" NS   next possible doc-list-depth value
.
.nr doc-next-list-depth 1
.
.
.\" NS doc-increment-list-stack macro
.\" NS   set up next block for list
.
.de doc-increment-list-stack
.  nr doc-next-list-depth (\n[doc-list-depth] + 1)
.  nr doc-list-indent-stack\n[doc-next-list-depth] 0
.  nr doc-list-offset-stack\n[doc-next-list-depth] 0
.  ds doc-tag-width-stack\n[doc-next-list-depth] \*[doc-tag-width-stack\n[doc-list-depth]]
.  ds doc-list-stack\n[doc-next-list-depth]
.  nr doc-compact-list-stack\n[doc-next-list-depth] 0
..
.
.
.\" NS doc-decrement-list-stack macro
.\" NS   decrement stack
.
.de doc-decrement-list-stack
.  rm doc-list-stack\n[doc-next-list-depth]
.  rr doc-list-indent-stack\n[doc-next-list-depth]
.  rr doc-list-offset-stack\n[doc-next-list-depth]
.  rm doc-tag-width-stack\n[doc-next-list-depth]
.  rr doc-compact-list-stack\n[doc-next-list-depth]
.  nr doc-next-list-depth -1
..
.
.
.\" NS Xr user macro
.\" NS   cross reference (man page only)
.
.de Xr
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Xr manpage_name [section#] \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Xr
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.      tm Usage: .Xr manpage_name [section#] \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ie !"\*[doc-type\n[doc-arg-ptr]]"string" \{\
.        doc-do-xref-\*[doc-type\n[doc-arg-ptr]]
.      \}
.      el \{\
.        as doc-out-string \&\*[doc-Xr-font]
.        as doc-out-string \*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.        if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.          nr doc-arg-ptr +1
.          if "\*[doc-type\n[doc-arg-ptr]]"string" \{\
.            as doc-out-string \&(\*[doc-arg\n[doc-arg-ptr]])
.            nr doc-arg-ptr +1
.          \}
.
.          if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.            doc-do-\*[doc-type\n[doc-arg-ptr]]
.          \}
.        \}
.      \}
.      doc-print-and-reset
.    \}
.  \}
..
.
.
.\" NS Sx user macro
.\" NS   cross section reference
.
.de Sx
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Sx Section Header \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Sx
.      doc-parse-args \$@
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    as doc-out-string \&\*[doc-Sx-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
.\}
..
.
.
.\" NS doc-do-end-column-list macro
.\" NS   column-list end-list
.
.de doc-do-end-column-list
'  in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u - \n[doc-list-indent-stack\n[doc-list-depth]]u)
.  ta T .5i 1i
.  fi
.  doc-decrement-list-stack
.  nr doc-list-depth -1
.  doc-increment-list-stack
..
.
.
.\" NS doc-set-column-tab[1-6] macro
.\" NS   establish tabs for list-type column
.
.de doc-set-column-tab1
.  ta \w\*[doc-arg1]    u
.  nr doc-column-indent-width \w\*[doc-arg1]    u
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab2
.  ta \w\*[doc-arg1]    u +\w\*[doc-arg2]    u
.  nr doc-column-indent-width (\w\*[doc-arg1]    u + \w\*[doc-arg2]    u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab3
.  ta \w\*[doc-arg1]    u +\w\*[doc-arg2]    u +\w\*[doc-arg3]    u
.  nr doc-column-indent-width (\w\*[doc-arg1]    u + \w\*[doc-arg2]    u + \w\*[doc-arg3]    u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab4
.  ta \w\*[doc-arg1]    u +\w\*[doc-arg2]    u +\w\*[doc-arg3]    u +\w\*[doc-arg4]    u
.  nr doc-column-indent-width (\w\*[doc-arg1]    u + \w\*[doc-arg2]    u + \w\*[doc-arg3]    u + \w\*[doc-arg4]    u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab5
.  ta \w\*[doc-arg1]   u +\w\*[doc-arg2]   u +\w\*[doc-arg3]   u +\w\*[doc-arg4]   u +\w\*[doc-arg5]   u
.  nr doc-column-indent-width (\w\*[doc-arg1]   u + \w\*[doc-arg2]   u + \w\*[doc-arg3]   u + \w\*[doc-arg4]   u +\w\*[doc-arg5]   u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.\" This is packed abnormally close; intercol width should be an option
.de doc-set-column-tab6
.  ta \w\*[doc-arg1] u +\w\*[doc-arg2] u +\w\*[doc-arg3] u +\w\*[doc-arg4] u +\w\*[doc-arg5] u +\w\*[doc-arg6] u
.  nr doc-column-indent-width (\w\*[doc-arg1] u + \w\*[doc-arg2] u + \w\*[doc-arg3] u + \w\*[doc-arg4] u + \w\*[doc-arg5] u + \w\*[doc-arg6] u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.\" NS doc-column-list macro
.\" NS   column items
.
.de doc-column-list
.  if !\n[doc-list-indent-stack\n[doc-list-depth]] \{\
.    nr doc-list-indent-stack\n[doc-list-depth] \n[doc-column-indent-width]u
.  \}
.  if !\n[.u] \{\
.    fi
'    in (\n[.i]u + \n[doc-column-indent-width]u)
.  \}
.  ti -\n[doc-column-indent-width]u
.
.  doc-parse-arg-vector
.  nr doc-arg-ptr +1
.
.  ie (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    if "\*[doc-arg\n[doc-arg-ptr]]"Ta" \{\
.      nr jJ (\n[doc-arg-ptr] - 1)
.      rm doc-space\n[jJ]
.      rr jJ
.    \}
.    doc-do-\*[doc-type\n[doc-arg-ptr]]
.  \}
.  el .tm Usage: .It column_string [Ta [column_string ...] ] (#\n[.c])
..
.
.
.\" NS Ta user macro
.\" NS   append tab (\t)
.
.de Ta
.  ie \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.      if "\*[doc-arg\n[doc-arg-ptr]]"Ta" \{\
.        nr jJ (\n[doc-arg-ptr] - 1)
.        rm doc-space\n[jJ]
.        rr jJ
.      \}
.      as doc-out-string \t
.      doc-do-\*[doc-type\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \t\c
.      rm doc-space\n[doc-arg-ptr]
.      doc-print-out-string
.      doc-reset-args
.      \" .ds doc-out-string
.    \}
.  \}
.  el \{\
.    tm1 "Usage: Ta must follow column entry: e.g. (#\n[.c])
.    tm1 "         .It column_string [Ta [column_string ...] ]
.  \}
..
.
.
.\" NS Dl user macro
.\" NS   display (one line) literal
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Dl
.
.de Dl
'  ta T .5i
.  in (\n[.i]u + \n[doc-display-indent]u)
.
.  ie !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Dl argument ... (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Dl
.
.      nr doc-reg-Dl 1
.      while (\n[doc-reg-Dl] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Dl] "\$[\n[doc-reg-Dl]]
.        nr doc-reg-Dl +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.      Li
.    \}
.  \}
.  el \{\
.    tm Usage: .Dl not callable by other macros (#\n[.c])
.  \}
.
.  in (\n[.i]u - \n[doc-display-indent]u)
..
.
.
.\" NS D1 user macro
.\" NS   display (one line)
.\" NS
.\" NS local variable:
.\" NS   doc-reg-D1
.
.de D1
'  ta T .5i
.  in (\n[.i]u + \n[doc-display-indent]u)
.
.  ie !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .D1 argument ... (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name D1
.
.      nr doc-reg-D1 1
.      while (\n[doc-reg-D1] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-D1] "\$[\n[doc-reg-D1]]
.        nr doc-reg-D1 +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" .\*[doc-arg\n[doc-arg-ptr]]
.      el .No
.    \}
.  \}
.  el \{\
.    tm Usage: .D1 not callable by other macros (#\n[.c])
.  \}
.
.  in (\n[.i]u - \n[doc-display-indent]u)
..
.
.
.\" NS Ex user macro - DEFUNCT
.
.de Ex
.  tm Ex defunct, Use .D1: \$@
..
.
.
.\" NS Vt user macro
.\" NS   variable type (for forcing old style variable declarations)
.\" NS   this is not done in the same manner as .Ot for fortrash --
.\" NS   clean up later
.
.de Vt
.  \" if a function declaration was the last thing given, want vertical space
.  if \n[doc-declaration-count] \{\
.    doc-paragraph
.    nr doc-declaration-count 0
.  \}
.
.  \" if a subroutine was the last thing given, want vertical space
.  if \n[doc-function-count] \{\
.    ie !\n[doc-variable-type] \{\
.      doc-paragraph
.      rs
.    \}
.    el .br
.  \}
.
.  nr doc-variable-type +1
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.  nop \&\*[doc-Ft-font]\$*
.
.  ie !\n[doc-have-old-function] .br
.  el \*[doc-soft-space]
.
.  ft \n[doc-curr-font]
.  fs \n[doc-curr-size]
..
.
.
.\" NS doc-is-func-type register (bool)
.\" NS   set if subroutine (in synopsis only) (fortran only)
.
.nr doc-is-func-type 0
.
.
.\" NS Ft user macro
.\" NS   function type
.
.de Ft
.  if \n[doc-in-synopsis-section] \{\
.    if \n[doc-function-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-declaration-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    nr doc-is-func-type 1
.  \}
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.  nop \&\*[doc-Ft-font]\$*
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
.  \" .br
..
.
.
.\" NS doc-have-old-function register
.
.nr doc-have-old-function 0
.
.
.\" NS Ot user macro
.\" NS   old function type (fortran - no newline)
.
.de Ot
.  nr doc-have-old-function 1
.
.  if \n[doc-in-synopsis-section] \{\
.    if \n[doc-function-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-declaration-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    nr doc-is-func-type 1
.  \}
.
.  if \n[.$] .as doc-out-string \&\*[doc-Ft-font]\$*
.  as doc-out-string \&\ \f[P]
..
.
.
.\" NS Fa user macro
.\" NS   function arguments
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Fa
.
.de Fa
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tm Usage: .Fa Function Arguments ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Fa
.
.      nr doc-reg-Fa 1
.      while (\n[doc-reg-Fa] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Fa] "\$[\n[doc-reg-Fa]]
.        nr doc-reg-Fa +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  ie \n[doc-func-arg-count] \{\
.    doc-do-function
.  \}
.  el \{\
.    if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.      as doc-out-string \*[doc-Fa-font]
.      nr doc-arg-ptr +1
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      doc-print-recursive
.
.      if \n[doc-in-synopsis-section] \{\
.        if \n[doc-function-count] .br
.      \}
.    \}
.  \}
..
.
.
.\" NS doc-do-function macro
.\" NS   internal .Fa for .Fc
.
.nr doc-func-arg-count 0
.
.de doc-do-function
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    \" .if (\n[doc-in-synopsis-section] > 0) \{\
.    ds Fb
.    nr fB 0
.    nr Fb 0
.    fB \*[doc-arg\n[doc-arg-ptr]]
.    if (\n[fB] > 1) \{\
.      rm doc-arg\n[doc-arg-ptr]
.      rn Fb doc-arg\n[doc-arg-ptr]
.    \}
.    \" .\}
.
.    if (\n[doc-func-arg-count] > 1) \{\
.      as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]],\*[doc-space\n[doc-arg-ptr]]\*[doc-Fa-font]\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.      \" .as doc-out-string \&\,\*[doc-space\n[doc-arg-ptr]]\f[P]\s[0]\*[doc-Fa-font]\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    \}
.
.    if (\n[doc-func-arg-count] == 1) \{\
.      as doc-out-string \&\|\*[doc-Fa-font]\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    \}
.    nr doc-func-arg-count +1
.    doc-do-function
.  \}
.  el \{\
.    doc-reset-args
.  \}
..
.
.
.\" NS doc-function-count register
.\" NS   break a line if more than one function in a synopsis
.
.nr doc-function-count 0
.
.
.\" NS Fn macro - functions
.
.de Fn
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .Fn function_name function_arg(s) ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name Fn
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-in-synopsis-section] > 0) \{\
.    \" if there is/has been more than one subroutine declaration
.    if (\n[doc-is-func-type] == 0) \{\
.      if (\n[doc-function-count] > 0) \{\
.        doc-paragraph
.        nr doc-variable-type 0
.        nr doc-declaration-count 0
.      \}
.    \}
.    if (\n[doc-is-func-type] == 1) \{\
.      br
.      nr doc-variable-type 0
.      nr doc-declaration-count 0
.      nr doc-is-func-type 0
.    \}
.
.    if (\n[doc-declaration-count] > 0) \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    if (\n[doc-variable-type] > 0) \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.    \}
.
.    nr doc-function-count +1
.    nr doc-is-func-type 0
.    rs
.
.    ie (\n[doc-in-synopsis-section] > 1) .br
.    el \{\
.      if (\n[doc-indent-synopsis] == 0) \{\
.        nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
.      \}
.    \}
.
.    in +\n[doc-indent-synopsis]u
.    ti -\n[doc-indent-synopsis]u
.    nr doc-in-synopsis-section +1
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    as doc-out-string \*[fN]\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]\*[lp]
.
.    ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.      as doc-out-string \*[doc-Fa-font]
.      nr doc-arg-ptr +1
.      f-\*[doc-type\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \|\*[rp]
.      doc-print-and-reset
.    \}
.
.    if (\n[doc-in-synopsis-section] > 0) \{\
.      in -\n[doc-indent-synopsis]u
.    \}
.  \}
..
.
.
.\" NS f-macro macro - class switch
.\" NS f-punct-suffix macro - punctuation
.\" NS f-punct-prefix macro - write out function
.
.de f-macro
.  as doc-out-string \*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.  nop \*[doc-arg\n[doc-arg-ptr]]
..
.
.
.\" NS f-string macro
.\" NS   handle function arguments
.\" NS
.\" NS local variable:
.\" NS   doc-reg-fs
.
.de f-string
.  if (\n[doc-in-synopsis-section] > 0) \{\
.    ds Fb
.    nr fB 0
.    nr Fb 0
.    fB \*[doc-arg\n[doc-arg-ptr]]
.    if (\n[fB] > 1) \{\
.      rm doc-arg\n[doc-arg-ptr]
.      rn Fb doc-arg\n[doc-arg-ptr]
.    \}
.  \}
.
.  as doc-out-string \*[doc-arg\n[doc-arg-ptr]]
.
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-reg-fs \n[doc-arg-ptr]
.    nr doc-arg-ptr +1
.    if "\*[doc-type\n[doc-arg-ptr]]"string" \{\
.      as doc-out-string \&\|\f[\n[doc-curr-font]]\s[\n[doc-curr-size]],\*[doc-space\n[doc-reg-fs]]\f[P]\s[0]\|
.    \}
.    f-\*[doc-type\n[doc-arg-ptr]]
.  \}
.  el \{\
.    as doc-out-string \*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    doc-print-and-reset
.  \}
..
.
.
.de f-punct-suffix
.  as doc-out-string \*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\*[doc-arg\n[doc-arg-ptr]]
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    No
.  \}
.  el .doc-print-and-reset
..
.
.
.de f-punct-prefix
.  as doc-out-string \*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\*[doc-space\n[doc-arg-ptr]]\*[doc-arg\n[doc-arg-ptr]]
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    No
.  \}
.  el .doc-print-and-reset
..
.
.
.\" NS Fo macro - function open
.
.de Fo
.  hy 0
.
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .Fo function_name (#\n[.c])
.    el \{\
.      ds doc-macro-name Fo
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-in-synopsis-section] > 0) \{\
.    \" if there is/has been more than one subroutine declaration
.    if (\n[doc-is-func-type] == 0) \{\
.      if (\n[doc-function-count] > 0) \{\
.        doc-paragraph
.        nr doc-variable-type 0
.        nr doc-declaration-count 0
.      \}
.    \}
.    if (\n[doc-is-func-type] == 1) \{\
.      br
.      nr doc-variable-type 0
.      nr doc-declaration-count 0
.      nr doc-is-func-type 0
.    \}
.
.    if (\n[doc-declaration-count] > 0) \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    if (\n[doc-variable-type] > 0) \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.    \}
.
.    nr doc-function-count +1
.    nr doc-is-func-type 0
.    rs
.
.    ie (\n[doc-in-synopsis-section] > 1) .br
.    el \{\
.      if (\n[doc-indent-synopsis] == 0) \{\
.        nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
.      \}
.    \}
.
.    in +\n[doc-indent-synopsis]u
.    ti -\n[doc-indent-synopsis]u
.    nr doc-in-synopsis-section +1
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-nesting-level +1
.    nr doc-func-arg-count 1
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    as doc-out-string \*[fN]\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]\*[lp]
.    doc-reset-args
.  \}
..
.
.
.\" NS Fc macro - function close
.
.de Fc
.  if (\n[doc-args-processed] == 0) \{\
.    if (\n[.$] > 0) \{\
.      ds doc-macro-name Fo
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  nr doc-func-arg-count 0
.  nr doc-nesting-level -1
.  as doc-out-string \|\*[rp]
.
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    \*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    doc-print-and-reset
.  \}
.
.  if (\n[doc-in-synopsis-section] > 0) \{\
.    in -\n[doc-indent-synopsis]u
.  \}
.
.  hy
..
.
.
.\" NS fb macro - if SYNOPSIS, set hard space inbetween function args
.\" NS fb register - count of words in a function argument
.\" NS Fb register - counter
.\" NS Fb string - temporary string
.
.de fB
.  \" .tm fB==\n[fB], Fb==\n[Fb], 1==\$1 2==\$2 3==\$3 4==\$4 5==\$5 6==\$6
.  if (\n[fB] == 0) \{\
.    nr fB \n[.$]
.    nr Fb 0
.    ds Fb
.  \}
.
.  nr Fb (\n[Fb] + 1)
.  as Fb \&\$1
.
.  if (\n[Fb] < \n[fB]) \{\
.    as Fb \&\*[doc-hard-space]
.    fB \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9
.  \}
..
.
.
.\" Very crude references, stash all reference info into strings (usual
.\" use of doc-out-string buffer, then doc-out-string contents copied to string of retrievable
.\" naming convention), print out reference on .Re request and clean up.
.\" Ordering very limited, no fancy citations, but can do articles, journals
.\" and books - need to add several missing options (like city etc).
.\" should be able to grab a refer entry, massage it a wee bit (prefix
.\" a `.' to the %[A-Z]) and not worry (ha!)
.\"
.\" NS Rs macro - Reference Start
.\" NS rS register - Reference Start flag
.\" NS rS string - Reference Start buffer name for next save (of doc-out-string buffer)
.
.de Rs
.  nr rS 1
.  rC
.  if (\n[nA] == 1) .doc-paragraph
.  nr Kl 0
..
.
.
.\" NS Re macro - Reference End
.
.de Re
.  rZ
.  rC
.nr rS 0
..
.
.
.\" NS rC macro - reference cleanup
.
.de rC
.  nr uK 0
.  nr jK 0
.  nr nK 0
.  nr oK 0
.  nr qK 0
.  nr rK 0
.  nr tK 0
.  nr vK 0
.  nr dK 0
.  nr pK 0
.  nr bK 0
.  ds rS
.  rm U1 U2 U3 U4 U5 U6 U7 U8
.  rm uK jK nK oK rK qK tK vK dK pK bK
..
.
.
.\" NS rZ macro - reference print
.
.de rZ
.  if \n[uK] \{\
.    nop \&\*[U1],
.    nr aK 1
.    if (\n[uK] > 1) \{\
.      aK
.    \}
.    nr Kl -\n[uK]
.  \}
.
.  if \n[tK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \{\
.      ie ((\n[jK] == 1) : (\n[bK] == 1)) \{\
.        nop \&\*[q]\*[tK]\*[q].
.      \}
.      el \{\
.        nop \&\*[doc-Em-font]\*[tK]\*[doc-No-font].
.      \}
.    \}
.
.    if (\n[Kl] > 0) \{\
.      ie ((\n[jK] == 1) : (\n[bK] == 1)) \{\
.        nop \&\*[q]\*[tK]\*[q],
.      \}
.      el \{\
.        nop \&\*[doc-Em-font]\*[tK]\*[doc-No-font],
.      \}
.    \}
.  \}
.
.  if \n[bK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[doc-Em-font]\*[bK]\*[doc-No-font].
.    if (\n[Kl] > 0) \&\*[doc-Em-font]\*[bK]\*[doc-No-font],
.  \}
.
.  if \n[jK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[doc-Em-font]\*[jK]\*[doc-No-font].
.    if (\n[Kl] > 0) \&\*[doc-Em-font]\*[jK]\*[doc-No-font],
.  \}
.
.  if \n[rK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[rK].
.    if (\n[Kl] > 0) \&\*[rK],
.  \}
.
.  if \n[nK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[nK].
.    if (\n[Kl] > 0) \&\*[nK],
.  \}
.
.  if \n[vK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[vK].
.    if (\n[Kl] > 0) \&\*[vK],
.  \}
.
.  if \n[pK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[pK].
.    if (\n[Kl] > 0) \&\*[pK],
.  \}
.
.  if \n[qK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[qK].
.    if (\n[Kl] > 0) \&\*[qK],
.  \}
.
.  if \n[dK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[dK].
.    if (\n[Kl] > 0) \&\*[dK],
.  \}
.
.  if \n[oK] \{\
.    nr Kl (\n[Kl] - 1)
.    if (\n[Kl] == 0) \&\*[oK].
.    if (\n[Kl] > 0) \&\*[oK],
.  \}
.
.  if (\n[Kl] > 0) .tm unresolved reference problem
..
.
.
.\" NS aK macro - print out reference authors
.
.de aK
.  nr aK (\n[aK] + 1)
.  ie ((\n[uK] - \n[aK]) == 0) \{\
.    nop \&and \*[U\n[aK]],
.  \}
.  el \{\
.    nop \&\*[U\n[aK]],
.    aK
.  \}
..
.
.
.\" NS %A macro - reference author(s)
.\" NS uK register - reference author(s) counter
.\" NS U[1-9] strings - reference author(s) names
.
.de %A
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%A Author_name (#\n[.c])
.    el \{\
.      nr uK (\n[uK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS U\n[uK]
.      ds doc-macro-name %A
.      doc-parse-args \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %B macro - [reference] Book Name
.\" NS bK string - Book Name
.\" NS bK register - Book Name flag
.
.de %B
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%B Book Name (#\n[.c])
.    el \{\
.      ds doc-macro-name %B
.      if (\n[rS] > 0) \{\
.        nr bK (\n[bK] + 1)
.        nr Kl (\n[Kl] + 1)
.        ds rS bK
.      \}
.
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    ie (\n[rS] == 0) \{\
.      as doc-out-string \&\*[doc-Em-font]
.      doc-print-recursive
.    \}
.    el .rR
.  \}
..
.
.
.\" NS %D macro - [reference] Date
.\" NS dK string - Date String
.\" NS dK register - Date flag
.
.de %D
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%D Date (#\n[.c])
.    el \{\
.      ds doc-macro-name %D
.      nr dK (\n[dK] + 1)
.      nr Kl (\n[Kl] + 1)
.
.      ds rS dK
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %J macro - [reference] Journal Name
.\" NS jK register - [reference] Journal Name flag
.\" NS jK string - [reference] Journal Name
.
.de %J
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%J Journal Name (#\n[.c])
.      el \{\
.        ds doc-macro-name %J
.        nr jK (\n[jK] + 1)
.        ds rS jK
.        nr Kl (\n[Kl] + 1)
.
.        ds doc-arg1 \$1
.        ds doc-arg2 \$2
.        ds doc-arg3 \$3
.        ds doc-arg4 \$4
.        ds doc-arg5 \$5
.        ds doc-arg6 \$6
.        ds doc-arg7 \$7
.        ds doc-arg8 \$8
.        ds doc-arg9 \$9
.
.        nr doc-num-args \n[.$]
.        doc-parse-arg-vector
.      \}
.    \}
.
.    if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.      nr doc-arg-ptr +1
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      rR
.    \}
..
.
.
.\" NS %N macro - [reference] issue number
.\" NS nK register - [reference] issue number flag
.\" NS nK string - [reference] issue number
.
.de %N
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%N issue number (#\n[.c])
.    el \{\
.      nr nK (\n[nK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS nK
.      ds doc-macro-name %N
.      doc-parse-args \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %O macro - [reference] optional information
.\" NS oK register - [reference] optional information flag
.\" NS oK string - [reference] optional information
.
.de %O
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%O optional information ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name %O
.      nr oK (\n[oK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS oK
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %P macro - [reference] page numbers
.\" NS pK register - [reference] page number flag
.\" NS pK string - [reference] page number
.
.de %P
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%P page numbers ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name %P
.      nr pK (\n[pK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS pK
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %Q macro - Corporate or Foreign Author
.\" NS qK string - Corporate or Foreign Author
.\" NS qK register - Corporate or Foreign Author flag
.
.de %Q
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%Q Corporate or Foreign Author (#\n[.c])
.    el \{\
.      ds doc-macro-name %Q
.      nr qK (\n[qK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS qK
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %R macro - [reference] report name
.\" NS rK string - [reference] report name
.\" NS rK register - [reference] report flag
.
.de %R
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%R reference report (#\n[.c])
.    el \{\
.      ds doc-macro-name %R
.      nr rK (\n[rK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS rK
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS %T macro - reference title
.\" NS tK string - reference title
.\" NS tK register - reference title flag
.
.de %T
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%T (#\n[.c])
.    el \{\
.      ds doc-macro-name %T
.      if (\n[rS] > 0) \{\
.        nr tK (\n[tK] + 1)
.        nr Kl (\n[Kl] + 1)
.        ds rS tK
.      \}
.      ds doc-arg1 \$1
.      ds doc-arg2 \$2
.      ds doc-arg3 \$3
.      ds doc-arg4 \$4
.      ds doc-arg5 \$5
.      ds doc-arg6 \$6
.      ds doc-arg7 \$7
.      ds doc-arg8 \$8
.      ds doc-arg9 \$9
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    \" .ie (\n[jS] == 1) \{\
.    \" .  nr doc-curr-font \n[.f]
.    \" .  nr doc-curr-size \n[.s]
.    \" .  ds doc-quote-left \&\*[Lq]\*[rA]
.    \" .  ds doc-quote-right \&\*[Rq]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \" .  doc-enclose-string \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9
.    \" .\}
.    \" .el \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    ie (\n[rS] == 0) \{\
.      as doc-out-string \&\*[doc-Em-font]
.      doc-print-recursive
.    \}
.    el .rR
.    \" .\}
.  \}
..
.
.
.\" NS %V macro - reference volume
.\" NS vK string - reference volume
.\" NS vK register - reference volume flag
.
.de %V
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) .tm Usage: .%V Volume , ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name %V
.      nr vK (\n[vK] + 1)
.      nr Kl (\n[Kl] + 1)
.      ds rS vK
.      doc-parse-args \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    rR
.  \}
..
.
.
.\" NS rR macro - reference recursion routine
.\" NS jM local string
.\" NS jN local register
.
.de rR
.  hy 0
.  ds jM \*[doc-type\n[doc-arg-ptr]]
.
.  ie "\*[jM]"macro" \{\
.    \" .as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    ie "\*[doc-arg\n[doc-arg-ptr]]"Tn" \{\
.      nN
.    \}
.    el \{\
.      if (\n[doc-args-processed] > 8) \{\
.        tm Usage: \*[doc-macro-name] - maximum 8 arguments (#\n[.c])
.      \}
.      doc-append-arg rR macro
.      \*[doc-arg\n[doc-arg-ptr]]
.    \}
.  \}
.  el \{\
.    nr jN \n[doc-arg-ptr]
.    ie "\*[jM]"string" .as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    el .as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \" .el .as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      \" .as doc-out-string \&\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      rD
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      as doc-out-string \&\*[doc-space\n[jN]]
.      rR
.    \}
.  \}
.
.  rm jM
.  rr jN
..
.
.
.\" NS rD macro - save doc-out-string buffer in to appropriate name
.
.de rD
.  as \*[rS] \*[doc-out-string]
.  ds doc-out-string
.  ds rS
.  doc-reset-args
..
.
.
.\" NS Hf macro - source include header files.
.
.de Hf
.  doc-paragraph
.  nop File:
.  Pa \$1
.  doc-paragraph
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  ie t \{\
.    nop \&\*[doc-Li-font]
.    br
.    ta +9n 18n 27n 36n 45n 54n 63n 72n
.  \}
.  el \{\
.    ta +8n 16n 24n 32n 40n 48n 56n 64n 72n
.  \}
.
.  nf
.  so \$1
.  fi
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
.  doc-paragraph
..
.
.
.\" NS An user macro
.\" NS   author name
.\" NS aN register
.
.nr aN 0
.
.de An
.  if (\n[nY] == 1) \{\
.    ie (\n[aN] == 1) \{\
.      br
.    \}
.    el \{\
.      nr aN 1
.    \}
.  \}
.
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) \{\
.      tm Usage: .An author_name ... \*[doc-punct-chars] (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name An
.      doc-parse-args \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9
.    \}
.  \}
.
.  if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Sf macro -defunct
.
.de Sf
.  tm .Sf defunct, use prefix or Ns
..
.
.
.ds doc-func-error-string "function returns the value 0 if successful; otherwise the value -1 is returned and the global variable \*[doc-Va-font]errno\f[P] is set to indicate the error.
.
.
.\" NS Rv user macro
.\" NS   return values
.
.de Rv
.  ie (\n[.$] == 0) \{\
.    tm Usage: .Rv [-std] (#\n[.c])
.  \}
.  el \{\
.    ds doc-macro-name Rv
.
.    \" .nr doc-arg-ptr 0
.    \" .nr lR (\n[lR] + 1)
.    \" .ds doc-arg1 \$2
.    \" .ds doc-arg2 \$3
.    \" .ds doc-arg3 \$4
.    \" .ds doc-arg4 \$5
.    \" .ds doc-arg5 \$6
.    \" .ds doc-arg6 \$7
.    \" .ds doc-arg7 \$8
.    \" .ds doc-arg8 \$9
.    \" .
.    \" .nr doc-num-args (\n[.$] - 1)
.
.    if "\$1"-std" \{\
.      doc-reg-Rv \*[cH]
.      if ((\n[doc-reg-Rv] < 2) : (\n[doc-reg-Rv] > 3)) \{\
.        tm Usage: .Rv -std sections 2 and 3 only
.      \}
.      br
.      nop \&The
.      Fn \$2
.      nop \&\*[doc-func-error-string]
.    \}
.  \}
..
.
.
.ec
.
.\" EOF
