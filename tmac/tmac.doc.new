.\" Copyright (c) 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed by the University of
.\"      California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)doc 5.8 (Berkeley) 8/5/91
.\"
.\" Modified by jjc@jclark.com as follows: the doc-* files are assumed to be
.\" installed as mdoc/doc-* rather than tmac.doc-* (the filename
.\" `tmac.doc-common' would be too long); when using groff, the doc-* files
.\" are loaded using the `mso' request.
.\"
.\" Modified by wl@gnu.org to make it more readable: using long names and
.\" many groff features, updating and extending documentation.
.
.
.if !\n(.g \
.  ab This version of mdoc can be run with groff only!
.
.
.cp 0
.
.eo
.
.
.\" Load start-up files
.ie t .mso mdoc/doc-ditroff.new
.el   .mso mdoc/doc-nroff.new
.
.mso mdoc/doc-common.new
.mso mdoc/doc-syms.new
.
.
.\" NS doc-inline-debug register (bool)
.\" NS   inline debug mode (inline if 1, to stderr if 0 (default))
.
.nr doc-inline-debug 0
.
.
.\" NS doc-debug register (bool)
.\" NS   debug mode (1 if active, 0 otherwise (default))
.
.nr doc-debug 0
.
.
.\" NS Db macro
.\" NS   start/stop debug mode (`.Db'/`.Db on'/`.Db off')
.\" NS
.\" NS   without argument, toggle debug status
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-debug
.
.de Db
.  ie \n[.$] \{\
.    ie "\$1"on" \{\
.      tm DEBUGGING ON
.      nr doc-debug 1
.    \}
.    el \{\
.      ie "\$1"off" \{\
.        tm DEBUGGING OFF
.        nr doc-debug 0
.      \}
.      el \
.        tm Usage: .Db [on | off] (#\n[.c])
.  \}\}
.  el \{\
.    ie \n[doc-debug] \{\
.      tm DEBUGGING OFF
.      nr doc-debug 0
.    \}
.    el \{\
.      tm DEBUGGING ON
.      nr doc-debug 1
.  \}\}
..
.
.
.\" NS doc-macro-name string
.\" NS   name of calling request (set in each user-requestable macro)
.
.ds doc-macro-name
.
.
.\" NS doc-args-processed register
.\" NS   arguments processed so far
.
.nr doc-args-processed 0
.
.
.\" NS doc-num-args register
.\" NS   number of arguments (must be set to \n[.$] prior to
.\" NS   doc-parse-arg-vector request)
.
.nr doc-num-args 0
.
.
.\" NS doc-arg-ptr register
.\" NS   argument pointer
.
.nr doc-arg-ptr 0
.
.
.\" NS doc-argXXX string
.\" NS   argument vector
.
.
.\" NS doc-typeXXX string
.\" NS   argument type vector (`macro', `string', `punct-suffix',
.\" NS   `punct-prefix')
.
.
.\" NS doc-spaceXXX string
.\" NS   space vector
.
.
.\" NS doc-parse-args macro
.\" NS   parse arguments (recursively) (`.doc-parse-args arg ...')
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-argXXX, doc-typeXXX, doc-spaceXXX
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpa, doc-reg-dpa, doc-reg-dpa1
.
.de doc-parse-args
.  nr doc-args-processed +1
.
.  \" handle `|' specially for some requests
.  ie "\$1"|" \{\
.    ie "\*[doc-macro-name]"Op" \
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    el \{\
.      ie "\*[doc-macro-name]"Ar" \
.        ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.      el \{\
.        ie "\*[doc-macro-name]"Fl" \
.          ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.        el \{\
.          ie "\*[doc-macro-name]"Cm" \
.            ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.          el \{\
.            ie "\*[doc-macro-name]"It" \
.              ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.            el \
.              ds doc-arg\n[doc-args-processed] |
.  \}\}\}\}\}
.  el \
.    ds doc-arg\n[doc-args-processed] "\$1
.
.  \" get argument type and set spacing
.  doc-get-arg-type* \n[doc-args-processed]
.  ds doc-type\n[doc-args-processed] \*[doc-arg-type]
.  doc-set-spacing-for-\*[doc-arg-type]
.
.  if \n[doc-debug] \{\
.    ie "\*[doc-arg-type]"macro" \
.      ds doc-str-dpa macro
.    el \{\
.      ie "\*[doc-arg-type]"string" \
.        ds doc-str-dpa string
.      el \{\
.        ie "\*[doc-arg-type]"punct-suffix" \
.          ds doc-str-dpa closing punctuation or suffix
.        el \
.          ds doc-str-dpa opening punctuation or prefix
.    \}\}
.
.    ie \n[doc-inline-debug] \{\
.      br
.      nr doc-reg-dpa \n[.i]u
.      in -\n[doc-reg-dpa]u
.
.      if (\n[doc-args-processed] == 1) \{\
.        nop \f[B]DEBUG(doc-parse-args) MACRO:\f[P] `.\*[doc-macro-name]'
.        nop \& \f[B]Line #:\f[P] \n[.c]
.      \}
.      nop \t\f[B]Argc:\f[P] \n[doc-args-processed]
.      nop \ \f[B]Argv:\f[P] `\*[doc-arg\n[doc-args-processed]]'
.      nop \ \f[B]Length:\f[P] \n[doc-width]
.      nop \t\f[B]Space:\f[P] `\*[doc-space\n[doc-args-processed]]'
.      nop \ \f[B]Type:\f[P] \*[doc-str-dpa]
.    \}
.    el \{\
.      if (\n[doc-args-processed] == 1) \{\
.        tmc "DEBUG (doc-parse-args)
.        tm1 " MACRO: `.\*[doc-macro-name]'  Line #: \n[.c]
.      \}
.      tmc "  Argc: \n[doc-args-processed]
.      tmc "  Argv: `\*[doc-arg\n[doc-args-processed]]'
.      tm1 "  Length: \n[doc-width]
.      tmc "  Space: `\*[doc-space\n[doc-args-processed]]'
.      tm1 "  Type: \*[doc-str-dpa]
.  \}\}
.
.  \" check whether we have processed the last parameter
.  ie (\n[.$] == 1) \{\
.    nr doc-arg-ptr 0
.
.    ie \n[doc-in-diversion] \{\
.      if (\n[doc-nesting-level] > 1) \
.        as doc-out-string "\*[doc-curr-space]
.    \}
.    el \{\
.      if \n[doc-nesting-level] \
.        if !\n[doc-func-arg-count] \
.          as doc-out-string "\*[doc-curr-space]
.    \}
.
.    \" use space after last parameter as the current one
.    ds doc-curr-space "\*[doc-space\n[doc-args-processed]]
.
.    if \n[doc-debug] \{\
.      nr doc-reg-dpa1 1
.
.      ie \n[doc-inline-debug] \{\
.        nop MACRO REQUEST: \t.\*[doc-macro-name]
.        while (\n[doc-reg-dpa1] <= \n[doc-args-processed]) \{\
.          nop "\*[doc-arg\n[doc-reg-dpa1]]"
.          nr doc-reg-dpa1 +1
.        \}
.        br
.        in \n[doc-reg-dpa]u
.      \}
.      el \{\
.        tmc "  MACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpa1] <= \n[doc-args-processed]) \{\
.          tmc " "\*[doc-arg\n[doc-reg-dpa1]]"
.          nr doc-reg-dpa1 +1
.        \}
.        tm
.  \}\}\}
.  el \{\
.    shift
.    doc-parse-args \$@
.  \}
..
.
.
.\" NS doc-parse-arg-vector macro
.\" NS   parse argument vector (recursive)
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-argXXX, doc-typeXXX, doc-spaceXXX
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpav, doc-reg-dpav, doc-reg-dpav1
.
.de doc-parse-arg-vector
.  nr doc-args-processed +1
.
.  \" handle `|' specially for some requests
.  if "\*[doc-arg\n[doc-args-processed]]"|" \{\
.    ie "\*[doc-macro-name]"Op" \
.      ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.    el \{\
.      ie "\*[doc-macro-name]"Ar" \
.        ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.      el \{\
.        ie "\*[doc-macro-name]"Fl" \
.          ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.        el \{\
.          ie "\*[doc-macro-name]"Cm" \
.            ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.          el \{\
.            if "\*[doc-macro-name]"It" \
.              ds doc-arg\n[doc-args-processed] \f[R]|\f[P]
.  \}\}\}\}\}
.
.  \" get argument type and set spacing
.  doc-get-arg-type* \n[doc-args-processed]
.  ds doc-type\n[doc-args-processed] \*[doc-arg-type]
.  doc-set-spacing-for-\*[doc-arg-type]
.
.  if \n[doc-debug] \{\
.    ie "\*[doc-arg-type]"macro" \
.      ds doc-str-dpav macro
.    el \{\
.      ie "\*[doc-arg-type]"string" \
.        ds doc-str-dpav string
.      el \{\
.        ie "\*[doc-arg-type]"punct-suffix" \
.          ds doc-str-dpav closing punctuation or suffix
.        el \
.          ds doc-str-dpav opening punctuation or prefix
.    \}\}
.
.    ie \n[doc-inline-debug] \{\
.      br
.      nr doc-reg-dpav \n[.i]u
.      in -\n[doc-reg-dpav]u
.
.      if (\n[doc-args-processed] == 1) \{\
.        nop \f[B]DEBUG(doc-parse-arg-vector)
.        nop MACRO:\f[P] `.\*[doc-macro-name]'
.        nop \& \f[B]Line #:\f[P] \n[.c]
.      \}
.      nop \t\f[B]Argc:\f[P] \n[doc-args-processed]
.      nop \ \f[B]Argv:\f[P] `\*[doc-arg\n[doc-args-processed]]'
.      nop \ \f[B]Length:\f[P] \n[doc-width]
.      nop \t\f[B]Space:\f[P] `\*[doc-space\n[doc-args-processed]]'
.      nop \ \f[B]Type:\f[P] \*[doc-str-dpav]
.    \}
.    el \{\
.      if (\n[doc-args-processed] == 1) \{\
.        tmc "DEBUG(doc-parse-arg-vector)
.        tm1 " MACRO: `.\*[doc-macro-name]'  Line #: \n[.c]
.      \}
.      tmc "  Argc: \n[doc-args-processed]
.      tmc "  Argv: `\*[doc-arg\n[doc-args-processed]]'
.      tm1 "  Length: \n[doc-width]
.      tmc "  Space: `\*[doc-space\n[doc-args-processed]]'
.      tm1 "  Type: \*[doc-str-dpav]
.  \}\}
.
.  \" check whether we have processed the last parameter
.  ie (\n[doc-num-args] == 1) \{\
.    nr doc-arg-ptr 0
.
.    ie \n[doc-in-diversion] \{\
.      if (\n[doc-nesting-level] > 1) \
.        as doc-out-string "\*[doc-curr-space]
.    \}
.    el \{\
.      if \n[doc-nesting-level] \
.        if !\n[doc-func-arg-count] \
.          as doc-out-string "\*[doc-curr-space]
.    \}
.
.    \" use space after last parameter as the current one
.    ds doc-curr-space "\*[doc-space\n[doc-args-processed]]
.
.    nr doc-num-args 0
.
.    if \n[doc-debug] \{\
.      nr doc-reg-dpav1 1
.
.      ie \n[doc-inline-debug] \{\
.        nop \tMACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpav1] <= \n[doc-args-processed]) \{\
.          nop "\*[doc-arg\n[doc-reg-dpav1]]"
.          nr doc-reg-dpav1 +1
.        \}
.        br
.        in \n[doc-reg-dpav]u
.      \}
.      el \{\
.        tmc "  MACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpav1] <= \n[doc-args-processed]) \{\
.          tmc " "\*[doc-arg\n[doc-reg-dpav1]]"
.          nr doc-reg-dpav1 +1
.        \}
.        tm
.  \}\}\}
.  el \{\
.    nr doc-num-args -1
.    doc-parse-arg-vector
.  \}
..
.
.
.\" NS doc-remaining-args macro
.\" NS   output remaining arguments as-is, separated by spaces (until
.\" NS   `doc-num-args' is exhausted), to `doc-out-string'
.
.de doc-remaining-args
.  nr doc-arg-ptr +1
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.
.  ie (\n[doc-num-args] == 1) \{\
.    nr doc-arg-ptr 0
.    nr doc-num-args 0
.  \}
.  el \{\
.    as doc-out-string "\*[doc-space]
.    nr doc-num-args -1
.    doc-remaining-args
.  \}
..
.
.
.\" NS doc-append-arg macro
.\" NS   append one argument to argument vector:
.\" NS   `.doc-append-arg [arg] [type]'
.
.de doc-append-arg
.  nr doc-args-processed +1
.  ds doc-arg\n[doc-args-processed] "\$1
.  ds doc-type\n[doc-args-processed] \$2
.  doc-set-spacing-for-\$2
..
.
.
.\" NS doc-print-and-reset macro
.\" NS   print doc-out-string and clean up argument vectors
.
.de doc-print-and-reset
.  doc-print-out-string
.  doc-reset-args
..
.
.
.\" NS doc-reset-args macro
.\" NS   reset argument counters
.
.de doc-reset-args
.  nr doc-args-processed 0
.  nr doc-arg-ptr 0
..
.
.
.\" NS doc-print-out-string macro
.\" NS   print `doc-out-string', possibly ending a diversion, enabling
.\" NS   hyphenation afterwards
.
.de doc-print-out-string
.  ie \n[doc-in-diversion] \{\
.    if (\n[doc-nesting-level] == 1) \{\
.      nop \&\*[doc-out-string]
.      ds doc-curr-space
.      ds doc-out-string
.    \}
.    if !\n[doc-nesting-level] \
.      doc-end-diversion-and-print
.  \}
.  el \{\
.    ie \n[doc-nesting-level] \{\
.      if \n[doc-space-mode] \
.        if !\n[doc-list-immediate] \
.          doc-save-and-divert
.    \}
.    el \{\
.      nop \&\*[doc-out-string]
.      ds doc-curr-space
.      ds doc-out-string
.  \}\}
.
.  hy
..
.
.
.\" NS doc-diversion diversion
.\" NS   diversion string
.
.
.\" NS doc-saved-out-string string
.\" NS   saved doc-out-string
.
.
.\" NS doc-in-diversion register (bool)
.\" NS   whether we are in a diversion
.
.nr doc-in-diversion 0
.
.
.\" NS doc-save-and-divert macro
.\" NS   save doc-out-string, restore fill mode, and divert
.
.de doc-save-and-divert
.  nr doc-in-diversion 1
.  ds doc-saved-out-string "\*[doc-out-string]
.  ds doc-out-string
.  ev doc-divert-environment
.  fi
.  di doc-diversion
..
.
.
.\" NS doc-end-diversion-and-print macro
.\" NS   end diversion and print
.
.de doc-end-diversion-and-print
.  br
.  di
.  ev
.
.  \" insert diversion only if it contains printable stuff
.  ie \n[dn] \{\
.    ds doc-str-dedap \&\*[doc-diversion]\c
.    ds doc-out-string "\*[doc-saved-out-string]\*[doc-str-dedap]\*[doc-out-string]
.  \}
.  el \
.    ds doc-out-string "\*[doc-saved-out-string]\*[doc-out-string]
.
.  nop \&\*[doc-out-string]
.
.  ds doc-out-string
.  nr doc-in-diversion 0
..
.
.
.\" NS doc-curr-font register
.\" NS   saved current font
.\" NS doc-curr-size register
.\" NS   saved current font size
.
.ec
.nr doc-curr-font \n[.f]
.nr doc-curr-size \n[.s]
.eo
.
.
.\" NS Fl user macro
.\" NS   handle flags (appends `-' and prints flags): `.Fl [arg ...]'
.\" NS
.\" NS width register `.Fl' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Fl (for communication with doc-flag-recursion)
.
.de Fl
.  as doc-out-string \*[doc-Fl-font]
.
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fl
.      doc-parse-args \$@
.    \}
.    el \{\
.      \" no arguments
.      as doc-out-string \|\-\|\f[P]\s[0]
.      doc-print-out-string
.  \}\}
.
.  if \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \|\-\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        as doc-out-string \|\-\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.
.        if "\*[doc-type\n[doc-arg-ptr]]"punct-suffix" \
.          as doc-out-string \|\-\|
.
.        nr doc-reg-Fl 1
.        doc-flag-recursion
.  \}\}\}
..
.
.
.\" NS doc-flag-recursion macro
.\" NS   `Fl' flag recursion routine (special handling)
.\" NS
.\" NS local variables:
.\" NS   doc-str-dfr, doc-str-dfr1, doc-reg-dfr
.
.de doc-flag-recursion
.  ds doc-str-dfr \*[doc-type\n[doc-arg-ptr]]
.  ds doc-str-dfr1 "\*[doc-arg\n[doc-arg-ptr]]
.
.  hy 0
.
.  ie "\*[doc-str-dfr]"macro" \{\
.    as doc-out-string \f[P]\s[0]
.    \*[doc-str-dfr1]
.  \}
.  el \{\
.    nr doc-reg-dfr \n[doc-arg-ptr]
.
.    ie "\*[doc-str-dfr]"string" \{\
.      \" handle vertical bar -- doc-reg-Fl is set for the first call of
.      \" doc-flag-recursion only; we need this to make `.Fl | ...' work
.      \" correctly
.      ie "\*[doc-str-dfr1]"\*[Ba]" \{\
.        if \n[doc-reg-Fl] \
.          as doc-out-string \|\-\*[doc-space]
.        as doc-out-string \&\*[Ba]
.      \}
.      el \{\
.        ie "\*[doc-str-dfr1]"\f[R]|\f[P]" \{\
.          if \n[doc-reg-Fl] \
.            as doc-out-string \|\-\*[doc-space]
.          as doc-out-string \f[R]|\f[P]
.        \}
.        el \{\
.          \" two consecutive hyphen characters?
.          ie "\*[doc-str-dfr1]"-" \
.            as doc-out-string \|\-\^\-\|
.          el \
.            as doc-out-string \|\-\*[doc-str-dfr1]
.    \}\}\}
.    el \{\
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as doc-out-string "\*[doc-str-dfr1]\f[P]\s[0]
.    \}
.
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      \" last argument
.      if "\*[doc-str-dfr]"punct-prefix" \
.        as doc-out-string \|\-
.      as doc-out-string \f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"punct-suffix" \{\
.        ie "\*[doc-type\n[doc-reg-dfr]]"punct-prefix" \
.          as doc-out-string \|\-
.        el \
.          as doc-out-string "\*[doc-space\n[doc-reg-dfr]]
.      \}
.      el \
.        as doc-out-string "\*[doc-space\n[doc-reg-dfr]]
.
.      shift
.      nr doc-reg-Fl 0
.      doc-flag-recursion \$@
.  \}\}
..
.
.
.\" NS doc-print-recursive macro
.\" NS   general name recursion routine (print remaining arguments)
.\" NS
.\" NS   hyphenation is disabled
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpr, doc-str-dpr1, doc-reg-dpr
.
.de doc-print-recursive
.  ds doc-str-dpr \*[doc-type\n[doc-arg-ptr]]
.  ds doc-str-dpr1 "\*[doc-arg\n[doc-arg-ptr]]
.
.  hy 0
.
.  ie "\*[doc-str-dpr]"macro" \{\
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \*[doc-str-dpr1]
.  \}
.  el \{\
.    nr doc-reg-dpr \n[doc-arg-ptr]
.
.    ie "\*[doc-str-dpr]"string" \
.      as doc-out-string \&\*[doc-str-dpr1]
.    el \{\
.      \" punctuation character
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as doc-out-string "\*[doc-str-dpr1]\f[P]\s[0]
.    \}
.
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      doc-print-and-reset
.    \}
.    el \{\
.      as doc-out-string "\*[doc-space\n[doc-reg-dpr]]
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS Ar user macro
.\" NS   command line `argument' macro: `.Ar [args ...]'
.\" NS
.\" NS width register `.Ar' set in doc-common
.
.de Ar
.  as doc-out-string \*[doc-Ar-font]
.
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ar
.      doc-parse-args \$@
.    \}
.    el \{\
.      \" no argument
.      as doc-out-string \&file\ ...\f[P]\s[0]
.      doc-print-out-string
.  \}\}
.
.  if \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] < \n[doc-arg-ptr]) \{\
.      as doc-out-string \&file\ ...\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        as doc-out-string \&file\ ...\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.        if "\*[doc-type\n[doc-arg-ptr]]"punct-suffix" \
.          as doc-out-string \&file\ ...
.        doc-print-recursive
.  \}\}\}
..
.
.
.\" NS Ad user macro
.\" NS   Addresses
.\" NS
.\" NS width register `.Ad' set in doc-common
.
.de Ad
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ad
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ad address ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ad-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Cd user macro
.\" NS   Config declaration (for section 4 SYNOPSIS)
.\" NS
.\" NS   this function causes a break; it uses the `Nm' font
.\" NS
.\" NS width register `.Cd' set in doc-common
.\"
.\" needs work - not very translatable
.
.de Cd
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Cd
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Cd Configuration file declaration (#\n[.c])
.  \}
.
.  br
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Nm-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    ie \n[doc-in-synopsis-section] \{\
.      if "\*[doc-macro-name]"Cd" \{\
.        rs
.        ie (\n[doc-in-synopsis-section] > 1) \
.          br
.        el \{\
.          if !\n[doc-indent-synopsis] \
.            nr doc-indent-synopsis \n[doc-display-indent]u
.        \}
.        in +\n[doc-indent-synopsis]u
.        ti -\n[doc-indent-synopsis]u
.        nr doc-in-synopsis-section +1
.      \}
.
.      doc-print-recursive
.      in -\n[doc-indent-synopsis]u
.    \}
.    el \
.      doc-print-recursive
.  \}
..
.
.
.\" NS Cm user macro
.\" NS   Interactive command modifier (flag)
.\" NS
.\" NS width register `.Cm' set in doc-common
.
.de Cm
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Cm
.      doc-parse-args \$@
.    \}
.    el \{\
.      tmc Usage: .Cm Interactive command modifier ...
.      tm1 " \*[doc-punct-chars] (#\n[.c])
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Cm-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Dv user macro
.\" NS   define variable
.\" NS
.\" NS   this function uses the `Er' font
.\" NS
.\" NS width register `.Dv' set in doc-common
.
.de Dv
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Dv
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Dv define_variable ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Er-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Em user macro
.\" NS   emphasis
.\" NS
.\" NS width register `.Em' set in doc-common
.
.de Em
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Em
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Em text ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Em-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Er user macro
.\" NS   errno type
.\" NS
.\" NS width register `.Er' set in doc-common
.
.de Er
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Er
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Er errno_type ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Er-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ev user macro
.\" NS   environment variable
.\" NS
.\" NS width register `.Ev' set in doc-common
.
.de Ev
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ev
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ev enviroment_variable ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ev-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-declaration-count register
.\" NS   subroutine test (in synopsis only)
.
.nr doc-declaration-count 0
.
.
.\" NS doc-do-function-declaration macro
.\" NS
.\" NS   do someting special while in SYNOPSIS
.
.de doc-do-function-declaration
.  if \n[doc-in-synopsis-section] \{\
.    \" if a variable type was the last thing given, want vertical space
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.    \" if a subroutine was the last thing given, want vertical space
.    if \n[doc-function-count] \{\
.      ie \n[doc-declaration-count] \
.        br
.      el \{\
.        doc-paragraph
.        rs
.    \}\}
.    nr doc-declaration-count +1
.  \}
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
..
.
.
.\" NS Fd user macro
.\" NS   function declaration -- not callable
.\" NS
.\" NS   this function causes a break
.\" NS
.\" NS width register `.Fd' set in doc-common
.
.de Fd
.  ie \n[doc-args-processed] \
.    tm Usage: .Fd function_declaration -- Fd is not callable (#\n[.c])
.  el \{\
.    doc-do-function-declaration
.    nop \*[doc-Fd-font]\$*
.    br
.    ft \n[doc-curr-font]
.    fs \n[doc-curr-size]
.  \}
..
.
.
.\" NS In user macro
.\" NS   #include statement - not callable (& no err check)
.\" NS
.\" NS   this function causes a break; it uses the `Fd' font
.\" NS
.\" NS width register `.In' set in doc-common
.
.de In
.  ie \n[doc-args-processed] \
.    tm Usage: .In #include_statement -- In is not callable (#\n[.c])
.  el \{\
.    doc-do-function-declaration
.    nop \*[doc-Fd-font]#include <\$1>
.    br
.    ft \n[doc-curr-font]
.    fs \n[doc-curr-size]
.  \}
..
.
.
.\" NS Fr user macro
.\" NS   function return value
.\" NS
.\" NS   this function uses the `Ar' font
.\" NS
.\" NS width register `.Fr' set in doc-common
.
.de Fr
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fr
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Fr Function_return_value... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ar-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ic user macro
.\" NS   interactive command
.\" NS
.\" NS width register `.Ic' set in doc-common
.
.de Ic
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ic
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ic Interactive command ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ic-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Li user macro
.\" NS   literals
.\" NS
.\" NS width register `.Li' set in doc-common
.
.de Li
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Li
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Li argument ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Li-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Or user macro
.\" NS   pipe symbol (OR)
.\" NS
.\" NS width register `.Or' set in doc-common
.\"
.\" XXX: What is this function good for?  It sets a font but does not print
.\"      a pipe symbol.  And it isn't documented.
.
.de Or
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Or
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Or ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ic-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ms user macro
.\" NS   math symbol
.\" NS
.\" NS   this function uses the `Sy' font
.\" NS
.\" NS width register `.Ms' set in doc-common
.
.de Ms
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ms
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ms Math symbol ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Sy-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-command-name string
.\" NS   save first invocation of .Nm
.
.ds doc-command-name
.
.
.\" NS Nm user macro
.\" NS   name of command or page topic
.\" NS
.\" NS width register `.Nm' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-str-Nm
.
.de Nm
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Nm
.
.      \" handle empty first parameter
.      ie "\$1"" \
.        ds doc-str-Nm "\*[doc-command-name]
.      el \
.        ds doc-str-Nm "\$1
.      shift
.      doc-parse-args "\*[doc-str-Nm]" \$@
.    \}
.    el \{\
.      ie "\*[doc-command-name]"" \
.        tm Usage: .Nm Name ... \*[doc-punct-chars] (#\n[.c])
.      el \
.        nop \*[doc-Nm-font]\*[doc-command-name]\f[P]\s[0]
.  \}\}
.
.  if \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \*[doc-Nm-font]\*[doc-command-name]\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      as doc-out-string \*[doc-Nm-font]
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \{\
.        as doc-out-string \&\*[doc-command-name]\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.
.        \" handle `.Nm ...' in SYNOPSIS
.        if \n[doc-in-synopsis-section] \{\
.          if "\*[doc-macro-name]"Nm" \{\
.            rs
.            in -\n[doc-indent-synopsis]u
.            ie (\n[doc-in-synopsis-section] > 1) \
.              br
.            el \{\
.              if !\n[doc-indent-synopsis] \{\
.                doc-get-width \$1
.                nr doc-indent-synopsis ((\n[doc-width]u + 1u) * \n[doc-fixed-width]u)
.            \}\}
.            in +\n[doc-indent-synopsis]u
.            ti -\n[doc-indent-synopsis]u
.            nr doc-in-synopsis-section +1
.        \}\}
.        if "\*[doc-command-name]"" \
.          ds doc-command-name "\*[doc-arg\n[doc-arg-ptr]]
.        doc-print-recursive
.  \}\}\}
..
.
.
.\" NS Pa user macro
.\" NS   pathname: `.Pa [arg ...]'
.\" NS
.\" NS width register `.Pa' set in doc-common
.
.de Pa
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Pa
.      doc-parse-args \$@
.    \}
.    el \{\
.      \" default value
.      nop \*[doc-Pa-font]~\f[P]\s[0]
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Pa-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Sy user macro
.\" NS   symbolics
.\" NS
.\" NS width register `.Sy' set in doc-common
.
.de Sy
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Sy
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Sy symbolic_text ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Sy-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Me user macro
.\" NS   menu entries
.\" NS
.\" NS width register `.Me' set in doc-common
.
.de Me
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Me
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Me menu_entry ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Me-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Tn user macro
.\" NS   trade name
.\" NS
.\" NS width register `.Tn' set in doc-common
.
.de Tn
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Tn
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Tn trade_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Tn-font-shape]\*[doc-Tn-font-size]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-reference-trademark macro
.\" NS   .Tn for inside of references
.\" NS
.\" NS   the code for references below checks for `Tn'!
.
.de doc-reference-trademark
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Tn
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Tn trade_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Tn-font-size]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS Va user macro
.\" NS   variable name
.\" NS
.\" NS width register `.Va' set in doc-common
.
.de Va
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Va
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Va variable_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Va-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS No user macro
.\" NS   normal text macro (default text style if mess up)
.\" NS
.\" NS width register `.No' set in doc-common
.
.de No
.  as doc-out-string \*[doc-No-font]
.
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name No
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .No normal_text ... \*[doc_punct_chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    ie "\*[doc-type\n[doc-arg-ptr]]"macro" \
.      \*[doc-arg\n[doc-arg-ptr]]
.    el \{\
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS Op user macro
.\" NS   option expression (i.e., enclose string in square brackets)
.\" NS
.\" NS width register `.Op' set in doc-common
.
.de Op
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Op
.
.  ds doc-quote-left "\*[doc-left-bracket]
.  ds doc-quote-right "\*[doc-right-bracket]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Aq user macro
.\" NS   enclose string in angle brackets
.\" NS
.\" NS width register `.Aq' set in doc-common
.
.de Aq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Aq
.
.  ds doc-quote-left <
.  ds doc-quote-right >
.
.  doc-enclose-string \$@
..
.
.
.\" NS Bq user macro
.\" NS   enclose string in square brackets
.\" NS
.\" NS width register `.Bq' set in doc-common
.
.de Bq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Bq
.
.  ds doc-quote-left "\*[doc-left-bracket]
.  ds doc-quote-right "\*[doc-right-bracket]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Dq user macro
.\" NS   enclose string in double quotes
.\" NS
.\" NS width register `.Dq' set in doc-common
.
.de Dq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Dq
.
.  ds doc-quote-left "\*[Lq]
.  ds doc-quote-right "\*[Rq]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Eq user macro
.\" NS   enclose string in user-defined quotes (args 1 and 2)
.\" NS
.\" NS width register `.Eq' set in doc-common
.
.de Eq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Eq
.
.  ds doc-quote-left "\$1
.  ds doc-quote-right "\$2
.
.  shift 2
.  doc-enclose-string \$@
..
.
.
.\" NS Pq user macro
.\" NS   enclose string in parentheses
.\" NS
.\" NS width register `.Pq' set in doc-common
.
.de Pq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Pq
.
.  ds doc-quote-left "\*[doc-left-parenthesis]
.  ds doc-quote-right "\*[doc-right-parenthesis]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Ql user macro
.\" NS   quoted literal
.\"
.\"   is in file doc-[dit|n]roff
.
.
.\" NS Qq user macro
.\" NS   enclose string in straight double quotes
.\" NS
.\" NS width register `.Qq' set in doc-common
.
.de Qq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Qq
.
.  ds doc-quote-left "\*[q]
.  ds doc-quote-right "\*[q]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Sq user macro
.\" NS   enclose string in single quotes
.\" NS
.\" NS width register `.Sq' set in doc-common
.
.de Sq
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Sq
.
.  ds doc-quote-left "\*[doc-left-singlequote]
.  ds doc-quote-right "\*[doc-right-singlequote]
.
.  doc-enclose-string \$@
..
.
.
.\" NS doc-temp-args-processed register
.\" NS   for data transfer to/from doc-skip-punct-backwards
.
.nr doc-temp-args-processed 0
.
.
.\" NS doc-enclose-string macro
.\" NS   enclose string with given args (e.g. [ and ])
.\" NS
.\" NS requires:
.\" NS   doc-quote-left (to be set by calling macro)
.\" NS   doc-quote-right (to be set by calling macro)
.
.de doc-enclose-string
.  ie \n[doc-args-processed] \
.    as doc-out-string \&\*[doc-quote-left]
.  el \{\
.    ie \n[.$] \{\
.      doc-parse-args \$@
.      as doc-out-string \&\*[doc-quote-left]
.    \}
.    el \{\
.      \" no argument
.      as doc-out-string \&\*[doc-quote-left]\*[doc-quote-right]
.      doc-print-out-string
.  \}\}
.
.  if \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \&\*[doc-quote-right]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie "\*[doc-type\n[doc-args-processed]]"punct-suffix" \{\
.        nr doc-temp-args-processed (\n[doc-args-processed] - 1)
.        doc-skip-punct-backwards
.        nr doc-temp-args-processed +1
.        ds doc-arg\n[doc-temp-args-processed] "\*[doc-quote-right]\&\*[doc-arg\n[doc-temp-args-processed]]
.        nr doc-temp-args-processed 0
.      \}
.      el \
.        doc-append-arg "\*[doc-quote-right]" punct-suffix
.
.      doc-do-\*[doc-type\n[doc-arg-ptr]]
.  \}\}
..
.
.
.\" NS doc-skip-punct-backwards macro
.\" NS   vector routine (for `doc-enclose-string': trace backwards past
.\" NS   trailing punctuation)
.
.de doc-skip-punct-backwards
.  if "\*[doc-type\n[doc-temp-args-processed]]"punct-suffix" \{\
.    nr doc-temp-args-processed -1
.    doc-skip-punct-backwards
.  \}
..
.
.
.\" NS Ao user macro
.\" NS   angle open
.\" NS
.\" NS width register `.Ao' set in doc-common
.
.de Ao
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Ao
.
.  ds doc-quote-left <
.
.  doc-enclose-open \$@
..
.
.
.\" NS Ac user macro
.\" NS   angle close
.\" NS
.\" NS width register `.Ac' set in doc-common
.
.de Ac
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Ac
.
.  ds doc-quote-right >
.
.  doc-enclose-close \$@
..
.
.
.\" NS Bo user macro
.\" NS   bracket open
.\" NS
.\" NS width register `.Bo' set in doc-common
.
.de Bo
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Bo
.
.  ds doc-quote-left [
.
.  doc-enclose-open \$@
..
.
.
.\" NS Bc user macro
.\" NS   bracket close
.\" NS
.\" NS width register `.Bc' set in doc-common
.
.de Bc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Bc
.
.  ds doc-quote-right ]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Do user macro
.\" NS   double quote open
.\" NS
.\" NS width register `.Do' set in doc-common
.
.de Do
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Do
.
.  ds doc-quote-left "\*[Lq]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Dc user macro
.\" NS   double quote close
.\" NS
.\" NS width register `.Dc' set in doc-common
.
.de Dc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Dc
.
.  ds doc-quote-right "\*[Rq]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Eo user macro
.\" NS   enclose open (using first argument as beginning of enclosure)
.\" NS
.\" NS width register `.Eo' set in doc-common
.
.de Eo
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Eo
.
.  ds doc-quote-left "\$1
.
.  shift
.  doc-enclose-open \$@
..
.
.
.\" NS Ec user macro
.\" NS   enclose close (using first argument as end of enclosure)
.\" NS
.\" NS width register `.Ec' set in doc-common
.
.de Ec
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Ec
.
.  ds doc-quote-right "\$1
.
.  shift
.  doc-enclose-close \$@
..
.
.
.\" NS Oo user macro
.\" NS   option open
.\" NS
.\" NS width register `.Oo' set in doc-common
.
.de Oo
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Oo
.
.  ds doc-quote-left [
.
.  doc-enclose-open \$@
..
.
.
.\" NS Oc user macro
.\" NS   option close
.\" NS
.\" NS width register `.Oc' set in doc-common
.
.de Oc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Oc
.
.  ds doc-quote-right ]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Po user macro
.\" NS   parenthesis open
.\" NS
.\" NS width register `.Po' set in doc-common
.
.de Po
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Po
.
.  ds doc-quote-left (
.
.  doc-enclose-open \$@
..
.
.
.\" NS Pc user macro
.\" NS   parenthesis close
.\" NS
.\" NS width register `.Pc' set in doc-common
.
.de Pc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Pc
.
.  ds doc-quote-right )
.
.  doc-enclose-close \$@
..
.
.
.\" NS Qo user macro
.\" NS   straight double quote open
.\" NS
.\" NS width register `.Qo' set in doc-common
.
.de Qo
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Qo
.
.  ds doc-quote-left "\*[q]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Qc user macro
.\" NS   straight double quote close
.\" NS
.\" NS width register `.Qc' set in doc-common
.
.de Qc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Qc
.
.  ds doc-quote-right "\*[q]
.
.  doc-enclose-close \$@
..
.
.
.\" NS So user macro
.\" NS   single quote open
.\" NS
.\" NS width register `.So' set in doc-common
.
.de So
.  if !\n[doc-args-processed] \
.    ds doc-macro-name So
.
.  ds doc-quote-left "\*[doc-left-singlequote]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Sc user macro
.\" NS   single quote close
.\" NS
.\" NS width register `.Sc' set in doc-common
.
.de Sc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Sc
.
.  ds doc-quote-right "\*[doc-right-singlequote]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Xo user macro
.\" NS   extend open
.\" NS
.\" NS width register `.Xo' set in doc-common
.
.de Xo
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Xo
.
.  ds doc-quote-left
.
.  doc-enclose-open \$@
..
.
.
.\" NS Xc user macro
.\" NS   extend close
.\" NS
.\" NS width register `.Xc' set in doc-common
.
.de Xc
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Xc
.
.  ds doc-quote-right
.
.  doc-enclose-close \$@
..
.
.
.\" NS doc-nesting-level register
.\" NS   (extension possible)
.
.nr doc-nesting-level 0
.
.
.\" NS doc-enclose-open macro
.\" NS   enclose string open
.
.de doc-enclose-open
.  nr doc-nesting-level +1
.
.  ie \n[doc-args-processed] \
.    as doc-out-string \&\*[doc-quote-left]
.  el \{\
.    ie \n[.$] \{\
.      doc-parse-args \$@
.      as doc-out-string \&\*[doc-quote-left]
.    \}
.    el \{\
.      as doc-out-string \&\*[doc-quote-left]
.
.      if !\n[doc-in-diversion] \
.        if \n[doc-space-mode] \
.          doc-save-and-divert
.  \}\}
.
.  ie \n[doc-args-processed] \{\
.    if (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.      nr doc-arg-ptr +1
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \
.        \*[doc-arg\n[doc-arg-ptr]]
.      el \{\
.        nr doc-arg-ptr -1
.        No
.    \}\}
.
.    if (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      if \n[doc-list-immediate] \{\
.        \" .tm SETTING doc-saved-list-immediate!
.        nr doc-saved-list-immediate 1
.      \}
.      doc-reset-args
.  \}\}
.  el \{\
.    if (\n[doc-nesting-level] > 1) \
.      as doc-out-string "\*[doc-space]
.  \}
..
.
.
.ds doc-saved-list-type
.
.
.\" NS doc-enclose-close macro
.\" NS   enclose string close
.\" NS
.\" NS local variable:
.\" NS   doc-str-dec
.
.de doc-enclose-close
.  nr doc-nesting-level -1
.
.  as doc-out-string \&\*[doc-quote-right]
.
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \
.      doc-parse-args \$@
.    el \{\
.      doc-print-out-string
.      if !"\*[doc-saved-list-type]"" \{\
.        doc-\*[doc-list-stack\n[doc-list-depth]]
.        nr doc-saved-list-immediate 0
.        ds doc-saved-list-type
.  \}\}\}
.
.  if \n[doc-args-processed] \{\
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      ie \n[doc-nesting-level] \
.        doc-reset-args
.      el \
.        doc-print-and-reset
.    \}
.    el \{\
.      nr doc-str-dec (\n[doc-arg-ptr] + 1)
.      if "\*[doc-type\n[doc-str-dec]]"string" \
.        as doc-out-string "\*[doc-space\n[doc-args-processed]]
.
.      if \n[doc-list-immediate] \{\
.        \" .tm UNSETTING doc-saved-list-immediate==\n[doc-saved-list-immediate]!
.        if \n[doc-saved-list-immediate] \
.          nr doc-saved-list-immediate 0
.      \}
.      No
.  \}\}
..
.
.
.\" NS Pf user macro
.\" NS   prefix: `.Pf prefix arg ...'
.\" NS
.\" NS width register `.Pf' set in doc-common
.
.de Pf
.  if !\n[doc-args-processed] \
.    ds doc-macro-name Pf
.
.  ds doc-quote-left "\$1
.
.  shift
.
.  ie \n[doc-args-processed] \{\
.    ie ((\n[doc-args-processed] - \n[doc-arg-ptr]) > 1) \{\
.      nr doc-arg-ptr +1
.      as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \}
.    el \
.      tm mdoc warning: .Pf: trailing prefix (#\n[.c])
.  \}
.  el \{\
.    as doc-out-string \&\*[doc-quote-left]
.    ie (\n[.$] < 2) \{\
.      tm mdoc warning: .Pf: missing arguments (#\n[.c])
.      doc-print-out-string
.    \}
.    el \
.      doc-parse-args \$@
.  \}
.
.  if \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] < \n[doc-arg-ptr]) \
.      doc-print-and-reset
.    el \
.      doc-do-\*[doc-type\n[doc-arg-ptr]]
.  \}
..
.
.
.\" NS Ns user macro
.\" NS   remove space (space removal done by .doc-parse-args)
.\" NS
.\" NS width register `.Ns' set in doc-common
.
.de Ns
.  if !\n[doc-args-processed] \{\
.    ds doc-macro-name Ns
.    ie \n[.$] \
.      doc-parse-args \$@
.    el \
.      tm Usage: .Ns must be called with arguments (#\n[.c])
.  \}
.
.  No
..
.
.
.\" NS Ap user macro
.\" NS   append an apostrophe
.\" NS
.\" NS width register `.Ap' set in doc-common
.
.de Ap
.  if !\n[doc-args-processed] \
.    tm Usage: `Ap' cannot be first request on a line (no `.Ap') (#\n[.c])
.
.  as doc-out-string \&'
.  No
..
.
.
.\" NS doc-space string
.\" NS   current inter-argument space
.
.ds doc-space "\*[doc-soft-space]
.
.
.\" NS doc-soft-space string
.\" NS   soft (stretchable) space (defined in doc-common)
.
.\" NS doc-hard-space string
.\" NS   hard (unpaddable) space (defined in doc-common)
.
.
.\" NS doc-set-hard-space macro
.\" NS   set current space string to hard (unpaddable) space.
.
.de doc-set-hard-space
.  ds doc-space "\*[doc-hard-space]
..
.
.
.\" NS doc-set-soft-space macro
.\" NS   set current space string to soft space (troff limitation)
.
.de doc-set-soft-space
.  ds doc-space "\*[doc-soft-space]
..
.
.
.\" NS doc-space-mode register
.\" NS   default is one (space mode on)
.
.nr doc-space-mode 1
.
.
.\" NS Sm user macro
.\" NS   space mode (`.Sm'/`.Sm on'/`.Sm off')
.\" NS
.\" NS   without argument, toggle space mode
.\" NS
.\" NS width register `.Sm' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Sm
.
.de Sm
.  if !\n[doc-args-processed] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Sm
.      doc-parse-args \$@
.    \}
.    el \{\
.      ie \n[doc-space-mode] \
.        nr doc-space-mode 0
.      el \
.        nr doc-space-mode 1
.  \}\}
.
.  if \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.
.    \" avoid a warning message in case `Sm' is the last parameter
.    if !d doc-arg\n[doc-arg-ptr] \
.      ds doc-arg\n[doc-arg-ptr]
.
.    ie "\*[doc-arg\n[doc-arg-ptr]]"on" \{\
.      ds doc-space "\*[doc-soft-space]
.      nr doc-space-mode 1
.    \}
.    el \{\
.      ie "\*[doc-arg\n[doc-arg-ptr]]"off" \{\
.        ds doc-space
.        ds doc-curr-space
.        nr doc-space-mode 0
.      \}
.      el \{\
.        \" no argument for Sm
.        nr doc-arg-ptr -1
.        ie \n[doc-space-mode] \
.          nr doc-space-mode 0
.        el \
.          nr doc-space-mode 1
.    \}\}
.
.    ie \n[doc-space-mode] \{\
.      \" recompute space vector for remaining arguments
.      nr doc-num-args (\n[doc-args-processed] - \n[doc-arg-ptr])
.      nr doc-args-processed \n[doc-arg-ptr]
.      nr doc-reg-Sm \n[doc-arg-ptr]
.      if \n[doc-num-args] \{\
.        doc-parse-arg-vector
.        nr doc-arg-ptr \n[doc-reg-Sm]
.    \}\}
.    el \{\
.      \" reset remaining space vector elements
.      nr doc-reg-Sm (\n[doc-arg-ptr] + 1)
.      while (\n[doc-reg-Sm] <= \n[doc-args-processed]) \{\
.        ds doc-space\n[doc-reg-Sm]
.        nr doc-reg-Sm +1
.        \" the body of a `while' request must end with the fitting `\}'
.      \}
.    \}
.
.    \" do we have parameters to print?
.    ie (\n[doc-args-processed] <= \n[doc-arg-ptr]) \{\
.      \" ignore `.Sm on' and `.Sm off' without additional parameters
.      ie (\n[doc-arg-ptr] > 1) \
.        doc-print-and-reset
.      el \
.        doc-reset-args
.    \}
.    el \{\
.      \" skip `Sm' argument
.      nr doc-arg-ptr +1
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS   doc-arg-type string
.\" NS     argument type
.
.ds doc-arg-type
.
.
.\" NS doc-get-arg-type macro
.\" NS   get argument type (`macro', `string', `punct-suffix', or
.\" NS   `punct-prefix')
.\" NS
.\" NS   this macro expects the width of the argument in `doc-width'
.\" NS
.\" NS modifies:
.\" NS   doc-arg-type
.
.de doc-get-arg-type
.  ds doc-arg-type string
.
.  if ((\n[doc-width] < 3) & \A'\$1') \{\
.    ie (\n[doc-width] == 1) \{\
.      if d doc-punct\$1 \{\
.        ie "\*[doc-punct\$1]"punct-suffix" \
.          ds doc-arg-type punct-suffix
.        el \{\
.          if "\*[doc-punct\$1]"punct-prefix" \
.            ds doc-arg-type punct-prefix
.    \}\}\}
.    el \{\
.      if r \$1 \
.        if \n[\$1] \
.          ds doc-arg-type macro
.  \}\}
..
.
.
.\" NS doc-get-arg-type* macro
.\" NS   same as `.doc-get-arg-type' but uses doc-argXXX strings
.\" NS
.\" NS modifies:
.\" NS
.\" NS   doc-arg-type
.
.de doc-get-arg-type*
.  ds doc-arg-type string
.  doc-get-arg-width \$1
.
.  if ((\n[doc-width] < 3) & \A'\*[doc-arg\$1]') \{\
.    ie (\n[doc-width] == 1) \{\
.      if d doc-punct\*[doc-arg\$1] \{\
.        ie "\*[doc-punct\*[doc-arg\$1]]"punct-suffix" \
.          ds doc-arg-type punct-suffix
.        el \{\
.          if "\*[doc-punct\*[doc-arg\$1]]"punct-prefix"
.            ds doc-arg-type punct-prefix
.    \}\}\}
.    el \{\
.      if r \*[doc-arg\$1] \
.        if \n[\*[doc-arg\$1]] \
.          ds doc-arg-type macro
.  \}\}
..
.
.
.\" NS doc-set-spacing-for-macro macro
.\" NS   set spacing for macros
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dssfm, doc-reg-dssfm1
.
.de doc-set-spacing-for-macro
.  nr doc-reg-dssfm1 \n[\*[doc-arg\n[doc-args-processed]]]
.
.  \" closing macros like .Ac, Bc., etc. have value 3 (remove space before
.  \" argument)
.  ie (\n[doc-reg-dssfm1] == 3) \{\
.    nr doc-reg-dssfm (\n[doc-args-processed] - 1)
.    ds doc-space\n[doc-reg-dssfm]
.    ds doc-space\n[doc-args-processed] "\*[doc-space]
.  \}
.  el \{\
.    \" macros like .Ap and .Ns have value 2 (remove space before and after
.    \" argument)
.    ie (\n[doc-reg-dssfm1] == 2) \{\
.      nr doc-reg-dssfm (\n[doc-args-processed] - 1)
.      ds doc-space\n[doc-reg-dssfm]
.      ds doc-space\n[doc-args-processed]
.    \}
.    el \
.      ds doc-space\n[doc-args-processed]
.  \}
..
.
.
.\" NS doc-set-spacing-for-string macro
.\" NS   set spacing for strings
.
.de doc-set-spacing-for-string
.  ds doc-space\n[doc-args-processed] "\*[doc-space]
..
.
.
.\" NS doc-set-spacing-for-punct-suffix macro
.\" NS   set spacing for punctuation suffixes
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dssfps
.
.de doc-set-spacing-for-punct-suffix
.  if (\n[doc-args-processed] > 1) \{\
.    nr doc-reg-dssfps (\n[doc-args-processed] - 1)
.    ds doc-space\n[doc-reg-dssfps]
.  \}
.
.  ds doc-space\n[doc-args-processed] "\*[doc-space]
..
.
.
.\" NS doc-set-spacing-for-punct-prefix macro
.\" NS   set spacing for punctuation prefixes
.
.de doc-set-spacing-for-punct-prefix
.  ds doc-space\n[doc-args-processed]
..
.
.
.\" type switches (on current argument doc-arg-ptr)
.
.
.\" NS doc-do-macro macro
.\" NS   call request if macro
.
.de doc-do-macro
.  \*[doc-arg\n[doc-arg-ptr]]
..
.
.
.\" NS doc-do-string macro
.\" NS   call .No if string
.
.de doc-do-string
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-punct-suffix macro
.\" NS   call .No if punctuation suffix
.
.de doc-do-punct-suffix
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-punct-prefix macro
.\" NS   call .No if punctuation prefix
.
.de doc-do-punct-prefix
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-xref-macro macro
.\" NS   ignore if macro
.
.de doc-do-xref-macro
..
.
.
.\" NS doc-do-xref-string macro
.\" NS   ignore if string
.
.de doc-do-xref-string
..
.
.
.\" NS doc-do-xref-punct-suffix macro
.\" NS   append if punctuation suffix
.
.de doc-do-xref-punct-suffix
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.  nr doc-arg-ptr +1
.  \" XXX ?
.  n\\C\\n(aP
..
.
.
.\" NS doc-do-xref-punct-prefix macro
.\" NS   append if punctuation prefix
.
.de doc-do-xref-punct-prefix
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.  nr doc-arg-ptr +1
.  \" XXX ?
.  n\\C\\n(aP
..
.
.
.\" NS Bf user macro
.\" NS   begin font mode (will be begin-mode/end-mode in groff & TeX)
.\" NS
.\" NS width register `.Bf' set in doc-common
.
.de Bf
.  ds doc-macro-name Bf
.
.  ie \n[.$] \{\
.    nr doc-curr-font-for-Ef \n[.f]
.    nr doc-curr-size-for-Ef \n[.s]
.
.    ie "\$1"Em" \
.      nop \*[doc-Em-font]\c
.    el \{\
.      ie "\$1"Li" \
.        nop \*[doc-Li-font]\c
.      el \{\
.        ie "\$1"Sy" \
.          nop \*[doc-Sy-font]\c
.        el \{\
.          ie "\$1"-emphasis" \
.            nop \*[doc-Em-font]\c
.          el \{\
.            ie "\$1"-literal" \
.              nop \*[doc-Li-font]\c
.            el \{\
.              ie "\$1"-symbolic" \
.                nop \*[doc-Sy-font]\c
.              el \{\
.                tmc mdoc warning: Unknown keyword `\$1' in .Bf request
.                tm1 " (#\n[.c])
.  \}\}\}\}\}\}\}
.  el \
.    tm Usage .Bf [Em | -emphasis | Li | -literal | Sy | -symbolic] (#\n[.c])
..
.
.
.\" NS Ef user macro
.\" NS   end font mode
.\" NS
.\" NS width register `.Ef' set in doc-common
.
.de Ef
.  ds doc-macro-name Ef
.
.  ie \n[.$] \
.    tm Usage .Ef (does not take arguments) (#\n[.c])
.  el \
.    nop \&\f[\n[doc-curr-font-for-Ef]]\s[\n[doc-curr-size-for-Ef]]
..
.
.
.\" NS Bk user macro
.\" NS   begin keep
.\" NS
.\" NS width register `.Bk' set in doc-common
.
.de Bk
.  ds doc-keep-type
.
.  ds doc-macro-name Bk
.
.  ie \n[.$] \{\
.    if !"\*[doc-keep-type]"" \
.      tm .Bk: nesting keeps not implemented yet. (#\n[.c])
.    ie "\$1"-lines" \
.      tm .Bk -lines: Not implemented yet. (#\n[.c])
.    el \{\
.      ie "\$1"-words" \
.        doc-set-hard-space
.      el \
.        tm mdoc warning: Unknown keyword `\$1' in .Bk request (#\n[.c])
.    \}
.
.    ds doc-keep-type \$1
.  \}
.  el \
.    tm Usage: .Bk [-lines | -words] (#\n[.c])
..
.
.
.\" NS Ek user macro
.\" NS   end keep
.\" NS
.\" NS width register `.Ek' set in doc-common
.
.de Ek
.  ds doc-macro-name Ek
.
.  ie \n[.$] \
.    tm Usage .Ek (does not take arguments) (#\n[.c])
.  el \{\
.    ie "\*[doc-keep-type]"-words" \
.      doc-set-soft-space
.    el \
.      tm .Bk -lines: Not implemented yet. (#\n[.c])
.  \}
..
.
.
.\" NS Bd user macro
.\" NS   begin display
.\" NS
.\" NS width register `.Bd' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Bd
.
.nr doc-display-depth 0
.
.de Bd
.  ds doc-macro-name Bd
.
.  ie \n[.$] \{\
.    nr doc-is-compact 0
.    nr doc-reg-Bd 0
.    nr doc-display-depth +1
.
.    if "\$1"-literal" \{\
.      nr doc-reg-Bd 1
.      ds doc-display-type-stack\n[doc-display-depth] literal
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.
.      ie t \{\
.        nop \*[doc-Li-font]\c
'        ta T 9n
.      \}
.      el \
'        ta T 8n
.      nf
.    \}
.
.    if "\$1"-filled" \{\
.      nr doc-reg-Bd 1
.      ds doc-display-type-stack\n[doc-display-depth] filled
.      br
.    \}
.
.    if "\$1"-ragged" \{\
.      nr doc-reg-Bd 1
.      ds doc-display-type-stack\n[doc-display-depth] ragged
.      na
.    \}
.
.    if "\$1"-unfilled" \{\
.      nr doc-reg-Bd 1
.      ds doc-display-type-stack\n[doc-display-depth] unfilled
.      nf
.    \}
.
.    \" have we seen an argument?
.    if \n[doc-reg-Bd] \{\
.      shift
.      if \n[.$] \
.        doc-do-Bd-args \$@
.    \}
.
.    \" avoid warning about non-existent register
.    if !r doc-indent-stack\n[doc-display-depth] \
.      nr doc-indent-stack\n[doc-display-depth] 0
.
.    if \n[doc-indent-stack\n[doc-display-depth]] \
'      in (\n[.i]u + \n[doc-indent-stack\n[doc-display-depth]]u)
.
.    if !\n[doc-is-compact] \{\
.      if !\n[doc-in-synopsis-section] \{\
.        ie "\*[doc-display-type-stack\n[doc-display-depth]]"ragged" \
.          sp \n[doc-display-vertical]u
.        el \
'          sp \n[doc-display-vertical]u
.    \}\}
.
.    if !\n[cR] \
.      ne 2v
.
.    nr doc-is-compact 0
.  \}
.  el \{\
.    tm1 "Usage: .Bd [-literal | -filled | -ragged | -unfilled]
.    tm1 "           [-offset [string]] [-compact] (#\n[.c])
.  \}
..
.
.
.\" NS doc-do-Bd-args macro
.\" NS   resolve remaining .Bd arguments
.\" NS
.\" NS local variables:
.\" NS   doc-str-ddBa, doc-reg-ddBa
.
.de doc-do-Bd-args
.  nr doc-reg-ddBa 1
.  ds doc-str-ddBa
.
.  if "\$1"-offset" \{\
.    ds doc-str-ddBa "\$2
.
.    if "\$2"left" \{\
.      nr doc-reg-ddBa 2
.      nr doc-indent-stack\n[doc-display-depth] 0
.    \}
.
.    if "\$2"right" \{\
.      nr doc-reg-ddBa 2
.      nr doc-indent-stack\n[doc-display-depth] (\n[.l]u / 3u)
.    \}
.
.    if "\$2"center" \{\
.      nr doc-reg-ddBa 2
.      nr doc-indent-stack\n[doc-display-depth] ((\n[.l]u - \n[.i]u) / 4u)
.    \}
.
.    if "\$2"indent" \{\
.      nr doc-reg-ddBa 2
.      nr doc-indent-stack\n[doc-display-depth] \n[doc-display-indent]u
.    \}
.
.    if "\$2"indent-two" \{\
.      nr doc-reg-ddBa 2
.      nr doc-indent-stack\n[doc-display-depth] (\n[doc-display-indent]u + \n[doc-display-indent]u)
.    \}
.
.    \" not a known keyword
.    if (\n[doc-reg-ddBa] == 1) \{\
.      nr doc-reg-ddBa 2
.      doc-get-width "\$2"
.      \" if the offset parameter has the form `XXn', 10 <= XX < 100, take
.      \" this parameter as the offset value; otherwise, use the width of the
.      \" parameter
.      ie (\n[doc-width] > 2) \{\
.        ie ((\$2 > 9n) & (\$2 < 100n)) \
.          nr doc-indent-stack\n[doc-display-depth] \$2
.        el \
.          nr doc-indent-stack\n[doc-display-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.      \}
.      el \{\
.        \" if the offset parameter is a (two-letter) macro, use the macro's
.        \" width as specified in doc-comon; otherwise, use the parameter
.        \" numerically
.        if (\n[doc-width] == 2) \
.          doc-get-arg-type "\$2"
.        ie "\*[doc-arg-type]"macro" \
.          nr doc-indent-stack\n[doc-display-depth] \n[\$2]
.        el \
.          nr doc-indent-stack\n[doc-display-depth] \$2
.    \}\}
.  \}
.
.  if "\$1"-compact" \
.    nr doc-is-compact 1
.
.  if (\n[doc-reg-ddBa] < \n[.$]) \{\
.    \" have we seen `-offset' or `-compact'?
.    ie "\*[doc-str-ddBa]"" \{\
.      shift
.      doc-do-Bd-args \$@
.    \}
.    el \{\
.      shift 2
.      doc-do-Bd-args \$@
.  \}\}
..
.
.
.\" NS Ed user macro
.\" NS   end display
.\" NS
.\" NS width register `.Ed' set in doc-common
.
.de Ed
.  ds doc-macro-name Ed
.
.  br
.
.  if !\n[doc-display-depth] \
.    tm mdoc warning: Extraneous .Ed (#\n[.c])
.
.  if "\*[doc-display-type-stack\n[doc-display-depth]]"literal" \{\
.    ft \n[doc-curr-font]
.    ps \n[doc-curr-size]
.  \}
.
.  in (\n[.i]u - \n[doc-indent-stack\n[doc-display-depth]]u)
.
.  nr doc-indent-stack\n[doc-display-depth] 0
.  ds doc-display-type-stack\n[doc-display-depth]
.  nr doc-display-depth -1
.
.  fi
.  if t \
.    ad
..
.
.
.\" NS Bl user macro
.\" NS   begin list
.\" NS
.\" NS width register `.Bl' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Bl
.
.de Bl
.  ie \n[.$] \{\
.    ds doc-macro-name Bl
.    nr doc-list-depth +1
.    nr doc-arg-ptr 1
.
.    ie "\$1"-hang" \{\
.      ds doc-list-stack\n[doc-list-depth] hang-list
.      nr doc-list-indent-stack\n[doc-list-depth] 6n
.      nr doc-have-indent 1
.    \}
.    el \{\
.      ie "\$1"-tag" \{\
.        ds doc-list-stack\n[doc-list-depth] tag-list
.        nr doc-have-indent 1
.      \}
.      el \{\
.        ie "\$1"-item" \{\
.          ds doc-list-stack\n[doc-list-depth] item-list
.          nr doc-have-indent 1
.        \}
.        el \{\
.          ie "\$1"-enum" \{\
.            ds doc-list-stack\n[doc-list-depth] enum-list
.            nr doc-list-indent-stack\n[doc-list-depth] 3n
.            nr doc-have-indent 1
.          \}
.          el \{\
.            ie "\$1"-bullet" \{\
.              ds doc-list-stack\n[doc-list-depth] bullet-list
.              nr doc-list-indent-stack\n[doc-list-depth] 2n
.              nr doc-have-indent 1
.            \}
.            el \{\
.              ie "\$1"-dash" \{\
.                ds doc-list-stack\n[doc-list-depth] dash-list
.                nr doc-list-indent-stack\n[doc-list-depth] 2n
.                nr doc-have-indent 1
.              \}
.              el \{\
.                ie "\$1"-hyphen" \{\
.                  ds doc-list-stack\n[doc-list-depth] dash-list
.                  nr doc-list-indent-stack\n[doc-list-depth] 2n
.                  nr doc-have-indent 1
.                \}
.                el \{\
.                  ie "\$1"-inset" \{\
.                    ds doc-list-stack\n[doc-list-depth] inset-list
.                    nr doc-have-indent 1
.                  \}
.                  el \{\
.                    ie "\$1"-diag" \{\
.                      ds doc-list-stack\n[doc-list-depth] diag-list
.                      nr doc-have-diag-list 1
.                    \}
.                    el \{\
.                      ie "\$1"-ohang" \{\
.                        ds doc-list-stack\n[doc-list-depth] ohang-list
.                        nr doc-have-indent 1
.                      \}
.                      el \{\
.                        ie "\$1"-column" \
.                          ds doc-list-stack\n[doc-list-depth] column-list
.                        el \{\
.                          tmc "mdoc warning:
.                          tmc " Unknown list type `\$1' in .Bl request
.                          tm
.                          nr doc-arg-ptr 0
.    \}\}\}\}\}\}\}\}\}\}\}
.
.    \" we have seen a list type
.    ie \n[doc-arg-ptr] \{\
.      shift
.
.      \" fill argument vector
.      nr doc-reg-Bl 1
.      while (\n[doc-reg-Bl] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Bl] "\$[\n[doc-reg-Bl]]
.        nr doc-reg-Bl +1
.      \}
.
.      doc-increment-list-stack
.
.      if \n[.$] \{\
.        nr doc-num-args \n[.$]
.        nr doc-arg-ptr 0
.        doc-do-Bl-args
.
.        \" initialize column list
.        if "\*[doc-list-stack\n[doc-list-depth]]"column-list" \{\
.          doc-set-column-tab\n[doc-num-columns]
.          nr doc-list-indent-stack\n[doc-list-depth] 0
'          in -\n[doc-column-indent-width]u
.          if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.            sp \n[doc-display-vertical]u
.
.          nf
.          nr doc-num-columns 0
.    \}\}\}
.    el \{\
.      tm1 "Usage: .Bl [[-hang | -tag] [-width]]
.      tm1 "           [ -item | -enum | -bullet | -diag] (#\n[.c])
.    \}
.
.    doc-reset-args
.  \}
.  el \{\
.    tm1 "Usage: .Bl [[-hang | -tag] [-width]]
.    tm1 "           [ -item | -enum | -bullet | -diag] (#\n[.c])
.  \}
..
.
.
.ec
.
.nr i 10
.while (\n[i] < 100) \{\
.  nr doc-width-\n[i]n 1
.  nr i +1
.\}
.
.eo
.
.
.\" NS doc-do-Bl-args macro
.\" NS   resolve remaining .Bl arguments
.\" NS
.\" NS local variable:
.\" NS   doc-str-dBla, doc-reg-dBla
.
.de doc-do-Bl-args
.  nr doc-arg-ptr +1
.  if (\n[doc-num-args] >= \n[doc-arg-ptr]) \{\
.    nr doc-reg-dBla 0
.
.    if "\*[doc-arg\n[doc-arg-ptr]]"-compact" \{\
.      nr doc-reg-dBla 1
.      nr doc-compact-list-stack\n[doc-list-depth] 1
.    \}
.
.    if "\*[doc-arg\n[doc-arg-ptr]]"-width" \{\
.      nr doc-reg-dBla 1
.      nr doc-arg-ptr +1
.      nr have-tag-width 1
.      ds doc-tag-width-stack\n[doc-list-depth] TagwidtH
.      ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
.
.      doc-get-arg-width \n[doc-arg-ptr]
.      ie (\n[doc-width] > 2) \{\
.        nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.        if (\n[doc-width] == 3) \
.          if \A'\*[doc-str-dBla]' \
.            if r doc-width-\*[doc-str-dBla] \
.              nr doc-list-indent-stack\n[doc-list-depth] \*[doc-str-dBla]
.      \}
.      el \{\
.        doc-get-arg-type \*[doc-str-dBla]
.        ie "\*[doc-arg-type]"macro" \
.          nr doc-list-indent-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
.        el \
.          nr doc-list-indent-stack\n[doc-list-depth] \*[doc-str-dBla]u
.    \}\}
.
.    if "\*[doc-arg\n[doc-arg-ptr]]"-offset" \{\
.      nr doc-reg-dBla 1
.      nr doc-arg-ptr +1
.
.      ie "\*[doc-arg\n[doc-arg-ptr]]"indent" \
.        nr doc-list-offset-stack\n[doc-list-depth] \n[doc-display-indent]u
.      el \{\
.        ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
.
.        doc-get-arg-width \n[doc-arg-ptr]
.        ie (\n[doc-width] > 2) \{\
.          nr doc-list-offset-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.          if \A'\*[doc-str-dBla]' \
.            if r doc-width-\*[doc-str-dBla] \
.              nr doc-list-offset-stack\n[doc-list-depth] \*[doc-str-dBla]
.        \}
.        el \{\
.          doc-get-arg-type \*[doc-str-dBla]
.          ie "\*[doc-arg-type]"macro" \
.            nr doc-list-offset-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
.          el \
.            nr doc-list-offset-stack\n[doc-list-depth] \*[doc-str-dBla]
.    \}\}\}
.
.    \" not a known keyword, so it specifies the width of the next column
.    \" (if it is a column list)
.    if !\n[doc-reg-dBla] \{\
.      ie "\*[doc-list-stack\n[doc-list-depth]]"column-list" \{\
.        nr doc-num-columns +1
.        ds doc-arg\n[doc-num-columns] "\*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        tmc mdoc warning: Unknown keyword `\*[doc-arg\n[doc-arg-ptr]]'
.        tm1 " in .Bl request (#\n[.c])
.    \}\}
.
.    if (\n[doc-num-args] > \n[doc-arg-ptr]) \
.      doc-do-Bl-args
.  \}
..
.
.
.\" NS El user macro
.\" NS   end list
.\" NS
.\" NS width register `.El' set in doc-common
.\" NS
.\" NS local variables:
.\" NS   doc-str-El, doc-reg-El
.
.de El
.  ie \n[.$] \
.    tm Usage: .El (#\n[.c])
.  el \{\
.    ds doc-macro-name El
.    nr doc-reg-El 0
.    ds doc-str-El \*[doc-list-stack\n[doc-list-depth]]
.
.    if "\*[doc-str-El]"column-list" \{\
.      nr doc-reg-El 1
.      doc-do-end-column-list
.    \}
.
.    if "\*[doc-str-El]"enum-list" \
.      nr doc-enum-list-count 0
.
.    if \n[doc-have-diag-list] \{\
.      nr doc-reg-El 1
.      nr doc-have-diag-list 0
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.    \}
.
.    if "\*[doc-str-El]"item-list" \{\
'      in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u)
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.      nr doc-reg-El 1
.    \}
.
.    if "\*[doc-str-El]"ohang-list" \{\
'      in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u)
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.      nr doc-reg-El 1
.    \}
.
.    if "\*[doc-str-El]"inset-list" \{\
'      in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u)
.      doc-decrement-list-stack
.      nr doc-list-depth -1
.      doc-increment-list-stack
.      nr doc-reg-El 1
.    \}
.
.    if !\n[doc-reg-El] \
.      doc-end-list
.
.    br
.  \}
..
.
.
.\" NS doc-save-Pa-font string
.\" NS   save doc-Pa-font font string for section FILES (no underline if
.\" NS   nroff)
.
.
.\" NS It user macro
.\" NS   list item
.\" NS
.\" NS width register `.It' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-str-It, doc-reg-It
.
.de It
.  ds doc-str-It \*[doc-list-stack\n[doc-list-depth]]
.
.  if "\*[doc-str-It]"" \{\
.    tm mdoc error: .It without preceding .Bl
.    tmc Usage .It -list-type [-width [string] | -compact | -offset [string]]
.    tm1 " (#\n[.c])
.    tm .It \$@
.  \}
.
.  \" .tmc Here is
.  \" .tm1 " doc-list-stack[\n[doc-list-depth]]==\*[doc-str-It]
.
.  br
.  if !\n[cR] \
.    ne 3v
.
.  ie \n[.$] \{\
.    ds doc-macro-name It
.    ds doc-out-string
.
.    nr doc-reg-It 1
.    while (\n[doc-reg-It] <= \n[.$]) \{\
.      ds doc-arg\n[doc-reg-It] "\$[\n[doc-reg-It]]
.      nr doc-reg-It +1
.    \}
.
.    nr doc-reg-It 0
.    nr doc-num-args \n[.$]
.
.    if "\*[doc-str-It]"diag-list" \{\
.      nr doc-reg-It 1
.      nr doc-arg-ptr 0
.      doc-remaining-args
.      doc-diag-list
.    \}
.
.    if "\*[doc-str-It]"column-list" \{\
.      ds doc-out-string
.      nr doc-arg-ptr 0
.      nr doc-reg-It 1
.      doc-column-list
.    \}
.
.    if "\*[doc-str-It]"item-list" \{\
.      nr doc-arg-ptr 0
.      nr doc-reg-It 1
.      doc-item-list
.    \}
.
.    if !\n[doc-reg-It] \{\
.      doc-parse-arg-vector
.
.      \" tm1 "It list-type==\*[doc-str-It]
.      \" tm1 "   doc-arg-ptr==\n[doc-arg-ptr]
.      \" tm1 "   beg arg(doc-arg[1])==\*[doc-arg1]
.      \" tm1 "   doc-nesting-level==\n[doc-nesting-level]
.      \" tm1 "   doc-in-diversion==\n[doc-in-diversion]
.      \" tm1 "   doc-saved-list-immediate==\n[doc-saved-list-immediate]
.      \" tm1 "   doc-args-processed==\n[doc-args-processed]
.
.      nr doc-nesting-level +1
.      nr doc-list-immediate 1
.      nr doc-arg-ptr +1
.      ds doc-curr-type \*[doc-type\n[doc-arg-ptr]]
.      ds doc-curr-arg "\*[doc-arg\n[doc-arg-ptr]]
.
.      if \n[doc-in-files-section] \{\
.        ds doc-save-Pa-font "\*[doc-Pa-font]
.        if n \
.          ds doc-Pa-font "\*[doc-No-font]
.      \}
.
.      ie "\*[doc-type\n[doc-arg-ptr]]"macro" \
.        \*[doc-arg\n[doc-arg-ptr]]
.      el \{\
.        nr doc-arg-ptr -1
.        No
.      \}
.
.      \" tm1 "in It here is doc-out-string==\*[doc-out-string]
.      \" tm1 "   arg(doc-arg[1])==\*[doc-arg1]
.      \" tm1 "   doc-nesting-level==\n[doc-nesting-level]
.      \" tm1 "   doc-in-diversion==\n[doc-in-diversion]
.      \" tm1 "   doc-saved-list-immediate==\n[doc-saved-list-immediate]
.      \" tm1 "   doc-args-processed==\n[doc-args-processed]
.
.      ie \n[doc-saved-list-immediate] \
.        ds doc-saved-list-type "\*[doc-str-It]
.      el \
.        doc-\*[doc-str-It]
.  \}\}
.  el \
.    doc-\*[doc-str-It]
..
.
.
.\" NS doc-inset-list macro
.\" NS   .It item of list-type inset
.
.de doc-inset-list
.  doc-set-vertical-and-indent
.  br
.  nop \&\*[doc-out-string]
.
.  nr doc-nesting-level -1
.  nr doc-list-immediate 0
.  ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-hang-list macro
.\" NS   .It item of list-type hanging tag (as opposed to tagged)
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dhl
.
.de doc-hang-list
.  doc-set-vertical-and-indent-and-offset
.  nr doc-reg-dhl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-dhl]u
.
.  ie (\w\*[doc-out-string]u >= \n[doc-list-indent-stack\n[doc-list-depth]]u) \
.    nop \&\*[doc-out-string]
.  el \
.    nop \&\*[doc-out-string]\h'|\n[doc-reg-dhl]u'\c
.
.  nr doc-nesting-level -1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-ohang-list macro
.\" NS   .It item of list-type overhanging tag
.
.de doc-ohang-list
.  doc-set-vertical-and-indent
.  nop \&\*[doc-out-string]
.  br
.
.  nr doc-nesting-level -1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-item-list macro
.\" NS   .It item of list-type [empty tag]
.
.de doc-item-list
.  doc-set-vertical-and-indent
.  br
.
.  \" .ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-enum-list-count register
.\" NS   contains current enum count value
.
.nr doc-enum-list-count 0
.
.
.\" NS doc-enum-list macro
.\" NS   enumerated list
.
.de doc-enum-list
.  nr doc-nesting-level +1
.  nr doc-enum-list-count +1
.  ds doc-out-string "\n[doc-enum-list-count].
.  doc-do-list
..
.
.
.\" NS doc-bullet-list macro
.\" NS   bullet paragraph list
.
.de doc-bullet-list
.  nr doc-nesting-level +1
.  ds doc-out-string "\*[doc-Sy-font]\[bu]\f[P]
.  doc-do-list
..
.
.
.\" NS doc-dash-list macro
.\" NS   hyphen paragraph list (sub bullet list)
.
.de doc-dash-list
.  nr doc-nesting-level +1
.  ds doc-out-string "\*[doc-Sy-font]\-\f[P]
.  doc-do-list
..
.
.
.\" NS doc-do-list macro
.\" NS   .It item of list-type enum/bullet/hyphen
.\" NS
.\" NS local variable:
.\" NS   doc-reg-ddl
.
.de doc-do-list
.  doc-set-vertical-and-indent-and-offset
.  nr doc-reg-ddl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-ddl]u
.
.  ie (\w\*[doc-out-string]u >= \n[doc-list-indent-stack\n[doc-list-depth]]u) \
.    nop \&\*[doc-out-string]
.  el \
.    nop \&\*[doc-out-string]\h'|\n[doc-reg-ddl]u'\c
.
.  nr doc-nesting-level -1
.  \" .nr doc-in-diversion 1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-diag-list macro
.\" NS   .It item of list-type diagnostic-message
.
.nr doc-have-diag-list 0
.nr doc-diag-list-input-line-count 0
.
.de doc-diag-list
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  ie \n[doc-have-diag-list] \{\
.    ie ((\n[.c] - \n[doc-diag-list-input-line-count]) > 1) \
.      doc-paragraph
.    el \
.      br
.  \}
.  el \
.    br
.  nr doc-diag-list-input-line-count \n[.c]
.
.  nop \*[doc-Sy-font]\*[doc-out-string]\c
.  nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\*[doc-digit-string]\c
.
.  doc-reset-args
.  ds doc-out-string
'  fi
..
.
.
.\" NS doc-tag-list macro
.\" NS   .It item of list-type `tag'
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dtl
.
.de doc-tag-list
.  \" tm in doc-tag-list here is doc-out-string==\*[doc-out-string]
.  if !\n[have-tag-width] \
.    doc-get-tag-width
.  doc-set-vertical-and-indent-and-offset
.  nr doc-reg-dtl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-dtl]u
.
.  ie (\w\*[doc-out-string]u > \n[doc-list-indent-stack\n[doc-list-depth]]u) \{\
.    nop \&\*[doc-out-string]
.    br
.  \}
.  el \
.    nop \&\*[doc-out-string]\h'|\n[doc-reg-dtl]u'\c
.
.  if \n[doc-in-files-section] \
.    if n \
.      ds doc-Pa-font "\*[doc-save-Pa-font]
.
.  nr doc-nesting-level -1
.  nr doc-list-immediate 0
.  \" .nr doc-in-diversion 1
.  ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-get-tag-width macro
.\" NS   resolve unknown tag width (if .Bl [inset | tag] only)
.
.de doc-get-tag-width
.  if !"TagwidtH"\*[doc-tag-width-stack\n[doc-list-depth]]" \{\
.    ie "\*[doc-curr-type]"macro" \{\
.
.\" XXX what is `lN'?
.
.      ds doc-tag-width-stack\n[lN] \*[doc-curr-arg]
.      nr doc-list-indent-stack\n[lN] \n[\*[doc-curr-arg]]
.    \}
.    el \{\
.      ds doc-tag-width-stack\n[lN] No
.      nr doc-list-indent-stack\n[lN] \n[No]
.    \}
.    if !"\*[doc-tag-width-stack\n[doc-list-depth]]"\*[doc-tag-width-stack\n[lN]]" \
.      nr doc-have-indent 1
.  \}
..
.
.
.\" NS doc-set-vertical-and-indent-and-offset macro
.\" NS   set up vertical spacing (if compact) and indent (with offset)
.
.de doc-set-vertical-and-indent-and-offset
.  ie \n[doc-have-indent] \{\
.    nr doc-have-indent 0
.    nr have-tag-width 0
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.      sp \n[doc-display-vertical]u
.    in (\n[.i]u + \n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-list-offset-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  \}
.  el \{\
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.      sp \n[doc-display-vertical]u
.  \}
.
.  if !\n[cR] \
.    ne 2v
..
.
.
.\" NS doc-set-vertical-and-indent macro
.\" NS   set up vertical spacing (if compact) and indent (without offset)
.
.de doc-set-vertical-and-indent
.  ie \n[doc-have-indent] \{\
.    nr doc-have-indent 0
.    nr have-tag-width 0
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.      sp \n[doc-display-vertical]u
.    in (\n[.i]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
.  \}
.  el \{\
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.      sp \n[doc-display-vertical]u
.  \}
.
.  if !\n[cR] \
.    ne 2v
..
.
.
.\" NS doc-saved-list-immediate register (bool)
.\" NS   saved doc-list-immediate value
.
.nr doc-saved-list-immediate 0
.
.
.\" NS doc-list-depth register
.\" NS   list type stack counter
.
.nr doc-list-depth 0
.
.
.\" NS doc-list-immediate register (bool)
.\" NS   tag flag (for diversions)
.
.
.nr doc-num-columns 0
.nr doc-compact-list-stack1 0
.ds doc-tag-width-stack0
.ds doc-tag-width-stack1
.nr doc-list-offset-stack1 0
.
.
.\" NS doc-end-list macro
.\" NS   list end function
.
.de doc-end-list
.  \" .tm in doc-list-depth:
.  \" .tm1 "  doc-list-offset-stack[\n[doc-list-depth]]==\n[doc-list-offset-stack\n[doc-list-depth]]
.  \" .tm1 "  doc-list-indent-stack[\n[doc-list-depth]]==\n[doc-list-indent-stack\n[doc-list-depth]]
.
.  ie (\n[doc-list-offset-stack\n[doc-list-depth]] > 0) \{\
'    in (\n[.i]u - \n[doc-list-indent-stack\n[doc-list-depth]]u - \n[doc-list-offset-stack\n[doc-list-depth]]u - \n[doc-digit-width]u)
.    rr doc-list-offset-stack\n[doc-list-depth]
.  \}
.  el \
'    in (\n[.i]u - \n[doc-list-indent-stack\n[doc-list-depth]]u - \n[doc-digit-width]u)
.
.  if (\n[doc-list-depth] <= 0) \
.    tm mdoc warning: extraneous .El call (#\n[.c])
.
.  doc-decrement-list-stack
.  nr doc-list-depth -1
.  doc-increment-list-stack
..
.
.
.\" NS doc-next-list-depth register
.\" NS   next possible doc-list-depth value
.
.nr doc-next-list-depth 1
.
.
.\" NS doc-increment-list-stack macro
.\" NS   set up next block for list
.
.de doc-increment-list-stack
.  nr doc-next-list-depth (\n[doc-list-depth] + 1)
.  nr doc-list-indent-stack\n[doc-next-list-depth] 0
.  nr doc-list-offset-stack\n[doc-next-list-depth] 0
.  ds doc-tag-width-stack\n[doc-next-list-depth] \*[doc-tag-width-stack\n[doc-list-depth]]
.  ds doc-list-stack\n[doc-next-list-depth]
.  nr doc-compact-list-stack\n[doc-next-list-depth] 0
..
.
.
.\" NS doc-decrement-list-stack macro
.\" NS   decrement stack
.
.de doc-decrement-list-stack
.  ds doc-list-stack\n[doc-next-list-depth]
.  nr doc-list-indent-stack\n[doc-next-list-depth] 0
.  nr doc-list-offset-stack\n[doc-next-list-depth] 0
.  ds doc-tag-width-stack\n[doc-next-list-depth]
.  nr doc-compact-list-stack\n[doc-next-list-depth] 0
.  nr doc-next-list-depth -1
..
.
.
.\" NS Xr user macro
.\" NS   cross reference (man page only)
.\" NS
.\" NS width register `.Xr' set in doc-common
.
.de Xr
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .Xr manpage_name [section#] \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name Xr
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    ie "\*[doc-type\n[doc-arg-ptr]]"macro" \
.      tm Usage: .Xr manpage_name [section#] \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ie !"\*[doc-type\n[doc-arg-ptr]]"string" \
.        doc-do-xref-\*[doc-type\n[doc-arg-ptr]]
.      el \{\
.        as doc-out-string \*[doc-Xr-font]
.        as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.        nr doc-arg-ptr +1
.        if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.          if "\*[doc-type\n[doc-arg-ptr]]"string" \{\
.            as doc-out-string \&\*[lp]\*[doc-arg\n[doc-arg-ptr]]\*[rp]
.            nr doc-arg-ptr +1
.        \}\}
.        ie (\n[doc-args-processed] >= \n[doc-arg-ptr]) \
.          doc-do-\*[doc-type\n[doc-arg-ptr]]
.        el \
.          doc-print-and-reset
.  \}\}\}
..
.
.
.\" NS Sx user macro
.\" NS   cross section reference
.\" NS
.\" NS width register `.Sx' set in doc-common
.
.de Sx
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .Sx Section Header \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name Sx
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Sx-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}\}
..
.
.
.\" NS doc-do-end-column-list macro
.\" NS   column-list end-list
.
.de doc-do-end-column-list
'  in (\n[.i]u - \n[doc-list-offset-stack\n[doc-list-depth]]u - \n[doc-list-indent-stack\n[doc-list-depth]]u)
.  ta T .5i 1i
.  fi
.  doc-decrement-list-stack
.  nr doc-list-depth -1
.  doc-increment-list-stack
..
.
.
.\" NS doc-set-column-tab[1-6] macro
.\" NS   establish tabs for list-type column
.
.de doc-set-column-tab1
.  ta \w\*[doc-arg1]    u
.  nr doc-column-indent-width \w\*[doc-arg1]    u
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab2
.  ta \w\*[doc-arg1]    u +\w\*[doc-arg2]    u
.  nr doc-column-indent-width (\w\*[doc-arg1]    u + \w\*[doc-arg2]    u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab3
.  ta \w\*[doc-arg1]    u +\w\*[doc-arg2]    u +\w\*[doc-arg3]    u
.  nr doc-column-indent-width (\w\*[doc-arg1]    u + \w\*[doc-arg2]    u + \w\*[doc-arg3]    u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab4
.  ta \w\*[doc-arg1]    u +\w\*[doc-arg2]    u +\w\*[doc-arg3]    u +\w\*[doc-arg4]    u
.  nr doc-column-indent-width (\w\*[doc-arg1]    u + \w\*[doc-arg2]    u + \w\*[doc-arg3]    u + \w\*[doc-arg4]    u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.de doc-set-column-tab5
.  ta \w\*[doc-arg1]   u +\w\*[doc-arg2]   u +\w\*[doc-arg3]   u +\w\*[doc-arg4]   u +\w\*[doc-arg5]   u
.  nr doc-column-indent-width (\w\*[doc-arg1]   u + \w\*[doc-arg2]   u + \w\*[doc-arg3]   u + \w\*[doc-arg4]   u +\w\*[doc-arg5]   u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.\" This is packed abnormally close; intercol width should be an option
.de doc-set-column-tab6
.  ta \w\*[doc-arg1] u +\w\*[doc-arg2] u +\w\*[doc-arg3] u +\w\*[doc-arg4] u +\w\*[doc-arg5] u +\w\*[doc-arg6] u
.  nr doc-column-indent-width (\w\*[doc-arg1] u + \w\*[doc-arg2] u + \w\*[doc-arg3] u + \w\*[doc-arg4] u + \w\*[doc-arg5] u + \w\*[doc-arg6] u)
'  in (\n[.i]u + \n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.\" NS doc-column-list macro
.\" NS   column items
.\" NS
.\" NS local variable:
.\" NS   doc-reg-dcl
.
.de doc-column-list
.  if !\n[doc-list-indent-stack\n[doc-list-depth]] \
.    nr doc-list-indent-stack\n[doc-list-depth] \n[doc-column-indent-width]u
.  if !\n[.u] \{\
.    fi
'    in (\n[.i]u + \n[doc-column-indent-width]u)
.  \}
.  ti -\n[doc-column-indent-width]u
.
.  doc-parse-arg-vector
.  nr doc-arg-ptr +1
.
.  ie (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    if "\*[doc-arg\n[doc-arg-ptr]]"Ta" \{\
.      nr doc-reg-dcl (\n[doc-arg-ptr] - 1)
.      ds doc-space\n[doc-reg-dcl]
.    \}
.    doc-do-\*[doc-type\n[doc-arg-ptr]]
.  \}
.  el \
.    tm Usage: .It column_string [Ta [column_string ...] ] (#\n[.c])
..
.
.
.\" NS Ta user macro
.\" NS   append tab (\t)
.\" NS
.\" NS width register `.Ta' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Ta
.
.de Ta
.  ie \n[doc-args-processed] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.      if "\*[doc-arg\n[doc-arg-ptr]]"Ta" \{\
.        nr doc-reg-Ta (\n[doc-arg-ptr] - 1)
.        ds doc-space\n[doc-reg-Ta]
.      \}
.      as doc-out-string \t
.      doc-do-\*[doc-type\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \t\c
.      ds doc-space\n[doc-arg-ptr]
.      doc-print-out-string
.      doc-reset-args
.      \" .ds doc-out-string
.  \}\}
.  el \{\
.    tm1 "Usage: Ta must follow column entry: e.g. (#\n[.c])
.    tm1 "         .It column_string [Ta [column_string ...] ]
.  \}
..
.
.
.\" NS Dl user macro
.\" NS   display (one line) literal
.\" NS
.\" NS width register `.Dl' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Dl
.
.de Dl
'  ta T .5i
.  in (\n[.i]u + \n[doc-display-indent]u)
.
.  ie !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .Dl argument ... (#\n[.c])
.    el \{\
.      ds doc-macro-name Dl
.
.      nr doc-reg-Dl 1
.      while (\n[doc-reg-Dl] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Dl] "\$[\n[doc-reg-Dl]]
.        nr doc-reg-Dl +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.      Li
.  \}\}
.  el \
.    tm Usage: .Dl not callable by other macros (#\n[.c])
.
.  in (\n[.i]u - \n[doc-display-indent]u)
..
.
.
.\" NS D1 user macro
.\" NS   display (one line)
.\" NS
.\" NS width register `.D1' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-D1
.
.de D1
'  ta T .5i
.  in (\n[.i]u + \n[doc-display-indent]u)
.
.  ie !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .D1 argument ... (#\n[.c])
.    el \{\
.      ds doc-macro-name D1
.
.      nr doc-reg-D1 1
.      while (\n[doc-reg-D1] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-D1] "\$[\n[doc-reg-D1]]
.        nr doc-reg-D1 +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.      nr doc-arg-ptr +1
.      No
.  \}\}
.  el \
.    tm Usage: .D1 not callable by other macros (#\n[.c])
.
.  in (\n[.i]u - \n[doc-display-indent]u)
..
.
.
.\" NS Ex user macro
.\" NS   defunct
.
.de Ex
.  tm mdoc error: .Ex defunct, use .D1: \$@
..
.
.
.\" NS Vt user macro
.\" NS   variable type (for forcing old style variable declarations)
.\" NS   this is not done in the same manner as .Ot for fortrash --
.\" NS   clean up later
.\" NS
.\" NS width register `.Vt' set in doc-common
.
.de Vt
.  \" if a function declaration was the last thing given, want vertical space
.  if \n[doc-declaration-count] \{\
.    doc-paragraph
.    nr doc-declaration-count 0
.  \}
.
.  \" if a subroutine was the last thing given, want vertical space
.  if \n[doc-function-count] \{\
.    ie !\n[doc-variable-type] \{\
.      doc-paragraph
.      rs
.    \}
.    el \
.      br
.  \}
.
.  nr doc-variable-type +1
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.  nop \*[doc-Ft-font]\$*
.
.  ie !\n[doc-have-old-function] \
.    br
.  el \
.    nop \&\*[doc-soft-space]
.
.  ft \n[doc-curr-font]
.  fs \n[doc-curr-size]
..
.
.
.\" NS doc-is-func-type register (bool)
.\" NS   set if subroutine (in synopsis only) (fortran only)
.
.nr doc-is-func-type 0
.
.
.\" NS Ft user macro
.\" NS   function type
.\" NS
.\" NS width register `.Ft' set in doc-common
.
.de Ft
.  if \n[doc-in-synopsis-section] \{\
.    if \n[doc-function-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-declaration-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    nr doc-is-func-type 1
.  \}
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.  nop \*[doc-Ft-font]\$*
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
.  \" .br
..
.
.
.\" NS doc-have-old-function register
.
.nr doc-have-old-function 0
.
.
.\" NS Ot user macro
.\" NS   old function type (fortran - no newline)
.\" NS
.\" NS width register `.Ot' set in doc-common
.
.de Ot
.  nr doc-have-old-function 1
.
.  if \n[doc-in-synopsis-section] \{\
.    if \n[doc-function-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-declaration-count] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    nr doc-is-func-type 1
.  \}
.
.  if \n[.$] \
.    as doc-out-string \*[doc-Ft-font]\$*
.  as doc-out-string \ \f[P]
..
.
.
.\" NS Fa user macro
.\" NS   function arguments
.\" NS
.\" NS width register `.Fa' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Fa
.
.de Fa
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .Fa Function Arguments ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name Fa
.
.      nr doc-reg-Fa 1
.      while (\n[doc-reg-Fa] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Fa] "\$[\n[doc-reg-Fa]]
.        nr doc-reg-Fa +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  ie \n[doc-func-arg-count] \
.    doc-do-function
.  el \{\
.    nr doc-arg-ptr +1
.    if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.      as doc-out-string \*[doc-Fa-font]
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      doc-print-recursive
.
.      if \n[doc-in-synopsis-section] \
.        if \n[doc-function-count] \
.          br
.  \}\}
..
.
.
.\" NS doc-do-function macro
.\" NS   internal .Fa for .Fc
.
.nr doc-func-arg-count 0
.
.de doc-do-function
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    \" .if \n[doc-in-synopsis-section] \{\
.    ds doc-function-arg
.    nr doc-num-function-args 0
.    nr doc-function-args-processed 0
.    doc-insert-hard-space \*[doc-arg\n[doc-arg-ptr]]
.    if (\n[doc-num-function-args] > 1) \
.      rn doc-function-arg doc-arg\n[doc-arg-ptr]
.    \" .\}
.
.    if (\n[doc-func-arg-count] > 1) \{\
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\|,
.      as doc-out-string "\*[doc-space\n[doc-arg-ptr]]\*[doc-Fa-font]
.      as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    \}
.
.    if (\n[doc-func-arg-count] == 1) \{\
.      as doc-out-string \|\*[doc-Fa-font]\*[doc-arg\n[doc-arg-ptr]]
.      as doc-out-string \f[P]\s[0]
.    \}
.    nr doc-func-arg-count +1
.    doc-do-function
.  \}
.  el \
.    doc-reset-args
..
.
.
.\" NS doc-function-count register
.\" NS   break a line if more than one function in a synopsis
.
.nr doc-function-count 0
.
.
.\" NS Fn user macro
.\" NS   functions
.\" NS
.\" NS width register `.Fn' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Fn
.
.de Fn
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \{\
.      tmc Usage: .Fn function_name function_arg(s) ... \*[doc-punct-chars]
.      tm1 " (#\n[.c])
.    \}
.    el \{\
.      ds doc-macro-name Fn
.
.      nr doc-reg-Fn 1
.      while (\n[doc-reg-Fn] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Fn] "\$[\n[doc-reg-Fn]]
.        nr doc-reg-Fn +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  if \n[doc-in-synopsis-section] \{\
.    \" if there is/has been more than one subroutine declaration
.    ie !\n[doc-is-func-type] \{\
.      if \n[doc-function-count] \{\
.        doc-paragraph
.        nr doc-variable-type 0
.        nr doc-declaration-count 0
.    \}\}
.    el \{\
.      br
.      nr doc-variable-type 0
.      nr doc-declaration-count 0
.      nr doc-is-func-type 0
.    \}
.
.    if \n[doc-declaration-count] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.    \}
.
.    nr doc-function-count +1
.    nr doc-is-func-type 0
.    rs
.
.    ie (\n[doc-in-synopsis-section] > 1) \
.      br
.    el \{\
.      if !\n[doc-indent-synopsis] \
.        nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
.    \}
.
.    in +\n[doc-indent-synopsis]u
.    ti -\n[doc-indent-synopsis]u
.    nr doc-in-synopsis-section +1
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    as doc-out-string \*[doc-Fn-font]\*[doc-arg\n[doc-arg-ptr]]
.    as doc-out-string \f[P]\s[0]\*[lp]
.
.    nr doc-arg-ptr +1
.    ie (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.      as doc-out-string \*[doc-Fa-font]
.      doc-do-function-\*[doc-type\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \|\*[rp]
.      doc-print-and-reset
.    \}
.
.    if \n[doc-in-synopsis-section] \
.      in -\n[doc-indent-synopsis]u
.  \}
..
.
.
.\" NS doc-do-function-macro macro
.
.de doc-do-function-macro
.  ie \n[doc-in-synopsis-section] \{\
.    as doc-out-string \&\*[rp]\f[R];\f[P]
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.  \}
.  el \
.    as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.
.  \*[doc-arg\n[doc-arg-ptr]]
..
.
.
.\" NS doc-do-function-string macro
.\" NS   handle function arguments
.\" NS
.\" NS local variable:
.\" NS   doc-reg-ddfs
.
.de doc-do-function-string
.  if \n[doc-in-synopsis-section] \{\
.    ds doc-function-arg
.    nr doc-num-function-args 0
.    nr doc-function-args-processed 0
.    doc-insert-hard-space \*[doc-arg\n[doc-arg-ptr]]
.    if (\n[doc-num-function-args] > 1) \
.      rn doc-function-arg doc-arg\n[doc-arg-ptr]
.  \}
.
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-reg-ddfs \n[doc-arg-ptr]
.    nr doc-arg-ptr +1
.    if "\*[doc-type\n[doc-arg-ptr]]"string" \{\
.      as doc-out-string \|\f[\n[doc-curr-font]]\s[\n[doc-curr-size]],
.      as doc-out-string "\*[doc-space\n[doc-reg-ddfs]]\f[P]\s[0]\|
.    \}
.    doc-do-function-\*[doc-type\n[doc-arg-ptr]]
.  \}
.  el \{\
.    ie \n[doc-in-synopsis-section] \{\
.      as doc-out-string \&\*[rp]\f[R];\f[P]
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \}
.    el \
.      as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    doc-print-and-reset
.  \}
..
.
.
.\" NS doc-do-function-punct-suffix macro
.
.de doc-do-function-punct-suffix
.  ie \n[doc-in-synopsis-section] \{\
.    as doc-out-string \&\*[rp]\f[R];\f[P]
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]
.  \}
.
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \
.    No
.  el \
.    doc-print-and-reset
..
.
.
.\" NS doc-do-function-punct-prefix macro
.\" NS   write out function
.
.de doc-do-function-punct-prefix
.  ie \n[doc-in-synopsis-section] \{\
.    as doc-out-string \&\*[rp]\f[R];\f[P]
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-space\n[doc-arg-ptr]]\*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-space\n[doc-arg-ptr]]\*[doc-arg\n[doc-arg-ptr]]
.  \}
.
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    No
.  \}
.  el \
.    doc-print-and-reset
..
.
.
.\" NS Fo user macro
.\" NS   function open
.\" NS
.\" NS width register `.Fo' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Fo
.
.de Fo
.  hy 0
.
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) \
.      tm Usage: .Fo function_name (#\n[.c])
.    el \{\
.      ds doc-macro-name Fo
.
.      nr doc-reg-Fo 1
.      while (\n[doc-reg-Fo] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Fo] "\$[\n[doc-reg-Fo]]
.        nr doc-reg-Fo +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  if \n[doc-in-synopsis-section] \{\
.    \" if there is/has been more than one subroutine declaration
.    ie !\n[doc-is-func-type] \{\
.      if \n[doc-function-count] \{\
.        doc-paragraph
.        nr doc-variable-type 0
.        nr doc-declaration-count 0
.    \}\}
.    el \{\
.      br
.      nr doc-variable-type 0
.      nr doc-declaration-count 0
.      nr doc-is-func-type 0
.    \}
.
.    if \n[doc-declaration-count] \{\
.      doc-paragraph
.      nr doc-variable-type 0
.    \}
.
.    if \n[doc-variable-type] \{\
.      doc-paragraph
.      nr doc-declaration-count 0
.    \}
.
.    nr doc-function-count +1
.    nr doc-is-func-type 0
.    rs
.
.    ie (\n[doc-in-synopsis-section] > 1) \
.      br
.    el \{\
.      if !\n[doc-indent-synopsis] \
.        nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
.    \}
.
.    in +\n[doc-indent-synopsis]u
.    ti -\n[doc-indent-synopsis]u
.    nr doc-in-synopsis-section +1
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-nesting-level +1
.    nr doc-func-arg-count 1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    as doc-out-string \*[doc-Fn-font]\*[doc-arg\n[doc-arg-ptr]]
.    as doc-out-string \f[P]\s[0]\*[lp]
.    doc-reset-args
.  \}
..
.
.
.\" NS Fc user macro
.\" NS   function close
.\" NS
.\" NS width register `.Fc' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-Fc
.
.de Fc
.  if !\n[doc-args-processed] \{\
.    if \n[.$] \{\
.      ds doc-macro-name Fc
.
.      nr doc-reg-Fc 1
.      while (\n[doc-reg-Fc] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Fc] "\$[\n[doc-reg-Fc]]
.        nr doc-reg-Fc +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-func-arg-count 0
.  nr doc-nesting-level -1
.
.  ie \n[doc-in-synopsis-section] \
.    as doc-out-string \|\*[rp]\f[R];\f[P]
.  el \
.    as doc-out-string \|\*[rp]
.  ie (\n[doc-args-processed] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    \*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \
.    doc-print-and-reset
.
.  if \n[doc-in-synopsis-section] \
.    in -\n[doc-indent-synopsis]u
.
.  hy
..
.
.
.\" NS doc-insert-hard-space macro
.\" NS   set hard space inbetween function arguments
.
.de doc-insert-hard-space
.  \" .tm1 "doc-insert-hard-space:
.  \" .tm1 "  doc-num-function-args==\n[doc-num-function-args]
.  \" .tm1 "  doc-function-args-processed==\n[doc-function-args-processed]
.  \" .tm1 "  args==\$@
.
.  if !\n[doc-num-function-args] \{\
.    nr doc-num-function-args \n[.$]
.    nr doc-function-args-processed 0
.    ds doc-function-arg
.  \}
.
.  nr doc-function-args-processed +1
.  as doc-function-arg "\$1
.
.  if (\n[doc-function-args-processed] < \n[doc-num-function-args]) \{\
.    as doc-function-arg "\*[doc-hard-space]
.
.    shift
.    doc-insert-hard-space \$@
.  \}
..
.
.
.\" Very crude references, stash all reference info into strings (usual
.\" use of doc-out-string, then doc-out-string contents copied to
.\" string of retrievable naming convention), print out reference on .Re
.\" request and clean up.  Ordering very limited, no fancy citations, but
.\" can do articles, journals, and books -- need to add several missing
.\" options (like city etc).  Should be able to grab a refer entry, massage
.\" it a wee bit (prefix a `.' to the %[A-Z]) and not worry (ha!).
.
.
.\" NS Rs user macro
.\" NS   reference start
.\" NS
.\" NS width register `.Rs' set in doc-common
.
.de Rs
.  nr doc-is-reference 1
.  doc-reset-reference
.  if \n[doc-in-see-also-section] \
.    doc-paragraph
.  nr doc-reference-count 0
..
.
.
.\" NS Re user macro
.\" NS   reference end
.\" NS
.\" NS width register `.Re' set in doc-common
.
.de Re
.  doc-print-reference
.  doc-reset-reference
.  nr doc-is-reference 0
..
.
.
.\" NS doc-reset-reference macro
.\" NS   reference cleanup
.
.de doc-reset-reference
.  nr doc-author-count 0
.  nr doc-journal-count 0
.  nr doc-issue-count 0
.  nr doc-optional-count 0
.  nr doc-corporate-count 0
.  nr doc-report-count 0
.  nr doc-reference-title-count 0
.  nr doc-volume-count 0
.  nr doc-date-count 0
.  nr doc-page-number-count 0
.  nr doc-book-count 0
.  ds doc-reference-string-name
.  rm doc-journal-name doc-issue-name doc-optional-string doc-report-name doc-corporate-name doc-reference-title-name doc-volume-name doc-date-count doc-page-number-string doc-book-name
..
.
.
.\" NS doc-print-reference macro
.\" NS   reference print
.
.de doc-print-reference
.  if \n[doc-author-count] \{\
.    nop \&\*[doc-author-name1],
.    nr doc-authors-processed 1
.    if (\n[doc-author-count] > 1) \
.      doc-print-reference-authors
.    nr doc-reference-count -\n[doc-author-count]
.  \}
.
.  if \n[doc-reference-title-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \{\
.      ie ((\n[doc-journal-count] == 1) : (\n[doc-book-count] == 1)) \
.        nop \&\*[q]\*[doc-reference-title-name]\*[q].
.      el \
.        nop \*[doc-Em-font]\*[doc-reference-title-name]\*[doc-No-font].
.    \}
.    el \{\
.      ie ((\n[doc-journal-count] == 1) : (\n[doc-book-count] == 1)) \
.        nop \&\*[q]\*[doc-reference-title-name]\*[q],
.      el \
.        nop \*[doc-Em-font]\*[doc-reference-title-name]\*[doc-No-font],
.  \}\}
.
.  if \n[doc-book-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \*[doc-Em-font]\*[doc-book-name]\*[doc-No-font].
.    el \
.      nop \*[doc-Em-font]\*[doc-book-name]\*[doc-No-font],
.  \}
.
.  if \n[doc-publisher-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \*[doc-Em-font]\*[doc-publisher-name]\*[doc-No-font].
.    el \
.      nop \*[doc-Em-font]\*[doc-publisher-name]\*[doc-No-font],
.  \}
.
.  if \n[doc-journal-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \*[doc-Em-font]\*[doc-journal-name]\*[doc-No-font].
.    el \
.      nop \*[doc-Em-font]\*[doc-journal-name]\*[doc-No-font],
.  \}
.
.  if \n[doc-report-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-report-name].
.    el \
.      nop \&\*[doc-report-name],
.  \}
.
.  if \n[doc-issue-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-issue-name].
.    el \
.      nop \&\*[doc-issue-name],
.  \}
.
.  if \n[doc-volume-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-volume-name].
.    el \
.      nop \&\*[doc-volume-name],
.  \}
.
.  if \n[doc-page-number-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-page-number-string].
.    el \
.      nop \&\*[doc-page-number-string],
.  \}
.
.  if \n[doc-corporate-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-corporate-name].
.    el \
.      nop \&\*[doc-corporate-name],
.  \}
.
.  if \n[doc-date-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-date].
.    el \
.      nop \&\*[doc-date],
.  \}
.
.  if \n[doc-optional-count] \{\
.    nr doc-reference-count -1
.    ie !\n[doc-reference-count] \
.      nop \&\*[doc-optional-string].
.    el \
.      nop \&\*[doc-optional-string],
.  \}
.
.  if \n[doc-reference-count] \
.    tm mdoc warning: unresolved reference problem
..
.
.
.\" NS doc-print-reference-authors macro
.\" NS   print out reference authors
.
.de doc-print-reference-authors
.  nr doc-authors-processed +1
.  ie (\n[doc-author-count] == \n[doc-authors-processed]) \
.    nop \&and \*[doc-author-name\n[doc-authors-processed]],
.  el \{\
.    nop \&\*[doc-author-name\n[doc-authors-processed]],
.    doc-print-reference-authors
.  \}
..
.
.
.\" NS %A user macro
.\" NS   reference author(s)
.\" NS
.\" NS width register `.%A' set in doc-common
.
.de %A
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%A Author_name (#\n[.c])
.    el \{\
.      nr doc-author-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-author-name\n[doc-author-count]
.
.      ds doc-macro-name %A
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %B user macro
.\" NS   [reference] Book Name
.\" NS
.\" NS width register `.%B' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%B
.
.de %B
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%B Book Name (#\n[.c])
.    el \{\
.      if \n[doc-is-reference] \{\
.        nr doc-book-count +1
.        nr doc-reference-count +1
.        ds doc-reference-string-name doc-book-name
.      \}
.
.      ds doc-macro-name %B
.
.      nr doc-reg-%B 1
.      while (\n[doc-reg-%B] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%B] "\$[\n[doc-reg-%B]]
.        nr doc-reg-%B +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    ie !\n[doc-is-reference] \{\
.      as doc-out-string \*[doc-Em-font]
.      doc-print-recursive
.    \}
.    el \
.      doc-do-references
.  \}
..
.
.
.\" NS %D user macro
.\" NS   [reference] date
.\" NS
.\" NS width register `.%D' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%D
.
.de %D
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%D Date (#\n[.c])
.    el \{\
.      nr doc-date-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-date
.
.      ds doc-macro-name %D
.
.      nr doc-reg-%D 1
.      while (\n[doc-reg-%D] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%D] "\$[\n[doc-reg-%D]]
.        nr doc-reg-%D +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %I user macro
.\" NS   [reference] issuer/publisher name
.\" NS
.\" NS width register `.%I' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%I
.
.de %I
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%I Issuer/Publisher Name (#\n[.c])
.    el \{\
.      nr doc-publisher-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-publisher-name
.
.      ds doc-macro-name %I
.
.      nr doc-reg-%I 1
.      while (\n[doc-reg-%I] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%I] "\$[\n[doc-reg-%I]]
.        nr doc-reg-%I +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %J user macro
.\" NS   [reference] Journal Name
.\" NS
.\" NS width register `.%J' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%J
.
.de %J
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%J Journal Name (#\n[.c])
.    el \{\
.      ds doc-macro-name %J
.      nr doc-journal-count +1
.      ds doc-reference-string-name doc-journal-name
.      nr doc-reference-count +1
.
.      nr doc-reg-%J 1
.      while (\n[doc-reg-%J] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%J] "\$[\n[doc-reg-%J]]
.        nr doc-reg-%J +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %N user macro
.\" NS   [reference] issue number
.\" NS
.\" NS width register `.%N' set in doc-common
.
.de %N
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%N issue number (#\n[.c])
.    el \{\
.      nr doc-issue-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-issue-name
.
.      ds doc-macro-name %N
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %O user macro
.\" NS   [reference] optional information
.\" NS
.\" NS width register `.%O' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%O
.
.de %O
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%O optional information ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      nr doc-optional-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-optional-string
.
.      ds doc-macro-name %O
.
.      nr doc-reg-%O 1
.      while (\n[doc-reg-%O] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%O] "\$[\n[doc-reg-%O]]
.        nr doc-reg-%O +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %P user macro
.\" NS   [reference] page numbers
.\" NS
.\" NS width register `.%P' set in doc-common
.
.de %P
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%P page numbers ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      nr doc-page-number-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-page-number-string
.
.      ds doc-macro-name %P
.
.      nr doc-reg-%P 1
.      while (\n[doc-reg-%P] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%P] "\$[\n[doc-reg-%P]]
.        nr doc-reg-%P +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %Q user macro
.\" NS   corporate or foreign author
.\" NS
.\" NS width register `.%Q' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%Q
.
.de %Q
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%Q Corporate or Foreign Author (#\n[.c])
.    el \{\
.      nr doc-corporate-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-corporate-name
.
.      ds doc-macro-name %Q
.
.      nr doc-reg-%Q 1
.      while (\n[doc-reg-%Q] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%Q] "\$[\n[doc-reg-%Q]]
.        nr doc-reg-%Q +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %R user macro
.\" NS   [reference] report name
.\" NS
.\" NS width register `.%R' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%R
.
.de %R
.  if (\n[doc-args-processed] == 0) \{\
.    ie (\n[.$] == 0) \
.      tm Usage: .%R reference report (#\n[.c])
.    el \{\
.      nr doc-report-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-report-name
.
.      ds doc-macro-name %R
.
.      nr doc-reg-%R 1
.      while (\n[doc-reg-%R] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%R] "\$[\n[doc-reg-%R]]
.        nr doc-reg-%R +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS %T user macro
.\" NS   reference title
.\" NS
.\" NS width register `.%T' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-reg-%T
.
.de %T
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%T reference title (#\n[.c])
.    el \{\
.      if \n[doc-is-reference] \{\
.        nr doc-reference-title-count +1
.        nr doc-reference-count +1
.        ds doc-reference-string-name doc-reference-title-name
.      \}
.
.      ds doc-macro-name %T
.
.      nr doc-reg-%T 1
.      while (\n[doc-reg-%T] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-%T] "\$[\n[doc-reg-%T]]
.        nr doc-reg-%T +1
.      \}
.
.      nr doc-num-args \n[.$]
.      doc-parse-arg-vector
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    ie !\n[doc-is-reference] \{\
.      as doc-out-string \*[doc-Em-font]
.      doc-print-recursive
.    \}
.    el \
.      doc-do-references
.  \}
..
.
.
.\" NS %V user macro
.\" NS   reference volume
.\" NS
.\" NS width register `.%V' set in doc-common
.
.de %V
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .%V Volume , ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name %V
.      nr doc-volume-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-volume-name
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-do-references macro
.\" NS   reference recursion routine
.\" NS
.\" NS local variables:
.\" NS   doc-str-ddr, doc-reg-ddr
.
.de doc-do-references
.  hy 0
.
.  ds doc-str-ddr "\*[doc-type\n[doc-arg-ptr]]
.
.  ie "\*[doc-str-ddr]"macro" \{\
.    \" .as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    ie "\*[doc-arg\n[doc-arg-ptr]]"Tn" \
.      doc-reference-trademark
.    el \{\
.      doc-append-arg doc-do-references macro
.      \*[doc-arg\n[doc-arg-ptr]]
.  \}\}
.  el \{\
.    nr doc-reg-ddr \n[doc-arg-ptr]
.    ie "\*[doc-str-ddr]"string" \
.      as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    el \
.      as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \" .el \{\
.    \" .  as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \" .  as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.
.    ie (\n[doc-args-processed] == \n[doc-arg-ptr]) \{\
.      \" .as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as \*[doc-reference-string-name] \&\*[doc-out-string]
.      ds doc-out-string
.      ds doc-reference-string-name
.      doc-reset-args
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      as doc-out-string "\*[doc-space\n[doc-reg-ddr]]
.      doc-do-references
.  \}\}
..
.
.
.\" NS Hf user macro
.\" NS   source include header files.
.\" NS
.\" NS width register `.Hf' set in doc-common
.
.de Hf
.  doc-paragraph
.  nop File:
.  Pa \$1
.  doc-paragraph
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  ie t \{\
.    nop \*[doc-Li-font]
.    br
.    ta T 9n
.  \}
.  el \
.    ta T 8n
.
.  nf
.  so \$1
.  fi
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
.  doc-paragraph
..
.
.
.\" NS doc-have-author register
.
.nr doc-have-author 0
.
.
.\" NS An user macro
.\" NS   author name
.\" NS
.\" NS width register `.An' set in doc-common
.
.de An
.  if \n[doc-in-authors-section] \{\
.    ie \n[doc-have-author] \
.      br
.    el \
.      nr doc-have-author 1
.  \}
.
.  if !\n[doc-args-processed] \{\
.    ie !\n[.$] \
.      tm Usage: .An author_name ... \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ds doc-macro-name An
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-args-processed] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Sf user macro
.\" NS   defunct
.\" NS
.\" NS width register `.Sf' set in doc-common
.
.de Sf
.  tm mdoc error: .Sf defunct, use .Pf or .Ns
..
.
.
.ds doc-func-error-string "function returns the value 0 if successful;
.as doc-func-error-string " otherwise the value -1 is returned and
.as doc-func-error-string " the global variable \*[doc-Va-font]errno\f[P]
.as doc-func-error-string " is set to indicate the error.
.
.
.\" NS Rv user macro
.\" NS   return values
.\" NS
.\" NS width register `.Rv' set in doc-common
.\" NS
.\" NS local variable:
.\" NS   doc-str-Rv
.
.de Rv
.
.\" XXX
.
.  ie !\n[.$] \
.    tm Usage: .Rv [-std] (#\n[.c])
.  el \{\
.    \" .ds doc-macro-name Rv
.    \" .nr doc-arg-ptr 0
.    \" .nr lR +1
.    \" .ds doc-arg1 \$2
.    \" .ds doc-arg2 \$3
.    \" .ds doc-arg3 \$4
.    \" .ds doc-arg4 \$5
.    \" .ds doc-arg5 \$6
.    \" .ds doc-arg6 \$7
.    \" .ds doc-arg7 \$8
.    \" .ds doc-arg8 \$9
.    \" .
.    \" .nr doc-num-args (\n[.$] - 1)
.
.    if "\$1"-std" \{\
.      doc-reg-Rv \*[doc-section]
.      if ((\n[doc-reg-Rv] < 2) : (\n[doc-reg-Rv] > 3)) \
.        tm Usage: .Rv -std in sections 2 and 3 only (#\n[.c])
.      br
.      nop \&The
.      Fn \$2
.      nop \&\*[doc-func-error-string]
.  \}\}
..
.
.
.\" NS Mt user macro
.\" NS   mailto (for conversion to HTML)
.
.de Mt
.  Pa \$@
..
.
.
.\" NS Lk user macro
.\" NS   link (for conversion to HTML)
.\" NS
.\" NS local variables:
.\" NS   doc-str-Lk, doc-reg-Lk
.
.de Lk
.  ds doc-str-Lk Sy \$@
.
.  ie (\n[.$] >= 2) \{\
.    doc-get-arg-type \$2
.    ie (\[doc-arg-type] < 3) \{\
.      Em \&\$2:
.      ds doc-str-Lk Sy "\$1"
.      doc-get-width "\$1"
.      shift 2
.      if \n[.$] \
.        as doc-str-Lk " \$@
.    \}
.    el \
.      doc-get-width "\$1"
.  \}
.  el \
.    doc-get-width "\$1"
.
.  ie n \
.    nr doc-reg-Lk 26
.  el \
.    nr doc-reg-Lk 38
.  ie (\n[doc-width] >= \n[doc-reg-Lk]) \
.    D1 \*[doc-str-Lk]
.  el \
.    \*[doc-str-Lk]
..
.
.
.rn em e@
.
.de em
.  tm mdoc error: end-macro (.em) respecification is not allowed. (#\n[.c])
.  ab Should this have been .Em ...?
..
.
.
.ec
.
.\" EOF
