.\" Copyright (c) 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed by the University of
.\"      California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)doc 5.8 (Berkeley) 8/5/91
.\"
.\" Modified by jjc@jclark.com as follows: the doc-* files are assumed to be
.\" installed as mdoc/doc-* rather than tmac.doc-* (the filename
.\" `tmac.doc-common' would be too long); when using groff, the doc-* files
.\" are loaded using the `mso' request.
.\"
.\" Modified by wl@gnu.org to make it more readable: using long names and
.\" many groff features, updating and extending documentation.
.\"
.\" %beginstrip%
.
.
.if !\n(.g \
.  ab This version of mdoc can be run with groff only!
.
.
.cp 0
.
.eo
.
.
.\" Load start-up files
.ie t .mso mdoc/doc-ditroff.new
.el   .mso mdoc/doc-nroff.new
.
.mso mdoc/doc-common.new
.mso mdoc/doc-syms.new
.
.
.\" NS doc-inline-debug user register (bool)
.\" NS   inline debug mode (inline if 1, to stderr if 0 (default))
.
.if !r doc-inline-debug .nr doc-inline-debug 0
.
.
.\" NS doc-debug global register (bool)
.\" NS   debug mode (1 if active, 0 otherwise (default))
.
.nr doc-debug 0
.
.
.\" NS Db macro
.\" NS   start/stop debug mode (`.Db'/`.Db on'/`.Db off')
.\" NS
.\" NS   without argument, toggle debug status
.\" NS
.\" NS modifies:
.\" NS   doc-debug
.
.de Db
.  ie \n[.$] \{\
.    ie "\$1"on" \{\
.      tm DEBUGGING ON
.      nr doc-debug 1
.    \}
.    el \{\
.      ie "\$1"off" \{\
.        tm DEBUGGING OFF
.        nr doc-debug 0
.      \}
.      el \
.        tm Usage: .Db [on | off] (#\n[.c])
.  \}\}
.  el \{\
.    ie \n[doc-debug] \{\
.      tm DEBUGGING OFF
.      nr doc-debug 0
.    \}
.    el \{\
.      tm DEBUGGING ON
.      nr doc-debug 1
.  \}\}
..
.
.
.\" NS doc-macro-name global string
.\" NS   name of calling request (set in each user-requestable macro)
.
.ds doc-macro-name
.
.
.\" NS doc-arg-limit global register
.\" NS   total number of arguments
.
.nr doc-arg-limit 0
.
.
.\" NS doc-num-args global register
.\" NS   number of arguments to handle (must be set to \n[.$] prior to
.\" NS   `doc-parse-arg-vector' request)
.
.nr doc-num-args 0
.
.
.\" NS doc-arg-ptr global register
.\" NS   argument pointer
.
.nr doc-arg-ptr 0
.
.
.\" NS doc-argXXX global string
.\" NS   argument vector
.\" NS
.\" NS   limit: doc-arg-limit
.
.ds doc-arg1
.
.
.\" NS doc-typeXXX global register
.\" NS   argument type vector (macro=1, string=2, punctuation suffix=3,
.\" NS   punctuation prefix=4)
.\" NS
.\" NS   limit: doc-arg-limit
.
.nr doc-type1 0
.
.
.\" NS doc-spaceXXX global string
.\" NS   space vector
.\" NS
.\" NS   limit: doc-arg-limit
.
.ds doc-space1
.
.
.\" NS doc-out-string global string
.\" NS   main working buffer
.
.ds doc-out-string
.
.
.\" NS doc-curr-space global string
.\" NS   current space string
.
.ds doc-curr-space
.
.
.\" NS doc-parse-args macro
.\" NS   parse arguments (recursively) (`.doc-parse-args arg ...')
.\" NS
.\" NS modifies:
.\" NS   doc-argXXX, doc-typeXXX, doc-spaceXXX, doc-arg-limit,
.\" NS   doc-arg-ptr, doc-out-string, doc-curr-space
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpa, doc-reg-dpa, doc-reg-dpa1
.
.de doc-parse-args
.  nr doc-arg-limit +1
.
.  \" handle `|' specially for some requests
.  ie "\$1"|" \{\
.    ie        "\*[doc-macro-name]"Op" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"Ar" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"Fl" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"Cm" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"It" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \
.      ds doc-arg\n[doc-arg-limit] |
.  \}\}\}\}\}
.  el \
.    ds doc-arg\n[doc-arg-limit] "\$1
.
.  \" get argument type and set spacing
.  doc-get-arg-type* \n[doc-arg-limit]
.  nr doc-type\n[doc-arg-limit] \n[doc-arg-type]
.  doc-set-spacing-\n[doc-arg-type]
.
.  if \n[doc-debug] \{\
.    ie (\n[doc-arg-type] == 1) \
.      ds doc-str-dpa macro
.    el \{\
.      ie (\n[doc-arg-type] == 2) \
.        ds doc-str-dpa string
.      el \{\
.        ie (\n[doc-arg-type] == 3) \
.          ds doc-str-dpa closing punctuation or suffix
.        el \
.          ds doc-str-dpa opening punctuation or prefix
.    \}\}
.
.    ie \n[doc-inline-debug] \{\
.      br
.      nr doc-reg-dpa \n[.i]u
.      in -\n[doc-reg-dpa]u
.
.      if (\n[doc-arg-limit] == 1) \{\
.        nop \f[B]DEBUG(doc-parse-args) MACRO:\f[P] `.\*[doc-macro-name]'
.        nop \& \f[B]Line #:\f[P] \n[.c]
.      \}
.      nop \t\f[B]Argc:\f[P] \n[doc-arg-limit]
.      nop \ \f[B]Argv:\f[P] `\*[doc-arg\n[doc-arg-limit]]'
.      nop \ \f[B]Length:\f[P] \n[doc-width]
.      nop \t\f[B]Space:\f[P] `\*[doc-space\n[doc-arg-limit]]'
.      nop \ \f[B]Type:\f[P] \*[doc-str-dpa]
.    \}
.    el \{\
.      if (\n[doc-arg-limit] == 1) \{\
.        tmc "DEBUG (doc-parse-args)
.        tm1 " MACRO: `.\*[doc-macro-name]'  Line #: \n[.c]
.      \}
.      tmc "  Argc: \n[doc-arg-limit]
.      tmc "  Argv: `\*[doc-arg\n[doc-arg-limit]]'
.      tm1 "  Length: \n[doc-width]
.      tmc "  Space: `\*[doc-space\n[doc-arg-limit]]'
.      tm1 "  Type: \*[doc-str-dpa]
.  \}\}
.
.  \" check whether we have processed the last parameter
.  ie (\n[.$] == 1) \{\
.    nr doc-arg-ptr 0
.
.    ie \n[doc-in-diversion] \{\
.      if (\n[doc-nesting-level] > 1) \
.        as doc-out-string "\*[doc-curr-space]
.    \}
.    el \{\
.      if \n[doc-nesting-level] \
.        if !\n[doc-func-arg-count] \
.          as doc-out-string "\*[doc-curr-space]
.    \}
.
.    \" use space after last parameter as the current one
.    ds doc-curr-space "\*[doc-space\n[doc-arg-limit]]
.
.    if \n[doc-debug] \{\
.      nr doc-reg-dpa1 1
.
.      ie \n[doc-inline-debug] \{\
.        nop MACRO REQUEST: \t.\*[doc-macro-name]
.        while (\n[doc-reg-dpa1] <= \n[doc-arg-limit]) \{\
.          nop "\*[doc-arg\n[doc-reg-dpa1]]"
.          nr doc-reg-dpa1 +1
.        \}
.        br
.        in \n[doc-reg-dpa]u
.      \}
.      el \{\
.        tmc "  MACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpa1] <= \n[doc-arg-limit]) \{\
.          tmc " "\*[doc-arg\n[doc-reg-dpa1]]"
.          nr doc-reg-dpa1 +1
.        \}
.        tm
.  \}\}\}
.  el \{\
.    shift
.    doc-parse-args \$@
.  \}
..
.
.
.\" NS doc-parse-arg-vector macro
.\" NS   parse argument vector (recursive)
.\" NS
.\" NS modifies:
.\" NS   doc-argXXX, doc-typeXXX, doc-spaceXXX, doc-arg-limit,
.\" NS   doc-num-args, doc-arg-ptr, doc-out-string, doc-curr-space
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpav, doc-reg-dpav, doc-reg-dpav1
.
.de doc-parse-arg-vector
.  nr doc-arg-limit +1
.
.  \" handle `|' specially for some requests
.  if "\*[doc-arg\n[doc-arg-limit]]"|" \{\
.    ie        "\*[doc-macro-name]"Op" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"Ar" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"Fl" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .ie "\*[doc-macro-name]"Cm" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.    el \{ .if "\*[doc-macro-name]"It" \
.      ds doc-arg\n[doc-arg-limit] \f[R]|\f[P]
.  \}\}\}\}\}
.
.  \" get argument type and set spacing
.  doc-get-arg-type* \n[doc-arg-limit]
.  nr doc-type\n[doc-arg-limit] \n[doc-arg-type]
.  doc-set-spacing-\n[doc-arg-type]
.
.  if \n[doc-debug] \{\
.    ie (\n[doc-arg-type] == 1) \
.      ds doc-str-dpav macro
.    el \{\
.      ie (\n[doc-arg-type] == 2) \
.        ds doc-str-dpav string
.      el \{\
.        ie (\n[doc-arg-type] == 3) \
.          ds doc-str-dpav closing punctuation or suffix
.        el \
.          ds doc-str-dpav opening punctuation or prefix
.    \}\}
.
.    ie \n[doc-inline-debug] \{\
.      br
.      nr doc-reg-dpav \n[.i]u
.      in -\n[doc-reg-dpav]u
.
.      if (\n[doc-arg-limit] == 1) \{\
.        nop \f[B]DEBUG(doc-parse-arg-vector)
.        nop MACRO:\f[P] `.\*[doc-macro-name]'
.        nop \& \f[B]Line #:\f[P] \n[.c]
.      \}
.      nop \t\f[B]Argc:\f[P] \n[doc-arg-limit]
.      nop \ \f[B]Argv:\f[P] `\*[doc-arg\n[doc-arg-limit]]'
.      nop \ \f[B]Length:\f[P] \n[doc-width]
.      nop \t\f[B]Space:\f[P] `\*[doc-space\n[doc-arg-limit]]'
.      nop \ \f[B]Type:\f[P] \*[doc-str-dpav]
.    \}
.    el \{\
.      if (\n[doc-arg-limit] == 1) \{\
.        tmc "DEBUG(doc-parse-arg-vector)
.        tm1 " MACRO: `.\*[doc-macro-name]'  Line #: \n[.c]
.      \}
.      tmc "  Argc: \n[doc-arg-limit]
.      tmc "  Argv: `\*[doc-arg\n[doc-arg-limit]]'
.      tm1 "  Length: \n[doc-width]
.      tmc "  Space: `\*[doc-space\n[doc-arg-limit]]'
.      tm1 "  Type: \*[doc-str-dpav]
.  \}\}
.
.  \" check whether we have processed the last parameter
.  ie (\n[doc-num-args] == 1) \{\
.    nr doc-arg-ptr 0
.
.    ie \n[doc-in-diversion] \{\
.      if (\n[doc-nesting-level] > 1) \
.        as doc-out-string "\*[doc-curr-space]
.    \}
.    el \{\
.      if \n[doc-nesting-level] \
.        if !\n[doc-func-arg-count] \
.          as doc-out-string "\*[doc-curr-space]
.    \}
.
.    \" use space after last parameter as the current one
.    ds doc-curr-space "\*[doc-space\n[doc-arg-limit]]
.
.    nr doc-num-args 0
.
.    if \n[doc-debug] \{\
.      nr doc-reg-dpav1 1
.
.      ie \n[doc-inline-debug] \{\
.        nop \tMACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpav1] <= \n[doc-arg-limit]) \{\
.          nop "\*[doc-arg\n[doc-reg-dpav1]]"
.          nr doc-reg-dpav1 +1
.        \}
.        br
.        in \n[doc-reg-dpav]u
.      \}
.      el \{\
.        tmc "  MACRO REQUEST: .\*[doc-macro-name]
.        while (\n[doc-reg-dpav1] <= \n[doc-arg-limit]) \{\
.          tmc " "\*[doc-arg\n[doc-reg-dpav1]]"
.          nr doc-reg-dpav1 +1
.        \}
.        tm
.  \}\}\}
.  el \{\
.    nr doc-num-args -1
.    doc-parse-arg-vector
.  \}
..
.
.
.\" NS doc-remaining-args macro
.\" NS   output remaining arguments as-is, separated by spaces (until
.\" NS   `doc-num-args' is exhausted), to `doc-out-string'
.\" NS
.\" NS modifies:
.\" NS   doc-num-args, doc-arg-ptr, doc-out-string
.
.de doc-remaining-args
.  nr doc-arg-ptr +1
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.
.  ie (\n[doc-num-args] == 1) \{\
.    nr doc-arg-ptr 0
.    nr doc-num-args 0
.  \}
.  el \{\
.    as doc-out-string "\*[doc-space]
.    nr doc-num-args -1
.    doc-remaining-args
.  \}
..
.
.
.\" NS doc-append-arg macro
.\" NS   append one argument to argument vector:
.\" NS   `.doc-append-arg [arg] [type]'
.\" NS
.\" NS modifies:
.\" NS   doc-argXXX, doc-typeXXX, doc-arg-limit
.
.de doc-append-arg
.  nr doc-arg-limit +1
.  ds doc-arg\n[doc-arg-limit] "\$1
.  nr doc-type\n[doc-arg-limit] \$2
.  doc-set-spacing-\$2
..
.
.
.\" NS doc-print-and-reset macro
.\" NS   print doc-out-string and clean up argument vectors
.
.de doc-print-and-reset
.  doc-print-out-string
.  doc-reset-args
..
.
.
.\" NS doc-reset-args macro
.\" NS   reset argument counters
.\" NS
.\" NS modifies:
.\" NS   doc-arg-limit, doc-arg-ptr
.
.de doc-reset-args
.  nr doc-arg-limit 0
.  nr doc-arg-ptr 0
..
.
.
.\" NS doc-print-out-string macro
.\" NS   print `doc-out-string', possibly ending a diversion, enabling
.\" NS   hyphenation afterwards
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-curr-space
.
.de doc-print-out-string
.  ie \n[doc-in-diversion] \{\
.    if (\n[doc-nesting-level] == 1) \{\
.      if !\n[doc-no-printing] \{\
.        nop \&\*[doc-out-string]
.        ds doc-curr-space
.        ds doc-out-string
.    \}\}
.    if !\n[doc-nesting-level] \
.      doc-end-diversion-and-print
.  \}
.  el \{\
.    ie \n[doc-nesting-level] \{\
.      if \n[doc-space-mode] \
.        if !\n[doc-list-immediate] \
.          doc-save-and-divert
.    \}
.    el \{\
.      if !\n[doc-no-printing] \{\
.        nop \&\*[doc-out-string]
.        ds doc-curr-space
.        ds doc-out-string
.  \}\}\}
.
.  hy
..
.
.
.\" NS doc-diversion diversion
.\" NS   diversion string
.
.
.\" NS doc-saved-out-string global string
.\" NS   saved doc-out-string
.
.ds doc-saved-out-string
.
.
.\" NS doc-in-diversion global register (bool)
.\" NS   whether we are in a diversion
.
.nr doc-in-diversion 0
.
.
.\" NS doc-save-and-divert macro
.\" NS   save doc-out-string, restore fill mode, and divert
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-saved-out-string, doc-diversion,
.\" NS   doc-in-diversion
.
.de doc-save-and-divert
.  nr doc-in-diversion 1
.  ds doc-saved-out-string "\*[doc-out-string]
.  ds doc-out-string
.  ev doc-divert-environment
.  fi
.
.  if \n[doc-debug] \
.    tm begin of `doc-diversion' at line #\n[.c]
.  di doc-diversion
..
.
.
.\" NS doc-end-diversion-and-print macro
.\" NS   end diversion and print
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-in-diversion
.\" NS
.\" NS local variables:
.\" NS   doc-str-dedap
.
.de doc-end-diversion-and-print
.  br
.  di
.  ev
.
.  \" insert diversion only if it contains printable stuff
.  ie \n[dn] \{\
.    ds doc-str-dedap \&\*[doc-diversion]\c
.    ds doc-out-string "\*[doc-saved-out-string]\*[doc-str-dedap]\*[doc-out-string]
.  \}
.  el \
.    ds doc-out-string "\*[doc-saved-out-string]\*[doc-out-string]
.
.  nop \&\*[doc-out-string]
.
.  ds doc-out-string
.  nr doc-in-diversion 0
..
.
.
.ec
.
.\" NS doc-curr-font global register
.\" NS   saved current font
.
.nr doc-curr-font \n[.f]
.
.
.\" NS doc-curr-size global register
.\" NS   saved current font size
.
.nr doc-curr-size \n[.s]
.
.eo
.
.
.\" NS Fl user macro
.\" NS   handle flags (appends `-' and prints flags): `.Fl [arg ...]'
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS local variables:
.\" NS   doc-reg-Fl (for communication with doc-flag-recursion)
.\" NS
.\" NS width register `Fl' set in doc-common
.
.de Fl
.  as doc-out-string \*[doc-Fl-font]
.
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fl
.      doc-parse-args \$@
.    \}
.    el \{\
.      \" no arguments
.      as doc-out-string \|\-\|\f[P]\s[0]
.      doc-print-out-string
.  \}\}
.
.  if \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \|\-\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie (\n[doc-type\n[doc-arg-ptr]] == 1) \{\
.        as doc-out-string \|\-\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.
.        if (\n[doc-type\n[doc-arg-ptr]] == 3) \
.          as doc-out-string \|\-\|
.
.        nr doc-reg-Fl 1
.        doc-flag-recursion
.  \}\}\}
..
.
.
.\" NS doc-flag-recursion macro
.\" NS   `Fl' flag recursion routine (special handling)
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string
.\" NS
.\" NS local variables:
.\" NS   doc-str-dfr, doc-reg-dfr, doc-reg-dfr1
.
.de doc-flag-recursion
.  nr doc-reg-dfr1 \n[doc-type\n[doc-arg-ptr]]
.  ds doc-str-dfr "\*[doc-arg\n[doc-arg-ptr]]
.
.  hy 0
.
.  ie (\n[doc-reg-dfr1] == 1) \{\
.    as doc-out-string \f[P]\s[0]
.    \*[doc-str-dfr]
.  \}
.  el \{\
.    nr doc-reg-dfr \n[doc-arg-ptr]
.
.    ie (\n[doc-reg-dfr1] == 2) \{\
.      \" handle vertical bar -- doc-reg-Fl is set for the first call of
.      \" doc-flag-recursion only; we need this to make `.Fl | ...' work
.      \" correctly
.      ie "\*[doc-str-dfr]"\*[Ba]" \{\
.        if \n[doc-reg-Fl] \
.          as doc-out-string \|\-\*[doc-space]
.        as doc-out-string \&\*[Ba]
.      \}
.      el \{\
.        ie "\*[doc-str-dfr]"\f[R]|\f[P]" \{\
.          if \n[doc-reg-Fl] \
.            as doc-out-string \|\-\*[doc-space]
.          as doc-out-string \f[R]|\f[P]
.        \}
.        el \{\
.          \" two consecutive hyphen characters?
.          ie "\*[doc-str-dfr]"-" \
.            as doc-out-string \|\-\^\-\|
.          el \
.            as doc-out-string \|\-\*[doc-str-dfr]
.    \}\}\}
.    el \{\
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as doc-out-string "\*[doc-str-dfr]\f[P]\s[0]
.    \}
.
.    ie (\n[doc-arg-limit] == \n[doc-arg-ptr]) \{\
.      \" last argument
.      if (\n[doc-reg-dfr1] == 4) \
.        as doc-out-string \|\-
.      as doc-out-string \f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      ie (\n[doc-type\n[doc-arg-ptr]] == 3) \{\
.        ie (\n[doc-type\n[doc-reg-dfr]] == 4) \
.          as doc-out-string \|\-
.        el \
.          as doc-out-string "\*[doc-space\n[doc-reg-dfr]]
.      \}
.      el \
.        as doc-out-string "\*[doc-space\n[doc-reg-dfr]]
.
.      shift
.      nr doc-reg-Fl 0
.      doc-flag-recursion \$@
.  \}\}
..
.
.
.\" NS doc-print-recursive macro
.\" NS   general name recursion routine (print remaining arguments)
.\" NS
.\" NS   hyphenation is disabled
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string
.\" NS
.\" NS local variables:
.\" NS   doc-str-dpr, doc-reg-dpr, doc-reg-dpr1
.
.de doc-print-recursive
.  nr doc-reg-dpr1 \n[doc-type\n[doc-arg-ptr]]
.  ds doc-str-dpr "\*[doc-arg\n[doc-arg-ptr]]
.
.  hy 0
.
.  ie (\n[doc-reg-dpr1] == 1) \{\
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \*[doc-str-dpr]
.  \}
.  el \{\
.    nr doc-reg-dpr \n[doc-arg-ptr]
.
.    ie (\n[doc-reg-dpr1] == 2) \
.      as doc-out-string \&\*[doc-str-dpr]
.    el \{\
.      \" punctuation character
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      as doc-out-string "\*[doc-str-dpr]\f[P]\s[0]
.    \}
.
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.      doc-print-and-reset
.    \}
.    el \{\
.      as doc-out-string "\*[doc-space\n[doc-reg-dpr]]
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS Ar user macro
.\" NS   command line `argument' macro: `.Ar [args ...]'
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Ar' set in doc-common
.
.de Ar
.  as doc-out-string \*[doc-Ar-font]
.
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ar
.      doc-parse-args \$@
.    \}
.    el \{\
.      \" no argument
.      as doc-out-string \&file\ ...\f[P]\s[0]
.      doc-print-out-string
.  \}\}
.
.  if \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
.      as doc-out-string \&file\ ...\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie (\n[doc-type\n[doc-arg-ptr]] == 1) \{\
.        as doc-out-string \&file\ ...\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.        if (\n[doc-type\n[doc-arg-ptr]] == 3) \
.          as doc-out-string \&file\ ...
.        doc-print-recursive
.  \}\}\}
..
.
.
.\" NS Ad user macro
.\" NS   Addresses
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Ad' set in doc-common
.
.de Ad
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ad
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ad address ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ad-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-in-synopsis-count global register
.\" NS   whether we have more than a single item in synopsis
.
.nr doc-in-synopsis-count 0
.
.
.\" NS doc-indent-synopsis global register
.\" NS   indentation in synopsis
.
.nr doc-indent-synopsis 0
.
.
.\" NS Cd user macro
.\" NS   Config declaration (for section 4 SYNOPSIS)
.\" NS
.\" NS   this function causes a break; it uses the `Nm' font
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size, doc-in-synopsis-count, doc-indent-synopsis
.\" NS
.\" NS width register `Cd' set in doc-common
.\"
.\" needs work - not very translatable
.
.de Cd
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Cd
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Cd Configuration file declaration (#\n[.c])
.  \}
.
.  br
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Nm-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    ie \n[doc-in-synopsis-count] \{\
.      if "\*[doc-macro-name]"Cd" \{\
.        rs
.        ie (\n[doc-in-synopsis-count] > 1) \
.          br
.        el \{\
.          if !\n[doc-indent-synopsis] \
.            nr doc-indent-synopsis \n[doc-display-indent]u
.        \}
.        in +\n[doc-indent-synopsis]u
.        ti -\n[doc-indent-synopsis]u
.        nr doc-in-synopsis-count +1
.      \}
.
.      doc-print-recursive
.      in -\n[doc-indent-synopsis]u
.    \}
.    el \
.      doc-print-recursive
.  \}
..
.
.
.\" NS Cm user macro
.\" NS   Interactive command modifier (flag)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Cm' set in doc-common
.
.de Cm
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Cm
.      doc-parse-args \$@
.    \}
.    el \{\
.      tmc Usage: .Cm Interactive command modifier ...
.      tm1 " \*[doc-punct-chars] (#\n[.c])
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Cm-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Dv user macro
.\" NS   define variable
.\" NS
.\" NS   this function uses the `Er' font
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Dv' set in doc-common
.
.de Dv
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Dv
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Dv define_variable ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Er-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Em user macro
.\" NS   emphasis
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Em' set in doc-common
.
.de Em
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Em
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Em text ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Em-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Er user macro
.\" NS   errno type
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Er' set in doc-common
.
.de Er
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Er
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Er errno_type ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Er-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ev user macro
.\" NS   environment variable
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Ev' set in doc-common
.
.de Ev
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ev
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ev enviroment_variable ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ev-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-have-decl global register (bool)
.\" NS   subroutine test (in synopsis only)
.
.nr doc-have-decl 0
.
.
.\" NS doc-have-var global register (bool)
.\" NS   whether last type is a variable type
.
.nr doc-have-var 0
.
.
.\" NS doc-do-func-decl macro
.\" NS   do someting special while in SYNOPSIS
.\" NS
.\" NS modifies:
.\" NS   doc-curr-font, doc-curr-size, doc-have-decl,
.\" NS   doc-have-var
.
.de doc-do-func-decl
.  if \n[doc-in-synopsis-count] \{\
.    \" if a variable type was the last thing given, want vertical space
.    if \n[doc-have-var] \{\
.      doc-paragraph
.      nr doc-have-var 0
.    \}
.    \" if a subroutine was the last thing given, want vertical space
.    if \n[doc-have-func] \{\
.      ie \n[doc-have-decl] \
.        br
.      el \{\
.        doc-paragraph
.        rs
.    \}\}
.    nr doc-have-decl 1
.  \}
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
..
.
.
.\" NS Fd user macro
.\" NS   function declaration -- not callable
.\" NS
.\" NS   this function causes a break
.\" NS
.\" NS width register `Fd' set in doc-common
.
.de Fd
.  ie \n[doc-arg-limit] \
.    tm Usage: .Fd function_declaration -- Fd is not callable (#\n[.c])
.  el \{\
.    doc-do-func-decl
.    nop \*[doc-Fd-font]\$*
.    br
.    ft \n[doc-curr-font]
.    ps \n[doc-curr-size]
.  \}
..
.
.
.\" NS In user macro
.\" NS   #include statement - not callable (& no err check)
.\" NS
.\" NS   this function causes a break; it uses the `Fd' font
.\" NS
.\" NS width register `In' set in doc-common
.
.de In
.  ie \n[doc-arg-limit] \
.    tm Usage: .In #include_statement -- In is not callable (#\n[.c])
.  el \{\
.    doc-do-func-decl
.    nop \*[doc-Fd-font]#include <\$1>
.    br
.    ft \n[doc-curr-font]
.    ps \n[doc-curr-size]
.  \}
..
.
.
.\" NS Fr user macro
.\" NS   function return value
.\" NS
.\" NS   this function uses the `Ar' font
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Fr' set in doc-common
.
.de Fr
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fr
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Fr Function_return_value... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ar-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ic user macro
.\" NS   interactive command
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Ic' set in doc-common
.
.de Ic
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ic
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ic Interactive command ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ic-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Li user macro
.\" NS   literals
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Li' set in doc-common
.
.de Li
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Li
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Li argument ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Li-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Or user macro
.\" NS   pipe symbol (OR)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Or' set in doc-common
.\"
.\" XXX: What is this function good for?  It sets a font but does not print
.\"      a pipe symbol.  And it isn't documented.
.
.de Or
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Or
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Or ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Ic-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Ms user macro
.\" NS   math symbol
.\" NS
.\" NS   this function uses the `Sy' font
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Ms' set in doc-common
.
.de Ms
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Ms
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Ms Math symbol ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Sy-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-command-name global string
.\" NS   save first invocation of .Nm
.
.ds doc-command-name
.
.
.\" NS Nm user macro
.\" NS   name of command or page topic
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size, doc-in-synopsis-count, doc-indent-synopsis,
.\" NS   doc-command-name
.\" NS
.\" NS local variables:
.\" NS   doc-str-Nm
.\" NS
.\" NS width register `Nm' set in doc-common
.
.de Nm
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Nm
.
.      \" handle empty first parameter
.      ie "\$1"" \
.        ds doc-str-Nm "\*[doc-command-name]
.      el \
.        ds doc-str-Nm "\$1
.      shift
.      doc-parse-args "\*[doc-str-Nm]" \$@
.    \}
.    el \{\
.      ie "\*[doc-command-name]"" \
.        tm Usage: .Nm Name ... \*[doc-punct-chars] (#\n[.c])
.      el \
.        nop \*[doc-Nm-font]\*[doc-command-name]\f[P]\s[0]
.  \}\}
.
.  if \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \*[doc-Nm-font]\*[doc-command-name]\f[P]\s[0]
.      doc-print-and-reset
.    \}
.    el \{\
.      as doc-out-string \*[doc-Nm-font]
.      ie (\n[doc-type\n[doc-arg-ptr]] == 1) \{\
.        as doc-out-string \&\*[doc-command-name]\f[P]\s[0]
.        \*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        nr doc-curr-font \n[.f]
.        nr doc-curr-size \n[.s]
.
.        \" handle `.Nm ...' in SYNOPSIS
.        if \n[doc-in-synopsis-count] \{\
.          if "\*[doc-macro-name]"Nm" \{\
.            rs
.            in -\n[doc-indent-synopsis]u
.            ie (\n[doc-in-synopsis-count] > 1) \
.              br
.            el \{\
.              if !\n[doc-indent-synopsis] \{\
.                doc-get-width \$1
.                nr doc-indent-synopsis ((\n[doc-width]u + 1u) * \n[doc-fixed-width]u)
.            \}\}
.            in +\n[doc-indent-synopsis]u
.            ti -\n[doc-indent-synopsis]u
.            nr doc-in-synopsis-count +1
.        \}\}
.        if "\*[doc-command-name]"" \
.          ds doc-command-name "\*[doc-arg\n[doc-arg-ptr]]
.        doc-print-recursive
.  \}\}\}
..
.
.
.\" NS Pa user macro
.\" NS   pathname: `.Pa [arg ...]'
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Pa' set in doc-common
.
.de Pa
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Pa
.      doc-parse-args \$@
.    \}
.    el \{\
.      \" default value
.      nop \*[doc-Pa-font]~\f[P]\s[0]
.  \}\}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Pa-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Sy user macro
.\" NS   symbolics
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Sy' set in doc-common
.
.de Sy
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Sy
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Sy symbolic_text ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Sy-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Me user macro
.\" NS   menu entries
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Me' set in doc-common
.
.de Me
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Me
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Me menu_entry ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Me-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Tn user macro
.\" NS   trade name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Tn' set in doc-common
.
.de Tn
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Tn
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Tn trade_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Tn-font-shape]\*[doc-Tn-font-size]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-reference-trademark macro
.\" NS   .Tn for inside of references
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS   the code for references below checks for `Tn'!
.
.de doc-reference-trademark
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Tn
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Tn trade_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \&\*[doc-Tn-font-size]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS Va user macro
.\" NS   variable name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Va' set in doc-common
.
.de Va
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Va
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Va variable_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Va-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS No user macro
.\" NS   normal text macro (default text style if mess up)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `No' set in doc-common
.
.de No
.  as doc-out-string \*[doc-No-font]
.
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name No
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .No normal_text ... \*[doc_punct_chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    ie (\n[doc-type\n[doc-arg-ptr]] == 1) \
.      \*[doc-arg\n[doc-arg-ptr]]
.    el \{\
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS doc-quote-left global string
.\" NS   left quotation character for `doc-enclose-string' and
.\" NS   `doc-enclose-open'
.
.ds doc-quote-left
.
.
.\" NS doc-quote-right global string
.\" NS   right quotation character for `doc-enclose-string' and
.\" NS   `doc-enclose-close'
.
.ds doc-quote-right
.
.
.\" NS Op user macro
.\" NS   option expression (i.e., enclose string in square brackets)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Op' set in doc-common
.
.de Op
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Op
.
.  ds doc-quote-left "\*[doc-left-bracket]
.  ds doc-quote-right "\*[doc-right-bracket]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Aq user macro
.\" NS   enclose string in angle brackets
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Aq' set in doc-common
.
.de Aq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Aq
.
.  ds doc-quote-left <
.  ds doc-quote-right >
.
.  doc-enclose-string \$@
..
.
.
.\" NS Bq user macro
.\" NS   enclose string in square brackets
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Bq' set in doc-common
.
.de Bq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Bq
.
.  ds doc-quote-left "\*[doc-left-bracket]
.  ds doc-quote-right "\*[doc-right-bracket]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Dq user macro
.\" NS   enclose string in double quotes
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Dq' set in doc-common
.
.de Dq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Dq
.
.  ds doc-quote-left "\*[Lq]
.  ds doc-quote-right "\*[Rq]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Eq user macro
.\" NS   enclose string in user-defined quotes (args 1 and 2)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Eq' set in doc-common
.
.de Eq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Eq
.
.  ds doc-quote-left "\$1
.  ds doc-quote-right "\$2
.
.  shift 2
.  doc-enclose-string \$@
..
.
.
.\" NS Pq user macro
.\" NS   enclose string in parentheses
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Pq' set in doc-common
.
.de Pq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Pq
.
.  ds doc-quote-left "\*[doc-left-parenthesis]
.  ds doc-quote-right "\*[doc-right-parenthesis]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Ql user macro
.\" NS   quoted literal
.\"
.\"   is in file doc-[dit|n]roff
.
.
.\" NS Qq user macro
.\" NS   enclose string in straight double quotes
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Qq' set in doc-common
.
.de Qq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Qq
.
.  ds doc-quote-left "\*[q]
.  ds doc-quote-right "\*[q]
.
.  doc-enclose-string \$@
..
.
.
.\" NS Sq user macro
.\" NS   enclose string in single quotes
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left, doc-quote-right
.\" NS
.\" NS width register `Sq' set in doc-common
.
.de Sq
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Sq
.
.  ds doc-quote-left "\*[doc-left-singlequote]
.  ds doc-quote-right "\*[doc-right-singlequote]
.
.  doc-enclose-string \$@
..
.
.
.\" NS doc-enclose-string macro
.\" NS   enclose string with given args (e.g. [ and ])
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-argXXX, doc-out-string
.\" NS
.\" NS local variables:
.\" NS   doc-reg-des (for communication with doc-skip-punct-backwards)
.\" NS
.\" NS requires:
.\" NS   doc-quote-left, doc-quote-right
.
.de doc-enclose-string
.  ie \n[doc-arg-limit] \
.    as doc-out-string \&\*[doc-quote-left]
.  el \{\
.    ie \n[.$] \{\
.      doc-parse-args \$@
.      as doc-out-string \&\*[doc-quote-left]
.    \}
.    el \{\
.      \" no argument
.      as doc-out-string \&\*[doc-quote-left]\*[doc-quote-right]
.      doc-print-out-string
.  \}\}
.
.  if \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \{\
.      \" last argument
.      as doc-out-string \&\*[doc-quote-right]
.      doc-print-and-reset
.    \}
.    el \{\
.      ie (\n[doc-type\n[doc-arg-limit]] == 3) \{\
.        nr doc-reg-des (\n[doc-arg-limit] - 1)
.        doc-skip-punct-backwards
.        nr doc-reg-des +1
.        ds doc-arg\n[doc-reg-des] "\*[doc-quote-right]\&\*[doc-arg\n[doc-reg-des]]
.        nr doc-reg-des 0
.      \}
.      el \
.        doc-append-arg "\*[doc-quote-right]" 3
.
.      doc-do-\n[doc-type\n[doc-arg-ptr]]
.  \}\}
..
.
.
.\" NS doc-skip-punct-backwards macro
.\" NS   vector routine (for `doc-enclose-string': trace backwards past
.\" NS   trailing punctuation)
.\" NS
.\" NS requires:
.\" NS   doc-reg-des
.
.de doc-skip-punct-backwards
.  if (\n[doc-type\n[doc-reg-des]] == 3) \{\
.    nr doc-reg-des -1
.    doc-skip-punct-backwards
.  \}
..
.
.
.\" NS Ao user macro
.\" NS   angle open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Ao' set in doc-common
.
.de Ao
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Ao
.
.  ds doc-quote-left <
.
.  doc-enclose-open \$@
..
.
.
.\" NS Ac user macro
.\" NS   angle close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Ac' set in doc-common
.
.de Ac
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Ac
.
.  ds doc-quote-right >
.
.  doc-enclose-close \$@
..
.
.
.\" NS Bo user macro
.\" NS   bracket open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Bo' set in doc-common
.
.de Bo
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Bo
.
.  ds doc-quote-left [
.
.  doc-enclose-open \$@
..
.
.
.\" NS Bc user macro
.\" NS   bracket close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Bc' set in doc-common
.
.de Bc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Bc
.
.  ds doc-quote-right ]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Do user macro
.\" NS   double quote open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Do' set in doc-common
.
.de Do
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Do
.
.  ds doc-quote-left "\*[Lq]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Dc user macro
.\" NS   double quote close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Dc' set in doc-common
.
.de Dc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Dc
.
.  ds doc-quote-right "\*[Rq]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Eo user macro
.\" NS   enclose open (using first argument as beginning of enclosure)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Eo' set in doc-common
.
.de Eo
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Eo
.
.  ds doc-quote-left "\$1
.
.  shift
.  doc-enclose-open \$@
..
.
.
.\" NS Ec user macro
.\" NS   enclose close (using first argument as end of enclosure)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Ec' set in doc-common
.
.de Ec
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Ec
.
.  ds doc-quote-right "\$1
.
.  shift
.  doc-enclose-close \$@
..
.
.
.\" NS Oo user macro
.\" NS   option open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Oo' set in doc-common
.
.de Oo
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Oo
.
.  ds doc-quote-left [
.
.  doc-enclose-open \$@
..
.
.
.\" NS Oc user macro
.\" NS   option close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Oc' set in doc-common
.
.de Oc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Oc
.
.  ds doc-quote-right ]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Po user macro
.\" NS   parenthesis open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Po' set in doc-common
.
.de Po
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Po
.
.  ds doc-quote-left (
.
.  doc-enclose-open \$@
..
.
.
.\" NS Pc user macro
.\" NS   parenthesis close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Pc' set in doc-common
.
.de Pc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Pc
.
.  ds doc-quote-right )
.
.  doc-enclose-close \$@
..
.
.
.\" NS Qo user macro
.\" NS   straight double quote open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Qo' set in doc-common
.
.de Qo
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Qo
.
.  ds doc-quote-left "\*[q]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Qc user macro
.\" NS   straight double quote close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Qc' set in doc-common
.
.de Qc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Qc
.
.  ds doc-quote-right "\*[q]
.
.  doc-enclose-close \$@
..
.
.
.\" NS So user macro
.\" NS   single quote open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `So' set in doc-common
.
.de So
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name So
.
.  ds doc-quote-left "\*[doc-left-singlequote]
.
.  doc-enclose-open \$@
..
.
.
.\" NS Sc user macro
.\" NS   single quote close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Sc' set in doc-common
.
.de Sc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Sc
.
.  ds doc-quote-right "\*[doc-right-singlequote]
.
.  doc-enclose-close \$@
..
.
.
.\" NS Xo user macro
.\" NS   extend open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-left
.\" NS
.\" NS width register `Xo' set in doc-common
.
.de Xo
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Xo
.
.  ds doc-quote-left
.
.  doc-enclose-open \$@
..
.
.
.\" NS Xc user macro
.\" NS   extend close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-quote-right
.\" NS
.\" NS width register `Xc' set in doc-common
.
.de Xc
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Xc
.
.  ds doc-quote-right
.
.  doc-enclose-close \$@
..
.
.
.\" NS doc-nesting-level global register
.\" NS   (extension possible)
.
.nr doc-nesting-level 0
.
.
.\" NS doc-enclose-open macro
.\" NS   enclose string open
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string, doc-nesting-level,
.\" NS   doc-saved-list-immediate
.
.de doc-enclose-open
.  nr doc-nesting-level +1
.
.  ie \n[doc-arg-limit] \
.    as doc-out-string \&\*[doc-quote-left]
.  el \{\
.    ie \n[.$] \{\
.      doc-parse-args \$@
.      as doc-out-string \&\*[doc-quote-left]
.    \}
.    el \{\
.      as doc-out-string \&\*[doc-quote-left]
.
.      if !\n[doc-in-diversion] \
.        if \n[doc-space-mode] \
.          doc-save-and-divert
.  \}\}
.
.  ie \n[doc-arg-limit] \{\
.    if (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
.      nr doc-arg-ptr +1
.      ie (\n[doc-type\n[doc-arg-ptr]] == 1) \
.        \*[doc-arg\n[doc-arg-ptr]]
.      el \{\
.        nr doc-arg-ptr -1
.        No
.    \}\}
.
.    if (\n[doc-arg-limit] == \n[doc-arg-ptr]) \{\
.      if \n[doc-list-immediate] \{\
.        \" .tm SETTING doc-saved-list-immediate!
.        nr doc-saved-list-immediate 1
.      \}
.      doc-reset-args
.  \}\}
.  el \{\
.    if (\n[doc-nesting-level] > 1) \
.      as doc-out-string "\*[doc-space]
.  \}
..
.
.
.\" NS doc-saved-list-type global string
.\" NS   saved list type
.
.ds doc-saved-list-type
.
.
.\" NS doc-enclose-close macro
.\" NS   enclose string close
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level, doc-saved-list-immediate,
.\" NS   doc-saved-list-type
.\" NS
.\" NS local variables:
.\" NS   doc-str-dec
.
.de doc-enclose-close
.  nr doc-nesting-level -1
.
.  as doc-out-string \&\*[doc-quote-right]
.
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \
.      doc-parse-args \$@
.    el \{\
.      doc-print-out-string
.      if !"\*[doc-saved-list-type]"" \{\
.        doc-\*[doc-list-type-stack\n[doc-list-depth]]
.        nr doc-saved-list-immediate 0
.        ds doc-saved-list-type
.  \}\}\}
.
.  if \n[doc-arg-limit] \{\
.    ie (\n[doc-arg-limit] == \n[doc-arg-ptr]) \{\
.      ie \n[doc-nesting-level] \
.        doc-reset-args
.      el \
.        doc-print-and-reset
.    \}
.    el \{\
.      nr doc-str-dec (\n[doc-arg-ptr] + 1)
.      if (\n[doc-type\n[doc-str-dec]] == 2) \
.        as doc-out-string "\*[doc-space\n[doc-arg-limit]]
.
.      if \n[doc-list-immediate] \{\
.        \" .tm UNSETTING doc-saved-list-immediate==\n[doc-saved-list-immediate]!
.        if \n[doc-saved-list-immediate] \
.          nr doc-saved-list-immediate 0
.      \}
.      No
.  \}\}
..
.
.
.\" NS Pf user macro
.\" NS   prefix: `.Pf prefix arg ...'
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-quote-left
.\" NS
.\" NS width register `Pf' set in doc-common
.
.de Pf
.  if !\n[doc-arg-limit] \
.    ds doc-macro-name Pf
.
.  ds doc-quote-left "\$1
.
.  shift
.
.  ie \n[doc-arg-limit] \{\
.    ie ((\n[doc-arg-limit] - \n[doc-arg-ptr]) > 1) \{\
.      nr doc-arg-ptr +1
.      as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.    \}
.    el \
.      tm mdoc warning: .Pf: trailing prefix (#\n[.c])
.  \}
.  el \{\
.    as doc-out-string \&\*[doc-quote-left]
.    ie (\n[.$] < 2) \{\
.      tm mdoc warning: .Pf: missing arguments (#\n[.c])
.      doc-print-out-string
.    \}
.    el \
.      doc-parse-args \$@
.  \}
.
.  if \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] < \n[doc-arg-ptr]) \
.      doc-print-and-reset
.    el \
.      doc-do-\n[doc-type\n[doc-arg-ptr]]
.  \}
..
.
.
.\" NS Ns user macro
.\" NS   remove space (space removal done by `doc-parse-args')
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name
.\" NS
.\" NS width register `Ns' set in doc-common
.
.de Ns
.  if !\n[doc-arg-limit] \{\
.    ds doc-macro-name Ns
.    ie \n[.$] \
.      doc-parse-args \$@
.    el \
.      tm Usage: .Ns must be called with arguments (#\n[.c])
.  \}
.
.  No
..
.
.
.\" NS Ap user macro
.\" NS   append an apostrophe
.\" NS
.\" NS modifies:
.\" NS   doc-out-string
.\" NS
.\" NS width register `Ap' set in doc-common
.
.de Ap
.  if !\n[doc-arg-limit] \
.    tm Usage: `Ap' cannot be first request on a line (no `.Ap') (#\n[.c])
.
.  as doc-out-string \&'
.  No
..
.
.
.\" NS doc-space global string
.\" NS   current inter-argument space
.
.ds doc-space "\*[doc-soft-space]
.
.
.\" NS doc-soft-space constant string
.\" NS   soft (stretchable) space (defined in doc-common)
.
.
.\" NS doc-hard-space constant string
.\" NS   hard (unpaddable) space (defined in doc-common)
.
.
.\" NS doc-set-hard-space macro
.\" NS   set current space string to hard (unpaddable) space.
.\" NS
.\" NS modifies:
.\" NS   doc-space
.
.de doc-set-hard-space
.  ds doc-space "\*[doc-hard-space]
..
.
.
.\" NS doc-set-soft-space macro
.\" NS   set current space string to soft space (troff limitation)
.\" NS
.\" NS modifies:
.\" NS   doc-space
.
.de doc-set-soft-space
.  ds doc-space "\*[doc-soft-space]
..
.
.
.\" NS doc-space-mode global register (bool)
.\" NS   default is one (space mode on)
.
.nr doc-space-mode 1
.
.
.\" NS Sm user macro
.\" NS   space mode (`.Sm'/`.Sm on'/`.Sm off')
.\" NS
.\" NS   without argument, toggle space mode
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-limit, doc-num-args, doc-arg-ptr,
.\" NS   doc-argXXX, doc-spaceXXX, doc-curr-space, doc-space-mode,
.\" NS   doc-space
.\" NS
.\" NS width register `Sm' set in doc-common
.\" NS
.\" NS local variables:
.\" NS   doc-reg-Sm
.
.de Sm
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Sm
.      doc-parse-args \$@
.    \}
.    el \{\
.      ie \n[doc-space-mode] \
.        nr doc-space-mode 0
.      el \
.        nr doc-space-mode 1
.  \}\}
.
.  if \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.
.    \" avoid a warning message in case `Sm' is the last parameter
.    if !d doc-arg\n[doc-arg-ptr] \
.      ds doc-arg\n[doc-arg-ptr]
.
.    ie "\*[doc-arg\n[doc-arg-ptr]]"on" \{\
.      ds doc-space "\*[doc-soft-space]
.      nr doc-space-mode 1
.    \}
.    el \{\
.      ie "\*[doc-arg\n[doc-arg-ptr]]"off" \{\
.        ds doc-space
.        ds doc-curr-space
.        nr doc-space-mode 0
.      \}
.      el \{\
.        \" no argument for Sm
.        nr doc-arg-ptr -1
.        ie \n[doc-space-mode] \
.          nr doc-space-mode 0
.        el \
.          nr doc-space-mode 1
.    \}\}
.
.    ie \n[doc-space-mode] \{\
.      \" recompute space vector for remaining arguments
.      nr doc-num-args (\n[doc-arg-limit] - \n[doc-arg-ptr])
.      nr doc-arg-limit \n[doc-arg-ptr]
.      nr doc-reg-Sm \n[doc-arg-ptr]
.      if \n[doc-num-args] \{\
.        doc-parse-arg-vector
.        nr doc-arg-ptr \n[doc-reg-Sm]
.    \}\}
.    el \{\
.      \" reset remaining space vector elements
.      nr doc-reg-Sm (\n[doc-arg-ptr] + 1)
.      while (\n[doc-reg-Sm] <= \n[doc-arg-limit]) \{\
.        ds doc-space\n[doc-reg-Sm]
.        nr doc-reg-Sm +1
.        \" the body of a `while' request must end with the fitting `\}'!
.      \}
.    \}
.
.    \" do we have parameters to print?
.    ie (\n[doc-arg-limit] <= \n[doc-arg-ptr]) \{\
.      \" ignore `.Sm on' and `.Sm off' without additional parameters
.      ie (\n[doc-arg-ptr] > 1) \
.        doc-print-and-reset
.      el \
.        doc-reset-args
.    \}
.    el \{\
.      \" skip `Sm' argument
.      nr doc-arg-ptr +1
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS doc-arg-type immediate register
.\" NS   argument type (macro=1, string=2, punctuation suffix=3,
.\" NS   punctuation prefix=4)
.
.nr doc-arg-type 0
.
.
.\" NS doc-get-arg-type macro
.\" NS   get argument type
.\" NS
.\" NS   this macro expects the width of the argument in `doc-width'
.\" NS
.\" NS modifies:
.\" NS   doc-arg-type
.
.de doc-get-arg-type
.  nr doc-arg-type 2
.
.  if ((\n[doc-width] < 4) & \A\$1) \{\
.    ie (\n[doc-width] == 1) \{\
.      if r doc-punct\$1 \
.        nr doc-arg-type \n[doc-punct\$1]
.    \}
.    el \
.      if r \$1 \
.        nr doc-arg-type 1
.  \}
..
.
.
.\" NS doc-get-arg-type* macro
.\" NS   similar to as `doc-get-arg-type' but uses doc-argXXX strings
.\" NS
.\" NS   this macro sets the `doc-width' register using the `length' request
.\" NS   to get the number of characters in a string literally
.\" NS
.\" NS modifies:
.\" NS   doc-arg-type, doc-width
.
.de doc-get-arg-type*
.  nr doc-arg-type 2
.  length doc-width "\*[doc-arg\$1]
.
.  if ((\n[doc-width] < 4) & \A\*[doc-arg\$1]) \{\
.    ie (\n[doc-width] == 1) \{\
.      if r doc-punct\*[doc-arg\$1] \
.        nr doc-arg-type \n[doc-punct\*[doc-arg\$1]]
.    \}
.    el \
.      if r \*[doc-arg\$1] \
.        nr doc-arg-type 1
.  \}
..
.
.
.\" NS doc-set-spacing-1 macro
.\" NS   set spacing for macros
.\" NS
.\" NS modifies:
.\" NS   doc-spaceXXX
.\" NS
.\" NS local variables:
.\" NS   doc-reg-dssfm, doc-reg-dssfm1
.
.de doc-set-spacing-1
.  nr doc-reg-dssfm1 \n[\*[doc-arg\n[doc-arg-limit]]]
.
.  \" closing macros like .Ac, Bc., etc. have value 3 (remove space before
.  \" argument)
.  ie (\n[doc-reg-dssfm1] == 3) \{\
.    nr doc-reg-dssfm (\n[doc-arg-limit] - 1)
.    ds doc-space\n[doc-reg-dssfm]
.    ds doc-space\n[doc-arg-limit] "\*[doc-space]
.  \}
.  el \{\
.    \" macros like .Ap and .Ns have value 2 (remove space before and after
.    \" argument)
.    ie (\n[doc-reg-dssfm1] == 2) \{\
.      nr doc-reg-dssfm (\n[doc-arg-limit] - 1)
.      ds doc-space\n[doc-reg-dssfm]
.      ds doc-space\n[doc-arg-limit]
.    \}
.    el \
.      ds doc-space\n[doc-arg-limit]
.  \}
..
.
.
.\" NS doc-set-spacing-2 macro
.\" NS   set spacing for strings
.\" NS
.\" NS modifies:
.\" NS   doc-spaceXXX
.
.de doc-set-spacing-2
.  ds doc-space\n[doc-arg-limit] "\*[doc-space]
..
.
.
.\" NS doc-set-spacing-3 macro
.\" NS   set spacing for punctuation suffixes
.\" NS
.\" NS modifies:
.\" NS   doc-spaceXXX
.\" NS
.\" NS local variables:
.\" NS   doc-reg-dssfps
.
.de doc-set-spacing-3
.  if \n[doc-arg-limit] \{\
.    nr doc-reg-dssfps (\n[doc-arg-limit] - 1)
.    ds doc-space\n[doc-reg-dssfps]
.  \}
.
.  ds doc-space\n[doc-arg-limit] "\*[doc-space]
..
.
.
.\" NS doc-set-spacing-4 macro
.\" NS   set spacing for punctuation prefixes
.\" NS
.\" NS modifies:
.\" NS   doc-spaceXXX
.
.de doc-set-spacing-4
.  ds doc-space\n[doc-arg-limit]
..
.
.
.\" type switches (on current argument doc-arg-ptr)
.
.
.\" NS doc-do-1 macro
.\" NS   call request if macro
.
.de doc-do-1
.  \*[doc-arg\n[doc-arg-ptr]]
..
.
.
.\" NS doc-do-2 macro
.\" NS   call .No if string
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr
.
.de doc-do-2
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-3 macro
.\" NS   call .No if punctuation suffix
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr
.
.de doc-do-3
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-4 macro
.\" NS   call .No if punctuation prefix
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr
.
.de doc-do-4
.  nr doc-arg-ptr -1
.  No
..
.
.
.\" NS doc-do-xref-1 macro
.\" NS   ignore if macro
.
.de doc-do-xref-1
..
.
.
.\" NS doc-do-xref-2 macro
.\" NS   ignore if string
.
.de doc-do-xref-2
..
.
.
.\" NS doc-do-xref-3 macro
.\" NS   append if punctuation suffix
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string
.
.de doc-do-xref-3
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.  nr doc-arg-ptr +1
.  \" XXX: ?
.  n\\C\\n(aP
..
.
.
.\" NS doc-do-xref-4 macro
.\" NS   append if punctuation prefix
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string
.
.de doc-do-xref-4
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.  nr doc-arg-ptr +1
.  \" XXX: ?
.  n\\C\\n(aP
..
.
.
.\" NS doc-curr-font-for-Ef global register
.\" NS   saved current font from `Bf' request
.
.nr doc-curr-font-for-Ef 0
.
.
.\" NS doc-curr-size-for-Ef global register
.\" NS   saved current size from `Bf' request
.
.nr doc-curr-size-for-Ef 0
.
.
.\" NS Bf user macro
.\" NS   begin font mode (will be begin-mode/end-mode in groff & TeX)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-curr-font-for-Ef, doc-curr-size-for-Ef
.\" NS
.\" NS width register `Bf' set in doc-common
.
.de Bf
.  ds doc-macro-name Bf
.
.  ie \n[.$] \{\
.    nr doc-curr-font-for-Ef \n[.f]
.    nr doc-curr-size-for-Ef \n[.s]
.
.    ie        "\$1"Em" \
.      nop \*[doc-Em-font]\c
.    el \{ .ie "\$1"Li" \
.      nop \*[doc-Li-font]\c
.    el \{ .ie "\$1"Sy" \
.      nop \*[doc-Sy-font]\c
.    el \{ .ie "\$1"-emphasis" \
.      nop \*[doc-Em-font]\c
.    el \{ .ie "\$1"-literal" \
.      nop \*[doc-Li-font]\c
.    el \{ .ie "\$1"-symbolic" \
.      nop \*[doc-Sy-font]\c
.    el \{\
.      tmc mdoc warning: Unknown keyword `\$1' in .Bf request
.      tm1 " (#\n[.c])
.  \}\}\}\}\}\}\}
.  el \
.    tm Usage .Bf [Em | -emphasis | Li | -literal | Sy | -symbolic] (#\n[.c])
..
.
.
.\" NS Ef user macro
.\" NS   end font mode
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name
.\" NS
.\" NS width register `Ef' set in doc-common
.
.de Ef
.  ds doc-macro-name Ef
.
.  ie \n[.$] \
.    tm Usage .Ef (does not take arguments) (#\n[.c])
.  el \
.    nop \&\f[\n[doc-curr-font-for-Ef]]\s[\n[doc-curr-size-for-Ef]]
..
.
.
.\" NS doc-keep-type global string
.\" NS   current keep type
.
.ds doc-keep-type
.
.
.\" NS Bk user macro
.\" NS   begin keep
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-keep-type
.\" NS
.\" NS width register `Bk' set in doc-common
.
.de Bk
.  ds doc-keep-type
.
.  ds doc-macro-name Bk
.
.  ie \n[.$] \{\
.    if !"\*[doc-keep-type]"" \
.      tm .Bk: nesting keeps not implemented yet. (#\n[.c])
.    ie "\$1"-lines" \
.      tm .Bk -lines: Not implemented yet. (#\n[.c])
.    el \{\
.      ie "\$1"-words" \
.        doc-set-hard-space
.      el \
.        tm mdoc warning: Unknown keyword `\$1' in .Bk request (#\n[.c])
.    \}
.
.    ds doc-keep-type \$1
.  \}
.  el \
.    tm Usage: .Bk [-lines | -words] (#\n[.c])
..
.
.
.\" NS Ek user macro
.\" NS   end keep
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name
.\" NS
.\" NS width register `Ek' set in doc-common
.
.de Ek
.  ds doc-macro-name Ek
.
.  ie \n[.$] \
.    tm Usage .Ek (does not take arguments) (#\n[.c])
.  el \{\
.    ie "\*[doc-keep-type]"-words" \
.      doc-set-soft-space
.    el \
.      tm .Bk -lines: Not implemented yet. (#\n[.c])
.  \}
..
.
.
.\" NS doc-display-depth global register
.\" NS   display level
.
.nr doc-display-depth 0
.
.
.\" NS doc-is-compact global register (bool)
.\" NS   set if the `compact' keyword is given
.
.nr doc-is-compact 0
.
.
.\" NS doc-display-type-stackXXX global string
.\" NS   the display type stack
.\" NS
.\" NS   limit: doc-display-depth
.
.ds doc-display-type-stack0
.
.
.\" NS doc-display-indent-stackXXX global register
.\" NS   stack of display indentation values
.\" NS
.\" NS   limit: doc-display-depth
.
.nr doc-display-indent-stack0 0
.
.
.\" NS Bd user macro
.\" NS   begin display
.\" NS
.\" NS width register `Bd' set in doc-common
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-curr-font, doc-curr-size, doc-display-depth,
.\" NS   doc-is-compact, doc-display-type-stackXXX,
.\" NS   doc-display-indent-stackXXX
.\" NS
.\" NS local variables:
.\" NS   doc-reg-Bd
.
.de Bd
.  ds doc-macro-name Bd
.
.  ie \n[.$] \{\
.    nr doc-is-compact 0
.    nr doc-reg-Bd 1
.    nr doc-display-depth +1
.
.    ie        "\$1"-literal" \{\
.      ds doc-display-type-stack\n[doc-display-depth] literal
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.
.      ie t \{\
.        nop \*[doc-Li-font]\c
'        ta T 9n
.      \}
.      el \
'        ta T 8n
.      nf
.    \}
.    el \{ .ie "\$1"-filled" \{\
.      ds doc-display-type-stack\n[doc-display-depth] filled
.      br
.    \}
.    el \{ .ie "\$1"-ragged" \{\
.      ds doc-display-type-stack\n[doc-display-depth] ragged
.      na
.    \}
.    el \{ .ie "\$1"-unfilled" \{\
.      ds doc-display-type-stack\n[doc-display-depth] unfilled
.      nf
.    \}
.    el \{\
.      tm mdoc warning: Unknown keyword `\$1' in .Bd request (#\n[.c])
.      nr doc-reg-Bd 0
.    \}\}\}\}
.
.    \" have we seen an argument?
.    if \n[doc-reg-Bd] \{\
.      shift
.      \" check other arguments
.      if \n[.$] \
.        doc-do-Bd-args \$@
.    \}
.
.    \" avoid warning about non-existent register
.    if !r doc-display-indent-stack\n[doc-display-depth] \
.      nr doc-display-indent-stack\n[doc-display-depth] 0
.
.    if \n[doc-display-indent-stack\n[doc-display-depth]] \
'      in +\n[doc-display-indent-stack\n[doc-display-depth]]u
.
.    if !\n[doc-is-compact] \{\
.      if !\n[doc-in-synopsis-count] \{\
.        ie "\*[doc-display-type-stack\n[doc-display-depth]]"ragged" \
.          sp \n[doc-display-vertical]u
.        el \
'          sp \n[doc-display-vertical]u
.    \}\}
.
.    if !\n[cR] \
.      ne 2v
.
.    nr doc-is-compact 0
.  \}
.  el \{\
.    tm1 "Usage: .Bd [-literal | -filled | -ragged | -unfilled]
.    tm1 "           [-offset [string]] [-compact] (#\n[.c])
.  \}
..
.
.
.\" NS doc-do-Bd-args macro
.\" NS   resolve remaining .Bd arguments
.\" NS
.\" NS modifies:
.\" NS   doc-is-compact, doc-display-indent-stackXXX
.\" NS
.\" NS local variables:
.\" NS   doc-str-ddBa, doc-reg-ddBa
.
.de doc-do-Bd-args
.  nr doc-reg-ddBa 1
.  ds doc-str-ddBa
.
.  ie        "\$1"-offset" \{\
.    ds doc-str-ddBa "\$2
.    nr doc-reg-ddBa 2
.
.    ie        "\$2"left" \
.      nr doc-display-indent-stack\n[doc-display-depth] 0
.    el \{ .ie "\$2"right" \
.      nr doc-display-indent-stack\n[doc-display-depth] (\n[.l]u / 3u)
.    el \{ .ie "\$2"center" \
.      nr doc-display-indent-stack\n[doc-display-depth] ((\n[.l]u - \n[.i]u) / 4u)
.    el \{ .ie "\$2"indent" \
.      nr doc-display-indent-stack\n[doc-display-depth] \n[doc-display-indent]u
.    el \{ .ie "\$2"indent-two" \
.      nr doc-display-indent-stack\n[doc-display-depth] (\n[doc-display-indent]u + \n[doc-display-indent]u)
.    el \
.      nr doc-reg-ddBa 1
.    \}\}\}\}
.
.    \" not a known keyword
.    if (\n[doc-reg-ddBa] == 1) \{\
.      nr doc-reg-ddBa 2
.      \" test whether argument is a valid numeric expression
.      ie \B\$2 \
.        nr doc-display-indent-stack\n[doc-display-depth] \$2
.      el \{\
.        doc-get-width "\$2"
.        ie (\n[doc-width] == 2) \{\
.          \" if the offset parameter is a macro, use the macro's
.          \" width as specified in doc-common
.          doc-get-arg-type "\$2"
.          ie (\n[doc-arg-type] == 1) \
.            nr doc-display-indent-stack\n[doc-display-depth] \n[\$2]
.          el \
.            nr doc-display-indent-stack\n[doc-display-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.        \}
.        el \
.          nr doc-display-indent-stack\n[doc-display-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.    \}\}
.  \}
.  el \{ .ie "\$1"-compact" \
.    nr doc-is-compact 1
.  el \
.      tm mdoc warning: Unknown keyword `\$1' in .Bd request (#\n[.c])
.  \}
.
.  if (\n[doc-reg-ddBa] < \n[.$]) \{\
.    \" have we seen `-offset' or `-compact'?
.    ie "\*[doc-str-ddBa]"" \{\
.      shift
.      doc-do-Bd-args \$@
.    \}
.    el \{\
.      shift 2
.      doc-do-Bd-args \$@
.  \}\}
..
.
.
.\" NS Ed user macro
.\" NS   end display
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-display-depth, doc-display-type-stackXXX,
.\" NS   doc-display-indent-stackXXX
.\" NS
.\" NS width register `Ed' set in doc-common
.
.de Ed
.  ds doc-macro-name Ed
.
.  br
.
.  if !\n[doc-display-depth] \
.    tm mdoc warning: Extraneous .Ed (#\n[.c])
.
.  if "\*[doc-display-type-stack\n[doc-display-depth]]"literal" \{\
.    ft \n[doc-curr-font]
.    ps \n[doc-curr-size]
.  \}
.
.  in -\n[doc-display-indent-stack\n[doc-display-depth]]u
.
.  nr doc-display-indent-stack\n[doc-display-depth] 0
.  ds doc-display-type-stack\n[doc-display-depth]
.  nr doc-display-depth -1
.
.  fi
.  if t \
.    ad
..
.
.
.\" NS doc-list-type-stackXXX global string
.\" NS   stack of list types
.\" NS
.\" NS   limit: doc-list-depth
.
.ds doc-list-type-stack1
.
.
.\" NS doc-list-indent-stackXXX global register
.\" NS   stack of list indentation values
.\" NS
.\" NS   limit: doc-list-depth
.
.nr doc-list-indent-stack1 0
.
.
.\" NS doc-have-indent global register (bool)
.\" NS   an indentation value is active
.
.nr doc-have-indent 0
.
.
.\" NS Bl user macro
.\" NS   begin list
.\" NS
.\" NS width register `Bl' set in doc-common
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-num-args, doc-arg-ptr, doc-argXXX,
.\" NS   doc-list-type-stackXXX, doc-list-indent-stackXXX, doc-have-indent,
.\" NS   doc-have-diag-list, doc-num-columns, doc-list-depth
.\" NS
.\" NS local variables:
.\" NS   doc-reg-Bl
.
.de Bl
.  ie \n[.$] \{\
.    ds doc-macro-name Bl
.    nr doc-list-depth +1
.    nr doc-arg-ptr 1
.
.    ie        "\$1"-hang" \{\
.      ds doc-list-type-stack\n[doc-list-depth] hang-list
.      nr doc-list-indent-stack\n[doc-list-depth] 6n
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-tag" \{\
.      ds doc-list-type-stack\n[doc-list-depth] tag-list
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-item" \{\
.      ds doc-list-type-stack\n[doc-list-depth] item-list
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-enum" \{\
.      ds doc-list-type-stack\n[doc-list-depth] enum-list
.      nr doc-list-indent-stack\n[doc-list-depth] 3n
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-bullet" \{\
.      ds doc-list-type-stack\n[doc-list-depth] bullet-list
.      nr doc-list-indent-stack\n[doc-list-depth] 2n
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-dash" \{\
.      ds doc-list-type-stack\n[doc-list-depth] dash-list
.      nr doc-list-indent-stack\n[doc-list-depth] 2n
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-hyphen" \{\
.      ds doc-list-type-stack\n[doc-list-depth] dash-list
.      nr doc-list-indent-stack\n[doc-list-depth] 2n
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-inset" \{\
.      ds doc-list-type-stack\n[doc-list-depth] inset-list
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-diag" \{\
.      ds doc-list-type-stack\n[doc-list-depth] diag-list
.      nr doc-have-diag-list 1
.    \}
.    el \{ .ie "\$1"-ohang" \{\
.      ds doc-list-type-stack\n[doc-list-depth] ohang-list
.      nr doc-have-indent 1
.    \}
.    el \{ .ie "\$1"-column" \
.      ds doc-list-type-stack\n[doc-list-depth] column-list
.    el \{\
.      tm mdoc warning: Unknown list type `\$1' in .Bl request
.      tm
.      nr doc-arg-ptr 0
.    \}\}\}\}\}\}\}\}\}\}\}
.
.    \" we have seen a list type
.    ie \n[doc-arg-ptr] \{\
.      shift
.
.      \" fill argument vector
.      nr doc-reg-Bl 1
.      while (\n[doc-reg-Bl] <= \n[.$]) \{\
.        ds doc-arg\n[doc-reg-Bl] "\$[\n[doc-reg-Bl]]
.        nr doc-reg-Bl +1
.      \}
.
.      doc-increment-list-stack
.
.      if \n[.$] \{\
.        nr doc-arg-limit \n[.$]
.        nr doc-arg-ptr 0
.        doc-do-Bl-args
.
.        \" initialize column list
.        if "\*[doc-list-type-stack\n[doc-list-depth]]"column-list" \{\
.          doc-set-column-tab \n[doc-num-columns]
.          nr doc-list-indent-stack\n[doc-list-depth] 0
'          in -\n[doc-column-indent-width]u
.          if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.            sp \n[doc-display-vertical]u
.
.          nf
.          nr doc-num-columns 0
.    \}\}\}
.    el \
.      doc-Bl-usage
.
.    doc-reset-args
.  \}
.  el \
.    doc-Bl-usage
..
.
.
.\" NS doc-Bl-usage macro
.
.de doc-Bl-usage
.  tm1 "Usage: .Bl [-hang | -ohang | -tag | -diag | -inset]
.  tm1 "             [-width [string]] [-offset [string]] [-compact]
.  tm1 "       .Bl [-column] [-offset [string]] [string1] [string2] ...
.  tm1 "       .Bl [-item | -enum | -bullet | -hyphen | -dash]
.  tm1 "             [-offset [string]] [-compact] (#\n[.c])
..
.
.
.\" NS doc-have-tag-width global macro
.\" NS   set if a tag width has been explicitly given
.
.nr doc-have-tag-width 0
.
.
.\" NS doc-do-Bl-args macro
.\" NS   resolve remaining .Bl arguments
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-argXXX, doc-list-indent-stackXXX, doc-num-columns,
.\" NS   doc-compact-list-stackXXX, doc-have-tag-width,
.\" NS   doc-tag-width-stackXXX, doc-list-offset-stackXXX
.\" NS
.\" NS local variables:
.\" NS   doc-str-dBla, doc-reg-dBla
.
.de doc-do-Bl-args
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-reg-dBla 1
.
.    ie        "\*[doc-arg\n[doc-arg-ptr]]"-compact" \
.      nr doc-compact-list-stack\n[doc-list-depth] 1
.    el \{ .ie "\*[doc-arg\n[doc-arg-ptr]]"-width" \{\
.      nr doc-arg-ptr +1
.      \" XXX: this code should be modified to handle nested lists
.      \"      of any type
.      nr doc-have-tag-width 1
.      ds doc-tag-width-stack\n[doc-list-depth] TagwidtH
.      ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
.
.      \" test whether argument is a valid numeric expression
.      ie \B\*[doc-str-dBla] \
.        nr doc-list-indent-stack\n[doc-list-depth] \*[doc-str-dBla]
.      el \{\
.        doc-get-arg-width \n[doc-arg-ptr]
.        ie (\n[doc-width] == 2) \{\
.          \" if the width parameter is a macro, use the macro's
.          \" width as specified in doc-common
.          doc-get-arg-type \*[doc-str-dBla]
.          ie (\n[doc-arg-type] == 1) \
.            nr doc-list-indent-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
.          el \
.            nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.        \}
.        el \
.          nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.    \}\}
.    el \{ .ie "\*[doc-arg\n[doc-arg-ptr]]"-xwidth" \{\
.      nr doc-arg-ptr +1
.      \" XXX: this code should be modified to handle nested lists
.      \"      of any type
.      nr doc-have-tag-width 1
.      ds doc-tag-width-stack\n[doc-list-depth] TagwidtH
.
.      ds doc-str-dBla \*[doc-arg\n[doc-arg-ptr]]
.      substring doc-str-dBla 1 2
.      if .\*[doc-str-dBla] \{\
.        doc-save-global-vars
.        nr doc-in-diversion 0
.        nr doc-nesting-level 0
.        ds doc-out-string
.        doc-dry-execute "\*[doc-arg\n[doc-arg-ptr]]"
.        \" save doc-out-string
.        ds doc-str-dBla "\*[doc-out-string]
.        doc-restore-global-vars
.        doc-get-width "\*[doc-str-dBla]"
.      \}
.      nr doc-list-indent-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.    \}
.    el \{ .ie "\*[doc-arg\n[doc-arg-ptr]]"-offset" \{\
.      nr doc-arg-ptr +1
.
.      ie "\*[doc-arg\n[doc-arg-ptr]]"indent" \
.        nr doc-list-offset-stack\n[doc-list-depth] \n[doc-display-indent]u
.      el \{\
.        ds doc-str-dBla "\*[doc-arg\n[doc-arg-ptr]]
.
.        ie \B\*[doc-str-dBla] \
.          nr doc-list-offset-stack\n[doc-list-depth] \*[doc-str-dBla]
.        el \{\
.          doc-get-arg-width \n[doc-arg-ptr]
.          ie (\n[doc-width] == 2) \{\
.            doc-get-arg-type \*[doc-str-dBla]
.            ie (\n[doc-arg-type] == 1) \
.              nr doc-list-offset-stack\n[doc-list-depth] \n[\*[doc-str-dBla]]
.            el \
.              nr doc-list-offset-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.          \}
.          el \
.            nr doc-list-offset-stack\n[doc-list-depth] (\n[doc-width]u * \n[doc-fixed-width]u)
.    \}\}\}
.    el \
.      nr doc-reg-dBla 0
.    \}\}\}
.
.    \" not a known keyword, so it specifies the width of the next column
.    \" (if it is a column list)
.    if !\n[doc-reg-dBla] \{\
.      ie "\*[doc-list-type-stack\n[doc-list-depth]]"column-list" \{\
.        nr doc-num-columns +1
.        ds doc-arg\n[doc-num-columns] "\*[doc-arg\n[doc-arg-ptr]]
.      \}
.      el \{\
.        tmc mdoc warning: Unknown keyword `\*[doc-arg\n[doc-arg-ptr]]'
.        tm1 " in .Bl request (#\n[.c])
.    \}\}
.
.    if (\n[doc-arg-limit] > \n[doc-arg-ptr]) \
.      doc-do-Bl-args
.  \}
..
.
.
.\" NS doc-save-global-vars macro
.\" NS   save all global variables
.\" NS
.\" NS local variables:
.\" NS   doc-reg-dsgv
.
.de doc-save-global-vars
.  nr doc-debug-saved \n[doc-debug]
.  ds doc-macro-name-saved "\*[doc-macro-name]
.  nr doc-arg-limit-saved \n[doc-arg-limit]
.  nr doc-num-args-saved \n[doc-num-args]
.  nr doc-arg-ptr-saved \n[doc-arg-ptr]
.
.  nr doc-reg-dsgv 1
.  while (\n[doc-reg-dsgv] <= \n[doc-arg-limit]) \{\
.    ds doc-arg\n[doc-reg-dsgv]-saved "\*[doc-arg\n[doc-reg-dsgv]]
.    nr doc-type\n[doc-reg-dsgv]-saved \n[doc-type\n[doc-reg-dsgv]]
.    ds doc-space\n[doc-reg-dsgv]-saved "\*[doc-space\n[doc-reg-dsgv]]
.    nr doc-reg-dsgv +1
.  \}
.
.  ds doc-out-string-saved "\*[doc-out-string]
.  ds doc-curr-space-saved "\*[doc-curr-space]
.  ds doc-saved-out-string-saved "\*[doc-saved-out-string]
.  nr doc-in-diversion-saved \n[doc-in-diversion]
.  nr doc-curr-font-saved \n[doc-curr-font]
.  nr doc-curr-size-saved \n[doc-curr-size]
.  nr doc-in-synopsis-count-saved \n[doc-in-synopsis-count]
.  nr doc-indent-synopsis-saved \n[doc-indent-synopsis]
.  nr doc-have-decl-saved \n[doc-have-decl]
.  nr doc-have-var-saved \n[doc-have-var]
.  ds doc-command-name-saved "\*[doc-command-name]
.  ds doc-quote-left-saved "\*[doc-quote-left]
.  ds doc-quote-right-saved "\*[doc-quote-right]
.  nr doc-nesting-level-saved \n[doc-nesting-level]
.  ds doc-saved-list-type-saved "\*[doc-saved-list-type]
.  ds doc-space-saved "\*[doc-space]
.  nr doc-space-mode-saved \n[doc-space-mode]
.  nr doc-curr-font-for-Ef-saved \n[doc-curr-font-for-Ef]
.  nr doc-curr-size-for-Ef-saved \n[doc-curr-size-for-Ef]
.  ds doc-keep-type-saved "\*[doc-keep-type]
.  nr doc-display-depth-saved \n[doc-display-depth]
.  nr doc-is-compact-saved \n[doc-is-compact]
.
.  nr doc-reg-dsgv 0
.  while (\n[doc-reg-dsgv] <= \n[doc-display-depth]) \{\
.    ds doc-display-type-stack\n[doc-reg-dsgv]-saved "\*[doc-display-type-stack\n[doc-reg-dsgv]]
.    nr doc-display-indent-stack\n[doc-reg-dsgv]-saved \n[doc-display-indent-stack\n[doc-reg-dsgv]]
.    nr doc-reg-dsgv +1
.  \}
.
.  nr doc-list-depth-saved \n[doc-list-depth]
.
.  nr doc-reg-dsgv 1
.  while (\n[doc-reg-dsgv] <= \n[doc-list-depth]) \{\
.    ds doc-list-type-stack\n[doc-reg-dsgv]-saved "\*[doc-list-type-stack\n[doc-reg-dsgv]]
.    nr doc-list-indent-stack\n[doc-reg-dsgv]-saved \n[doc-list-indent-stack\n[doc-reg-dsgv]]
.    nr doc-compact-list-stack\n[doc-reg-dsgv]-saved \n[doc-compact-list-stack\n[doc-reg-dsgv]]
.    ds doc-tag-width-stack\n[doc-reg-dsgv]-saved "\*[doc-tag-width-stack\n[doc-reg-dsgv]]
.    nr doc-list-offset-stack\n[doc-reg-dsgv]-saved \n[doc-list-offset-stack\n[doc-reg-dsgv]]
.    nr doc-reg-dsgv +1
.  \}
.
.  nr doc-have-indent-saved \n[doc-have-indent]
.  nr doc-have-tag-width-saved \n[doc-have-tag-width]
.  nr doc-no-printing-saved \n[doc-no-printing]
.  ds doc-saved-Pa-font-saved "\*[doc-saved-Pa-font]
.  nr doc-curr-type-saved \n[doc-curr-type]
.  ds doc-curr-arg-saved "\*[doc-curr-arg]
.  nr doc-enum-list-count-saved \n[doc-enum-list-count]
.  nr doc-have-diag-list-saved \n[doc-have-diag-list]
.  nr doc-diag-list-input-line-count-saved \n[doc-diag-list-input-line-count]
.  nr doc-saved-list-immediate-saved \n[doc-saved-list-immediate]
.  nr doc-list-immediate-saved \n[doc-list-immediate]
.  nr doc-num-columns-saved \n[doc-num-columns]
.  nr doc-next-list-depth-saved \n[doc-next-list-depth]
.  nr doc-column-indent-width-saved \n[doc-column-indent-width]
.  nr doc-is-func-saved \n[doc-is-func]
.  nr doc-have-old-func-saved \n[doc-have-old-func]
.  nr doc-func-arg-count-saved \n[doc-func-arg-count]
.  ds doc-func-arg-saved "\*[doc-func-arg]
.  nr doc-num-func-args-saved \n[doc-num-func-args]
.  nr doc-func-args-processed-saved \n[doc-func-args-processed]
.  nr doc-have-func-saved \n[doc-have-func]
.  nr doc-is-reference-saved \n[doc-is-reference]
.  nr doc-reference-count-saved \n[doc-reference-count]
.  ds doc-reference-string-name-saved "\*[doc-reference-string-name]
.  nr doc-authors-processed-saved \n[doc-authors-processed]
.  nr doc-author-count-saved \n[doc-author-count]
.
.  nr doc-reg-dsgv 0
.  while (\n[doc-reg-dsgv] <= \n[doc-author-count]) \{\
.    ds doc-author-name\n[doc-reg-dsgv]-saved "\*[doc-author-name\n[doc-reg-dsgv]]
.    nr doc-reg-dsgv +1
.  \}
.
.  nr doc-book-count-saved \n[doc-book-count]
.  ds doc-book-name-saved "\*[doc-book-name]
.  nr doc-date-count-saved \n[doc-date-count]
.  ds doc-date-saved "\*[doc-date]
.  nr doc-publisher-count-saved \n[doc-publisher-count]
.  ds doc-publisher-name-saved "\*[doc-publisher-name]
.  nr doc-journal-count-saved \n[doc-journal-count]
.  ds doc-journal-name-saved "\*[doc-journal-name]
.  nr doc-issue-count-saved \n[doc-issue-count]
.  ds doc-issue-name-saved "\*[doc-issue-name]
.  nr doc-optional-count-saved \n[doc-optional-count]
.  ds doc-optional-string-saved "\*[doc-optional-string]
.  nr doc-page-number-count-saved \n[doc-page-number-count]
.  ds doc-page-number-string-saved "\*[doc-page-number-string]
.  nr doc-corporate-count-saved \n[doc-corporate-count]
.  ds doc-corporate-name-saved "\*[doc-corporate-name]
.  nr doc-report-count-saved \n[doc-report-count]
.  ds doc-report-name-saved "\*[doc-report-name]
.  nr doc-reference-title-count-saved \n[doc-reference-title-count]
.  ds doc-reference-title-name-saved "\*[doc-reference-title-name]
.  nr doc-volume-count-saved \n[doc-volume-count]
.  ds doc-volume-name-saved "\*[doc-volume-name]
.  nr doc-have-author-saved \n[doc-have-author]
.
.  ds doc-document-title-saved "\*[doc-document-title]
.  ds doc-volume-saved "\*[doc-volume]
.  ds doc-section-saved "\*[doc-section]
.  ds doc-operating-system-saved "\*[doc-operating-system]
.  ds doc-date-string-saved "\*[doc-date-string]
.  nr doc-header-space-saved \n[doc-header-space]
.  nr doc-footer-space-saved \n[doc-footer-space]
.  nr doc-display-vertical-saved \n[doc-display-vertical]
.  ds doc-header-string-saved "\*[doc-header-string]
.  nr doc-in-see-also-section-saved \n[doc-in-see-also-section]
.  nr doc-in-files-section-saved \n[doc-in-files-section]
.  nr doc-in-authors-section-saved \n[doc-in-authors-section]
..
.
.
.\" NS doc-restore-global-vars macro
.\" NS   restore all global variables
.\" NS
.\" NS local variables:
.\" NS   doc-reg-drgv
.
.de doc-restore-global-vars
.  nr doc-debug \n[doc-debug-saved]
.  ds doc-macro-name "\*[doc-macro-name-saved]
.  nr doc-arg-limit \n[doc-arg-limit-saved]
.  nr doc-num-args \n[doc-num-args-saved]
.  nr doc-arg-ptr \n[doc-arg-ptr-saved]
.
.  nr doc-reg-drgv 1
.  while (\n[doc-reg-drgv] <= \n[doc-arg-limit]) \{\
.    ds doc-arg\n[doc-reg-drgv] "\*[doc-arg\n[doc-reg-drgv]-saved]
.    nr doc-type\n[doc-reg-drgv] \n[doc-type\n[doc-reg-drgv]-saved]
.    ds doc-space\n[doc-reg-drgv] "\*[doc-space\n[doc-reg-drgv]-saved]
.    nr doc-reg-drgv +1
.  \}
.
.  ds doc-out-string "\*[doc-out-string-saved]
.  ds doc-curr-space "\*[doc-curr-space-saved]
.  ds doc-saved-out-string "\*[doc-saved-out-string-saved]
.  nr doc-in-diversion \n[doc-in-diversion-saved]
.  nr doc-curr-font \n[doc-curr-font-saved]
.  nr doc-curr-size \n[doc-curr-size-saved]
.  nr doc-in-synopsis-count \n[doc-in-synopsis-count-saved]
.  nr doc-indent-synopsis \n[doc-indent-synopsis-saved]
.  nr doc-have-decl \n[doc-have-decl-saved]
.  nr doc-have-var \n[doc-have-var-saved]
.  ds doc-command-name "\*[doc-command-name-saved]
.  ds doc-quote-left "\*[doc-quote-left-saved]
.  ds doc-quote-right "\*[doc-quote-right-saved]
.  nr doc-nesting-level \n[doc-nesting-level-saved]
.  ds doc-saved-list-type "\*[doc-saved-list-type-saved]
.  ds doc-space "\*[doc-space-saved]
.  nr doc-space-mode \n[doc-space-mode-saved]
.  nr doc-curr-font-for-Ef \n[doc-curr-font-for-Ef-saved]
.  nr doc-curr-size-for-Ef \n[doc-curr-size-for-Ef-saved]
.  ds doc-keep-type "\*[doc-keep-type-saved]
.  nr doc-display-depth \n[doc-display-depth-saved]
.  nr doc-is-compact \n[doc-is-compact-saved]
.
.  nr doc-reg-drgv 0
.  while (\n[doc-reg-drgv] <= \n[doc-display-depth]) \{\
.    ds doc-display-type-stack\n[doc-reg-drgv] "\*[doc-display-type-stack\n[doc-reg-drgv]-saved]
.    nr doc-display-indent-stack\n[doc-reg-drgv] \n[doc-display-indent-stack\n[doc-reg-drgv]-saved]
.    nr doc-reg-drgv +1
.  \}
.
.  nr doc-list-depth \n[doc-list-depth-saved]
.
.  nr doc-reg-drgv 1
.  while (\n[doc-reg-drgv] <= \n[doc-list-depth]) \{\
.    ds doc-list-type-stack\n[doc-reg-drgv] "\*[doc-list-type-stack\n[doc-reg-drgv]-saved]
.    nr doc-list-indent-stack\n[doc-reg-drgv] \n[doc-list-indent-stack\n[doc-reg-drgv]-saved]
.    nr doc-compact-list-stack\n[doc-reg-drgv] \n[doc-compact-list-stack\n[doc-reg-drgv]-saved]
.    ds doc-tag-width-stack\n[doc-reg-drgv] "\*[doc-tag-width-stack\n[doc-reg-drgv]-saved]
.    nr doc-list-offset-stack\n[doc-reg-drgv] \n[doc-list-offset-stack\n[doc-reg-drgv]-saved]
.    nr doc-reg-drgv +1
.  \}
.
.  nr doc-have-indent \n[doc-have-indent-saved]
.  nr doc-have-tag-width \n[doc-have-tag-width-saved]
.  nr doc-no-printing \n[doc-no-printing-saved]
.  ds doc-saved-Pa-font "\*[doc-saved-Pa-font-saved]
.  nr doc-curr-type \n[doc-curr-type-saved]
.  ds doc-curr-arg "\*[doc-curr-arg-saved]
.  nr doc-enum-list-count \n[doc-enum-list-count-saved]
.  nr doc-have-diag-list \n[doc-have-diag-list-saved]
.  nr doc-diag-list-input-line-count \n[doc-diag-list-input-line-count-saved]
.  nr doc-saved-list-immediate \n[doc-saved-list-immediate-saved]
.  nr doc-list-immediate \n[doc-list-immediate-saved]
.  nr doc-num-columns \n[doc-num-columns-saved]
.  nr doc-next-list-depth \n[doc-next-list-depth-saved]
.  nr doc-column-indent-width \n[doc-column-indent-width-saved]
.  nr doc-is-func \n[doc-is-func-saved]
.  nr doc-have-old-func \n[doc-have-old-func-saved]
.  nr doc-func-arg-count \n[doc-func-arg-count-saved]
.  ds doc-func-arg "\*[doc-func-arg-saved]
.  nr doc-num-func-args \n[doc-num-func-args-saved]
.  nr doc-func-args-processed \n[doc-func-args-processed-saved]
.  nr doc-have-func \n[doc-have-func-saved]
.  nr doc-is-reference \n[doc-is-reference-saved]
.  nr doc-reference-count \n[doc-reference-count-saved]
.  ds doc-reference-string-name "\*[doc-reference-string-name-saved]
.  nr doc-authors-processed \n[doc-authors-processed-saved]
.  nr doc-author-count \n[doc-author-count-saved]
.
.  nr doc-reg-drgv 0
.  while (\n[doc-reg-drgv] <= \n[doc-author-count]) \{\
.    ds doc-author-name\n[doc-reg-drgv] "\*[doc-author-name\n[doc-reg-drgv]-saved]
.    nr doc-reg-drgv +1
.  \}
.
.  nr doc-book-count \n[doc-book-count-saved]
.  ds doc-book-name "\*[doc-book-name-saved]
.  nr doc-date-count \n[doc-date-count-saved]
.  ds doc-date "\*[doc-date-saved]
.  nr doc-publisher-count \n[doc-publisher-count-saved]
.  ds doc-publisher-name "\*[doc-publisher-name-saved]
.  nr doc-journal-count \n[doc-journal-count-saved]
.  ds doc-journal-name "\*[doc-journal-name-saved]
.  nr doc-issue-count \n[doc-issue-count-saved]
.  ds doc-issue-name "\*[doc-issue-name-saved]
.  nr doc-optional-count \n[doc-optional-count-saved]
.  ds doc-optional-string "\*[doc-optional-string-saved]
.  nr doc-page-number-count \n[doc-page-number-count-saved]
.  ds doc-page-number-string "\*[doc-page-number-string-saved]
.  nr doc-corporate-count \n[doc-corporate-count-saved]
.  ds doc-corporate-name "\*[doc-corporate-name-saved]
.  nr doc-report-count \n[doc-report-count-saved]
.  ds doc-report-name "\*[doc-report-name-saved]
.  nr doc-reference-title-count \n[doc-reference-title-count-saved]
.  ds doc-reference-title-name "\*[doc-reference-title-name-saved]
.  nr doc-volume-count \n[doc-volume-count-saved]
.  ds doc-volume-name "\*[doc-volume-name-saved]
.  nr doc-have-author \n[doc-have-author-saved]
.
.  ds doc-document-title "\*[doc-document-title-saved]
.  ds doc-volume "\*[doc-volume-saved]
.  ds doc-section "\*[doc-section-saved]
.  ds doc-operating-system "\*[doc-operating-system-saved]
.  ds doc-date-string "\*[doc-date-string-saved]
.  nr doc-header-space \n[doc-header-space-saved]
.  nr doc-footer-space \n[doc-footer-space-saved]
.  nr doc-display-vertical \n[doc-display-vertical-saved]
.  ds doc-header-string "\*[doc-header-string-saved]
.  nr doc-in-see-also-section \n[doc-in-see-also-section-saved]
.  nr doc-in-files-section \n[doc-in-files-section-saved]
.  nr doc-in-authors-section \n[doc-in-authors-section-saved]
..
.
.
.\" NS doc-no-printing global register (bool)
.\" NS   set if output is suppressed
.
.nr doc-no-printing 0
.
.
.\" NS doc-dry-execute macro
.\" NS   execute a string (splitting one arg into multiple args) without
.\" NS   output; this command must be surrounded by `doc-save-global-args'
.\" NS   and `doc-restore-global-args'
.
.de doc-dry-execute
.  doc-reset-args
.  nr doc-no-printing 1
.  ds doc-str-de \$1
.  shift
.  nop \*[doc-str-de] \$@
.  nr doc-no-printing 0
..
.
.
.\" NS El user macro
.\" NS   end list
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-have-diag-list, doc-enum-list-count,
.\" NS   doc-list-depth
.\" NS
.\" NS local variables:
.\" NS   doc-str-El
.\" NS
.\" NS width register `El' set in doc-common
.
.de El
.  ie \n[.$] \
.    tm Usage: .El (does not take arguments) (#\n[.c])
.  el \{\
.    ds doc-macro-name El
.    ds doc-str-El \*[doc-list-type-stack\n[doc-list-depth]]
.
.    ie        "\*[doc-str-El]"enum-list" \{\
.      nr doc-enum-list-count 0
.      doc-end-list 1
.    \}
.    el \{ .ie "\*[doc-str-El]"diag-list" \
.      nr doc-have-diag-list 0
.    el \{ .ie "\*[doc-str-El]"column-list" \
.      doc-do-end-column-list
.    el \{ .ie "\*[doc-str-El]"item-list" \
.      doc-end-list 0
.    el \{ .ie "\*[doc-str-El]"ohang-list" \
.      doc-end-list 0
.    el \{ .ie "\*[doc-str-El]"inset-list" \
.      doc-end-list 0
.    el \
.      doc-end-list 1
.    \}\}\}\}\}
.
.    br
.  \}
..
.
.
.\" NS doc-saved-Pa-font global string
.\" NS   saved doc-Pa-font string for section FILES (no underline if
.\" NS   nroff)
.
.ds doc-saved-Pa-font
.
.
.\" NS doc-curr-type global register
.\" NS   current argument type
.
.nr doc-curr-type 0
.
.
.\" NS doc-curr-arg global string
.\" NS   current argument
.
.ds doc-curr-arg
.
.
.\" NS It user macro
.\" NS   list item
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-num-args, doc-arg-ptr, doc-argXXX,
.\" NS   doc-out-string, doc-nesting-level, doc-list-immediate,
.\" NS   doc-saved-list-type, doc-saved-Pa-font, doc-curr-type,
.\" NS   doc-curr-arg
.\" NS
.\" NS width register `It' set in doc-common
.\" NS
.\" NS local variables:
.\" NS   doc-str-It, doc-reg-It
.
.de It
.  ds doc-str-It \*[doc-list-type-stack\n[doc-list-depth]]
.
.  if "\*[doc-str-It]"" \
.    tm mdoc error: .It without preceding .Bl (#\n[.c])
.
.  br
.  if !\n[cR] \
.    ne 3v
.
.  ie \n[.$] \{\
.    ds doc-macro-name It
.    ds doc-out-string
.
.    \" fill argument vector
.    nr doc-reg-It 1
.    while (\n[doc-reg-It] <= \n[.$]) \{\
.      ds doc-arg\n[doc-reg-It] "\$[\n[doc-reg-It]]
.      nr doc-reg-It +1
.    \}
.
.    nr doc-num-args \n[.$]
.    nr doc-arg-ptr 0
.    nr doc-reg-It 1
.
.    ie "\*[doc-str-It]"diag-list" \{\
.      doc-remaining-args
.      doc-diag-list
.      nr doc-reg-It 0
.    \}
.    el \{\
.      ie        "\*[doc-str-It]"column-list" \{\
.        ds doc-out-string
.        doc-column-list
.        nr doc-reg-It 0
.      \}
.      el \{ .ie "\*[doc-str-It]"tag-list" \
.        nr doc-reg-It 2
.      el \{ .ie "\*[doc-str-It]"hang-list" \
.        nr doc-reg-It 2
.      el \{ .ie "\*[doc-str-It]"ohang-list" \
.        nr doc-reg-It 2
.      el \{ .if "\*[doc-str-It]"inset-list" \
.        nr doc-reg-It 2
.    \}\}\}\}\}
.
.    if \n[doc-reg-It] \{\
.      ie (\n[doc-reg-It] == 2) \{\
.        \" handle remaining list types with arguments
.        doc-parse-arg-vector
.
.        nr doc-nesting-level +1
.        nr doc-list-immediate 1
.        nr doc-arg-ptr 1
.        nr doc-curr-type \n[doc-type1]
.        ds doc-curr-arg "\*[doc-arg1]
.
.        if \n[doc-in-files-section] \{\
.          ds doc-saved-Pa-font "\*[doc-Pa-font]
.          if n \
.            ds doc-Pa-font "\*[doc-No-font]
.        \}
.
.        ie (\n[doc-type1] == 1) \
.          \*[doc-arg1]
.        el \{\
.          nr doc-arg-ptr 0
.          No
.        \}
.
.        ie \n[doc-saved-list-immediate] \
.          ds doc-saved-list-type "\*[doc-str-It]
.        el \
.          doc-\*[doc-str-It]
.      \}
.      el \{\
.        tm1 "mdoc warning: .It requests in lists of type `\*[doc-str-It]'
.        tm1 "              don't take arguments (#\n[.c])
.        doc-\*[doc-str-It]
.  \}\}\}
.  el \
.    doc-\*[doc-str-It]
..
.
.
.\" NS doc-inset-list macro
.\" NS   .It item of list-type inset
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level, doc-list-immediate
.
.de doc-inset-list
.  doc-set-vertical-and-indent 0
.  br
.  nop \&\*[doc-out-string]
.
.  nr doc-nesting-level -1
.  nr doc-list-immediate 0
.  ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-hang-list macro
.\" NS   .It item of list-type hanging tag (as opposed to tagged)
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level, doc-list-immediate
.\" NS
.\" NS local variables:
.\" NS   doc-reg-dhl
.
.de doc-hang-list
.  doc-set-vertical-and-indent 1
.  nr doc-reg-dhl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-dhl]u
.
.  ie (\w\*[doc-out-string]u >= \n[doc-list-indent-stack\n[doc-list-depth]]u) \
.    nop \&\*[doc-out-string]
.  el \
.    nop \&\*[doc-out-string]\h'|\n[doc-reg-dhl]u'\c
.
.  nr doc-nesting-level -1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-ohang-list macro
.\" NS   .It item of list-type overhanging tag
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level, doc-list-immediate
.
.de doc-ohang-list
.  doc-set-vertical-and-indent 0
.  nop \&\*[doc-out-string]
.  br
.
.  nr doc-nesting-level -1
.  ds doc-out-string
.  nr doc-list-immediate 0
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-item-list macro
.\" NS   .It item of list-type [empty tag]
.
.de doc-item-list
.  doc-set-vertical-and-indent 0
.  br
.
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-enum-list-count global register
.\" NS   contains current enum count value
.
.nr doc-enum-list-count 0
.
.
.\" NS doc-enum-list macro
.\" NS   enumerated list
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level, doc-enum-list-count
.
.de doc-enum-list
.  nr doc-nesting-level +1
.  nr doc-enum-list-count +1
.  ds doc-out-string "\n[doc-enum-list-count].
.  doc-do-list
..
.
.
.\" NS doc-bullet-list macro
.\" NS   bullet paragraph list
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level
.
.de doc-bullet-list
.  nr doc-nesting-level +1
.  ds doc-out-string "\*[doc-Sy-font]\[bu]\f[P]
.  doc-do-list
..
.
.
.\" NS doc-dash-list macro
.\" NS   hyphen paragraph list (sub bullet list)
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level
.
.de doc-dash-list
.  nr doc-nesting-level +1
.  ds doc-out-string "\*[doc-Sy-font]\-\f[P]
.  doc-do-list
..
.
.
.\" NS doc-do-list macro
.\" NS   .It item of list-type enum/bullet/hyphen
.
.als doc-do-list doc-hang-list
.
.
.\" NS doc-have-diag-list global register (bool)
.\" NS   set if last item was a diag list
.
.\" XXX: this should be modified to handle nested lists of any type
.
.nr doc-have-diag-list 0
.
.
.\" NS doc-diag-list-input-line-count global register
.\" NS   saved line number to be checked in next diag-list item
.
.nr doc-diag-list-input-line-count 0
.
.
.\" NS doc-diag-list macro
.\" NS   .It item of list-type diagnostic-message
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-curr-font, doc-curr-size,
.\" NS   doc-diag-list-input-line-count
.
.de doc-diag-list
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  ie \n[doc-have-diag-list] \{\
.    ie ((\n[.c] - \n[doc-diag-list-input-line-count]) > 1) \
.      doc-paragraph
.    el \
.      br
.  \}
.  el \
.    br
.  nr doc-diag-list-input-line-count \n[.c]
.
.  nop \*[doc-Sy-font]\*[doc-out-string]\c
.  nop \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\*[doc-digit-string]\c
.
.  doc-reset-args
.  ds doc-out-string
'  fi
..
.
.
.\" NS doc-tag-list macro
.\" NS   .It item of list-type `tag'
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-nesting-level, doc-list-immediate
.\" NS
.\" NS local variables:
.\" NS   doc-reg-dtl
.
.de doc-tag-list
.  if !\n[doc-have-tag-width] \
.    doc-get-tag-width
.  doc-set-vertical-and-indent 1
.  nr doc-reg-dtl (\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  ti -\n[doc-reg-dtl]u
.
.  ie (\w\*[doc-out-string]u > \n[doc-list-indent-stack\n[doc-list-depth]]u) \{\
.    nop \&\*[doc-out-string]
.    br
.  \}
.  el \
.    nop \&\*[doc-out-string]\h'|\n[doc-reg-dtl]u'\c
.
.  if \n[doc-in-files-section] \
.    if n \
.      ds doc-Pa-font "\*[doc-saved-Pa-font]
.
.  nr doc-nesting-level -1
.  nr doc-list-immediate 0
.  ds doc-out-string
.  doc-reset-args
'  fi
..
.
.
.\" NS doc-get-tag-width macro
.\" NS   resolve unknown tag width (.Bl [inset | tag] only)
.\" NS
.\" NS modifies:
.\" NS   doc-list-indent-stackXXX, doc-have-indent, doc-tag-width-stackXXX
.\" NS
.\" NS requires:
.\" NS   doc-curr-type, doc-curr-arg
.
.de doc-get-tag-width
.  if !"TagwidtH"\*[doc-tag-width-stack\n[doc-list-depth]]" \{\
.    ie (\n[doc-curr-type] == 1) \{\
.      ds doc-tag-width-stack\n[doc-list-depth] \*[doc-curr-arg]
.      nr doc-list-indent-stack\n[doc-list-depth] \n[\*[doc-curr-arg]]
.    \}
.    el \{\
.      ds doc-tag-width-stack\n[doc-list-depth] No
.      nr doc-list-indent-stack\n[doc-list-depth] \n[No]
.    \}
.    nr doc-have-tag-width 1
.  \}
..
.
.
.\" NS doc-set-vertical-and-indent macro
.\" NS   set up vertical spacing (if not compact) and indentation (with
.\" NS   offset if argument is non-zero)
.\" NS
.\" NS modifies:
.\" NS   doc-have-indent, doc-have-tag-width
.
.de doc-set-vertical-and-indent
.  ie \n[doc-have-indent] \{\
.    nr doc-have-indent 0
.    nr doc-have-tag-width 0
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.      sp \n[doc-display-vertical]u
.    in +\n[doc-list-offset-stack\n[doc-list-depth]]u
.    if \$1 \
.      in +(\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.  \}
.  el \{\
.    if !\n[doc-compact-list-stack\n[doc-list-depth]] \
.      sp \n[doc-display-vertical]u
.  \}
.
.  if !\n[cR] \
.    ne 2v
..
.
.
.\" NS doc-saved-list-immediate global register (bool)
.\" NS   saved `doc-list-immediate' value
.
.nr doc-saved-list-immediate 0
.
.
.\" NS doc-list-depth global register
.\" NS   list type stack counter
.
.nr doc-list-depth 0
.
.
.\" NS doc-list-immediate global register (bool)
.\" NS   tag flag (for diversions)
.
.nr doc-list-immediate 0
.
.
.\" NS doc-num-columns global register
.\" NS   number of columns
.
.nr doc-num-columns 0
.
.
.\" NS doc-compact-list-stackXXX global register (bool)
.\" NS   stack of flags to indicate whether a particular list is compact
.\" NS
.\" NS   limit: doc-list-depth
.
.nr doc-compact-list-stack1 0
.
.
.\" NS doc-tag-width-stackXXX global string
.\" NS   stack of strings indicating how to set up current element of
.\" NS   doc-list-indent-stackXXX -- if set to TagwidtH, user has set it
.\" NS   directly; if it is a macro name, use the macro's width value;
.\" NS   otherwise, `doc-get-tag-width' uses width value of `No'.
.\" NS
.\" NS   limit: doc-list-depth
.
.ds doc-tag-width-stack0
.ds doc-tag-width-stack1
.
.
.\" NS doc-list-offset-stackXXX global register
.\" NS   stack of list offsets
.\" NS
.\" NS   limit: doc-list-depth
.
.nr doc-list-offset-stack1 0
.
.
.\" NS doc-end-list macro
.\" NS   list end function; resets indentation (and offset if argument is
.\" NS   non-zero)
.\" NS
.\" NS modifies:
.\" NS   doc-list-offset-stackXXX, doc-list-depth
.
.de doc-end-list
.  if \$1 \
'    in -(\n[doc-list-indent-stack\n[doc-list-depth]]u + \n[doc-digit-width]u)
.
'  in -\n[doc-list-offset-stack\n[doc-list-depth]]u
.  nr doc-list-offset-stack\n[doc-list-depth] 0
.
.  if (\n[doc-list-depth] <= 0) \
.    tm mdoc warning: extraneous .El call (#\n[.c])
.
.  doc-decrement-list-stack
.  nr doc-list-depth -1
.  doc-increment-list-stack
..
.
.
.\" NS doc-next-list-depth global register
.\" NS   next possible doc-list-depth value
.
.nr doc-next-list-depth 1
.
.
.\" NS doc-increment-list-stack macro
.\" NS   set up next block for list
.\" NS
.\" NS modifies:
.\" NS   doc-list-type-stackXXX, doc-list-indent-stackXXX,
.\" NS   doc-compact-list-stackXXX, doc-tag-width-stackXXX,
.\" NS   doc-list-offset-stackXXX, doc-next-list-depth
.
.de doc-increment-list-stack
.  nr doc-next-list-depth (\n[doc-list-depth] + 1)
.  nr doc-list-indent-stack\n[doc-next-list-depth] 0
.  nr doc-list-offset-stack\n[doc-next-list-depth] 0
.  ds doc-tag-width-stack\n[doc-next-list-depth] \*[doc-tag-width-stack\n[doc-list-depth]]
.  ds doc-list-type-stack\n[doc-next-list-depth]
.  nr doc-compact-list-stack\n[doc-next-list-depth] 0
..
.
.
.\" NS doc-decrement-list-stack macro
.\" NS   decrement stack
.\" NS
.\" NS modifies:
.\" NS   doc-list-type-stackXXX, doc-list-indent-stackXXX,
.\" NS   doc-compact-list-stackXXX, doc-tag-width-stackXXX,
.\" NS   doc-list-offset-stackXXX, doc-next-list-depth
.
.de doc-decrement-list-stack
.  ds doc-list-type-stack\n[doc-next-list-depth]
.  nr doc-list-indent-stack\n[doc-next-list-depth] 0
.  nr doc-list-offset-stack\n[doc-next-list-depth] 0
.  ds doc-tag-width-stack\n[doc-next-list-depth]
.  nr doc-compact-list-stack\n[doc-next-list-depth] 0
.  nr doc-next-list-depth -1
..
.
.
.\" NS Xr user macro
.\" NS   cross reference (man page only)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string
.\" NS
.\" NS width register `Xr' set in doc-common
.
.de Xr
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Xr
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Xr manpage_name [section#] \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    ie (\n[doc-type\n[doc-arg-ptr]] == 1) \
.      tm Usage: .Xr manpage_name [section#] \*[doc-punct-chars] (#\n[.c])
.    el \{\
.      ie (\n[doc-type\n[doc-arg-ptr]] == 2) \{\
.        as doc-out-string \*[doc-Xr-font]
.        as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.
.        nr doc-arg-ptr +1
.        if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.          if (\n[doc-type\n[doc-arg-ptr]] == 2) \{\
.            as doc-out-string \&\*[lp]\*[doc-arg\n[doc-arg-ptr]]\*[rp]
.            nr doc-arg-ptr +1
.        \}\}
.        ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \
.          doc-do-\n[doc-type\n[doc-arg-ptr]]
.        el \
.          doc-print-and-reset
.      \}
.      el \
.        doc-do-xref-\n[doc-type\n[doc-arg-ptr]]
.  \}\}
..
.
.
.\" NS Sx user macro
.\" NS   cross section reference
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Sx' set in doc-common
.
.de Sx
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Sx
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Sx section_header \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    as doc-out-string \*[doc-Sx-font]
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS doc-do-end-column-list macro
.\" NS   column-list end-list
.\" NS
.\" NS modifies:
.\" NS   doc-list-depth
.
.de doc-do-end-column-list
'  in -(\n[doc-list-offset-stack\n[doc-list-depth]]u + \n[doc-list-indent-stack\n[doc-list-depth]]u)
.  ta T .5i
.  fi
.  doc-decrement-list-stack
.  nr doc-list-depth -1
.  doc-increment-list-stack
..
.
.
.\" NS doc-column-indent-width global register
.\" NS   holds the indent width for a column list
.
.nr doc-column-indent-width 0
.
.
.\" NS doc-set-column-tab macro
.\" NS   establish tabs for list-type column: `.doc-set-column-tab num_cols'
.\" NS
.\" NS local variables:
.\" NS   doc-str-dsct, doc-str-dsct1, doc-reg-dsct, doc-column-indent-width
.
.de doc-set-column-tab
.  ds doc-str-dsct
.  nr doc-reg-dsct 1
.  nr doc-column-indent-width 0
.
.  ie (\$1 < 5) \
.    ds doc-str-dsct1 "    \"
.  el \{\
.    ie (\$1 == 5) \
.      ds doc-str-dsct1 "   \"
.    el \{\
.      \" XXX: this is packed abnormally close -- intercolumn width
.      \"      should be configurable
.      ds doc-str-dsct1 " \"
.  \}\}
.
.  while (\n[doc-reg-dsct] <= \$1) \{\
.    as doc-str-dsct " +\w\*[doc-arg\n[doc-reg-dsct]]\*[doc-str-dsct1]u
.    nr doc-column-indent-width +\w\*[doc-arg\n[doc-reg-dsct]]\*[doc-str-dsct1]u
.    nr doc-reg-dsct +1
.  \}
.
.  ta \*[doc-str-dsct]
'  in +(\n[doc-column-indent-width]u + \n[doc-list-offset-stack\n[doc-list-depth]]u)
..
.
.
.\" NS doc-column-list macro
.\" NS   column items
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-spaceXXX, doc-list-indent-stackXXX
.\" NS
.\" NS local variables:
.\" NS   doc-reg-dcl
.
.de doc-column-list
.  if !\n[doc-list-indent-stack\n[doc-list-depth]] \
.    nr doc-list-indent-stack\n[doc-list-depth] \n[doc-column-indent-width]u
.  if !\n[.u] \{\
.    fi
'    in +\n[doc-column-indent-width]u
.  \}
.  ti -\n[doc-column-indent-width]u
.
.  doc-parse-arg-vector
.  nr doc-arg-ptr +1
.
.  ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    if "\*[doc-arg\n[doc-arg-ptr]]"Ta" \{\
.      nr doc-reg-dcl (\n[doc-arg-ptr] - 1)
.      ds doc-space\n[doc-reg-dcl]
.    \}
.    doc-do-\n[doc-type\n[doc-arg-ptr]]
.  \}
.  el \
.    tm Usage: .It column_string [Ta [column_string ...] ] (#\n[.c])
..
.
.
.\" NS Ta user macro
.\" NS   append tab (\t)
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string
.\" NS
.\" NS width register `Ta' set in doc-common
.
.de Ta
.  ie \n[doc-arg-limit] \{\
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.      as doc-out-string \t
.      doc-do-\n[doc-type\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \t\c
.      doc-print-and-reset
.  \}\}
.  el \{\
.    tm1 "Usage: Ta must follow column entry: e.g. (#\n[.c])
.    tm1 "         .It column_string [Ta [column_string ...]]
.  \}
..
.
.
.\" NS Dl user macro
.\" NS   display (one line) literal
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name
.\" NS
.\" NS width register `Dl' set in doc-common
.
.de Dl
'  ta T .5i
.  in +\n[doc-display-indent]u
.
.  ie \n[doc-arg-limit] \
.    tm Usage: .Dl not callable by other macros (#\n[.c])
.  el \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Dl
.      doc-parse-args \$@
.      Li
.    \}
.    el \
.      tm Usage: .Dl argument ... (#\n[.c])
.  \}
.
.  in -\n[doc-display-indent]u
..
.
.
.\" NS D1 user macro
.\" NS   display (one line)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr
.\" NS
.\" NS width register `D1' set in doc-common
.
.de D1
'  ta T .5i
.  in +\n[doc-display-indent]u
.
.  ie \n[doc-arg-limit] \
.    tm Usage: .D1 not callable by other macros (#\n[.c])
.  el \{\
.    ie \n[.$] \{\
.      ds doc-macro-name D1
.      doc-parse-args \$@
.      nr doc-arg-ptr +1
.      No
.    \}
.    el \
.      tm Usage: .D1 argument ... (#\n[.c])
.  \}
.
.  in -\n[doc-display-indent]u
..
.
.
.\" NS Ex user macro
.\" NS   defunct
.
.de Ex
.  tm mdoc error: .Ex defunct, use .D1: \$@ (#\n[.c])
..
.
.
.\" NS Vt user macro
.\" NS   variable type (for forcing old style variable declarations);
.\" NS   this is not done in the same manner as .Ot for fortrash --
.\" NS   clean up later
.\" NS
.\" NS modifies:
.\" NS   doc-curr-font, doc-curr-size, doc-have-decl,
.\" NS   doc-have-var
.\" NS
.\" NS width register `Vt' set in doc-common
.
.de Vt
.  \" if a function declaration was the last thing given, want vertical space
.  if \n[doc-have-decl] \{\
.    doc-paragraph
.    nr doc-have-decl 0
.  \}
.
.  \" if a subroutine was the last thing given, want vertical space
.  if \n[doc-have-func] \{\
.    ie !\n[doc-have-var] \
.      br
.    el \{\
.      doc-paragraph
.      rs
.  \}\}
.
.  nr doc-have-var 1
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  nop \*[doc-Ft-font]\$*
.
.  ie \n[doc-have-old-func] \
.    nop \&\*[doc-soft-space]
.  el \
.    br
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
..
.
.
.\" NS doc-is-func global register (bool)
.\" NS   set if subroutine (in synopsis only) (fortran only)
.
.nr doc-is-func 0
.
.
.\" NS Ft user macro
.\" NS   function type
.\" NS
.\" NS modifies:
.\" NS   doc-curr-font, doc-curr-size, doc-have-decl,
.\" NS   doc-have-var, doc-is-func
.\" NS
.\" NS width register `Ft' set in doc-common
.
.de Ft
.  if \n[doc-in-synopsis-count] \{\
.    if (\n[doc-have-func] : \n[doc-have-decl]) \{\
.      doc-paragraph
.      nr doc-have-decl 0
.      nr doc-have-var 0
.    \}
.
.    if \n[doc-have-var] \{\
.      doc-paragraph
.      nr doc-have-var 0
.    \}
.
.    nr doc-is-func 1
.  \}
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  nop \*[doc-Ft-font]\$*
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
..
.
.
.\" NS doc-have-old-func global register (bool)
.\" NS   set if `Ot' has been called
.
.nr doc-have-old-func 0
.
.
.\" NS Ot user macro
.\" NS   old function type (fortran -- no newline)
.\" NS
.\" NS modifies:
.\" NS   doc-out-string, doc-have-decl, doc-have-var,
.\" NS   doc-is-func, doc-have-old-func
.\" NS
.\" NS width register `Ot' set in doc-common
.
.de Ot
.  nr doc-have-old-func 1
.
.  if \n[doc-in-synopsis-count] \{\
.    if (\n[doc-have-func] : \n[doc-have-decl]) \{\
.      doc-paragraph
.      nr doc-have-decl 0
.      nr doc-have-var 0
.    \}
.
.    if \n[doc-have-var] \{\
.      doc-paragraph
.      nr doc-have-var 0
.    \}
.
.    nr doc-is-func 1
.  \}
.
.  if \n[.$] \
.    as doc-out-string \*[doc-Ft-font]\$*
.  as doc-out-string \ \f[P]
..
.
.
.\" NS Fa user macro
.\" NS   function arguments
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size
.\" NS
.\" NS width register `Fa' set in doc-common
.
.de Fa
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fa
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Fa function_arguments ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  ie \n[doc-func-arg-count] \
.    doc-do-func
.  el \{\
.    nr doc-arg-ptr +1
.    if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.      as doc-out-string \*[doc-Fa-font]
.      nr doc-curr-font \n[.f]
.      nr doc-curr-size \n[.s]
.      doc-print-recursive
.
.      if \n[doc-in-synopsis-count] \
.        if \n[doc-have-func] \
.          br
.  \}\}
..
.
.
.\" NS doc-func-arg-count global register
.\" NS   how many function arguments have been processed so far
.
.nr doc-func-arg-count 0
.
.
.\" NS doc-func-arg global string
.\" NS   work buffer for function name strings
.
.ds doc-func-arg
.
.
.\" NS doc-num-func-args global register
.\" NS   number of function arguments
.
.nr doc-num-func-args 0
.
.
.\" NS doc-func-args-processed global register
.\" NS   function arguments processed so far
.
.nr doc-func-args-processed 0
.
.
.\" NS doc-do-func macro
.\" NS   internal .Fa for .Fc
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-argXXX, doc-out-string, doc-func-arg-count,
.\" NS   doc-func-arg, doc-num-func-args, doc-func-args-processed
.
.de doc-do-func
.  ie (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.
.    ds doc-func-arg
.    nr doc-num-func-args 0
.    nr doc-func-args-processed 0
.
.    doc-build-func-string \*[doc-arg\n[doc-arg-ptr]]
.    if (\n[doc-num-func-args] > 1) \
.      ds doc-arg\n[doc-arg-ptr] "\*[doc-func-arg]
.
.    if (\n[doc-func-arg-count] > 1) \{\
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]\|,
.      as doc-out-string "\*[doc-space\n[doc-arg-ptr]]\*[doc-Fa-font]
.      as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]\f[P]\s[0]
.    \}
.
.    if (\n[doc-func-arg-count] == 1) \{\
.      as doc-out-string \|\*[doc-Fa-font]\*[doc-arg\n[doc-arg-ptr]]
.      as doc-out-string \f[P]\s[0]
.    \}
.    nr doc-func-arg-count +1
.    doc-do-func
.  \}
.  el \
.    doc-reset-args
..
.
.
.\" NS doc-have-func global register (bool)
.\" NS   whether we have more than one function in synopsis
.
.nr doc-have-func 0
.
.
.\" NS Fn user macro
.\" NS   functions
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size, doc-in-synopsis-count, doc-indent-synopsis,
.\" NS   doc-have-decl, doc-have-var, doc-have-func,
.\" NS   doc-is-func
.\" NS
.\" NS width register `Fn' set in doc-common
.
.de Fn
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fn
.      doc-parse-args \$@
.    \}
.    el \{\
.      tmc Usage: .Fn function_name function_arg(s) ... \*[doc-punct-chars]
.      tm1 " (#\n[.c])
.  \}\}
.
.  if \n[doc-in-synopsis-count] \{\
.    \" if there is/has been more than one subroutine declaration
.    ie \n[doc-is-func] \{\
.      br
.      nr doc-have-var 0
.      nr doc-have-decl 0
.      nr doc-is-func 0
.    \}
.    el \{\
.      if \n[doc-have-func] \{\
.        doc-paragraph
.        nr doc-have-var 0
.        nr doc-have-decl 0
.    \}\}
.
.    if \n[doc-have-decl] \{\
.      doc-paragraph
.      nr doc-have-var 0
.    \}
.
.    if \n[doc-have-var] \{\
.      doc-paragraph
.      nr doc-have-decl 0
.    \}
.
.    nr doc-have-func 1
.    nr doc-is-func 0
.    rs
.
.    ie (\n[doc-in-synopsis-count] > 1) \
.      br
.    el \{\
.      if !\n[doc-indent-synopsis] \
.        nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
.    \}
.
.    in +\n[doc-indent-synopsis]u
.    ti -\n[doc-indent-synopsis]u
.    nr doc-in-synopsis-count +1
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    as doc-out-string \*[doc-Fn-font]\*[doc-arg\n[doc-arg-ptr]]
.    as doc-out-string \f[P]\s[0]\*[lp]
.
.    nr doc-arg-ptr +1
.    ie (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.      as doc-out-string \*[doc-Fa-font]
.      doc-do-func-\n[doc-type\n[doc-arg-ptr]]
.    \}
.    el \{\
.      as doc-out-string \|\*[rp]
.      doc-print-and-reset
.    \}
.
.    if \n[doc-in-synopsis-count] \
.      in -\n[doc-indent-synopsis]u
.  \}
..
.
.
.\" NS doc-do-func-1 macro
.\" NS   prepare `doc-out-string' and execute doc-argXXX
.\" NS
.\" NS modifies:
.\" NS   doc-out-string
.
.de doc-do-func-1
.  ie \n[doc-in-synopsis-count] \{\
.    as doc-out-string \&\*[rp]\f[R];\f[P]
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.  \}
.  el \
.    as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.
.  \*[doc-arg\n[doc-arg-ptr]]
..
.
.
.\" NS doc-do-func-2 macro
.\" NS   handle function arguments
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-argXXX, doc-out-string, doc-func-arg,
.\" NS   doc-num-func-args, doc-func-args-processed
.\" NS
.\" NS local variables:
.\" NS   doc-reg-ddfs
.
.de doc-do-func-2
.  if \n[doc-in-synopsis-count] \{\
.    ds doc-func-arg
.    nr doc-num-func-args 0
.    nr doc-func-args-processed 0
.
.    doc-build-func-string \*[doc-arg\n[doc-arg-ptr]]
.    if (\n[doc-num-func-args] > 1) \
.      ds doc-arg\n[doc-arg-ptr] "\*[doc-func-arg]
.  \}
.
.  as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.
.  ie (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
.    nr doc-reg-ddfs \n[doc-arg-ptr]
.    nr doc-arg-ptr +1
.    if (\n[doc-type\n[doc-arg-ptr]] == 2) \{\
.      as doc-out-string \|\f[\n[doc-curr-font]]\s[\n[doc-curr-size]],
.      as doc-out-string "\*[doc-space\n[doc-reg-ddfs]]\f[P]\s[0]\|
.    \}
.    doc-do-func-\n[doc-type\n[doc-arg-ptr]]
.  \}
.  el \{\
.    ie \n[doc-in-synopsis-count] \{\
.      as doc-out-string \&\*[rp]\f[R];\f[P]
.      as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    \}
.    el \
.      as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.
.    doc-print-and-reset
.  \}
..
.
.
.\" NS doc-do-func-3 macro
.\" NS   handle punctuation suffixes in functions
.\" NS
.\" NS modifies:
.\" NS   doc-out-string
.
.de doc-do-func-3
.  ie \n[doc-in-synopsis-count] \{\
.    as doc-out-string \&\*[rp]\f[R];\f[P]
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-arg\n[doc-arg-ptr]]
.  \}
.
.  ie (\n[doc-arg-limit] > \n[doc-arg-ptr]) \
.    No
.  el \
.    doc-print-and-reset
..
.
.
.\" NS doc-do-func-4 macro
.\" NS   handle punctuation prefixes in functions
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string
.
.de doc-do-func-4
.  ie \n[doc-in-synopsis-count] \{\
.    as doc-out-string \&\*[rp]\f[R];\f[P]
.    as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-space\n[doc-arg-ptr]]\*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \{\
.    as doc-out-string \&\*[rp]\f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    as doc-out-string "\*[doc-space\n[doc-arg-ptr]]\*[doc-arg\n[doc-arg-ptr]]
.  \}
.
.  ie (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    No
.  \}
.  el \
.    doc-print-and-reset
..
.
.
.\" NS Fo user macro
.\" NS   function open
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size, doc-in-synopsis-count, doc-indent-synopsis,
.\" NS   doc-have-decl, doc-have-var, doc-have-func,
.\" NS   doc-nesting-level, doc-is-func, doc-func-arg-count
.\" NS
.\" NS width register `Fo' set in doc-common
.
.de Fo
.  hy 0
.
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name Fo
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .Fo function_name (#\n[.c])
.  \}
.
.  if \n[doc-in-synopsis-count] \{\
.    \" if there is/has been more than one subroutine declaration
.    ie \n[doc-is-func] \{\
.      br
.      nr doc-have-var 0
.      nr doc-have-decl 0
.      nr doc-is-func 0
.    \}
.    el \{\
.      if \n[doc-have-func] \{\
.        doc-paragraph
.        nr doc-have-var 0
.        nr doc-have-decl 0
.    \}\}
.
.    if \n[doc-have-decl] \{\
.      doc-paragraph
.      nr doc-have-var 0
.    \}
.
.    if \n[doc-have-var] \{\
.      doc-paragraph
.      nr doc-have-decl 0
.    \}
.
.    nr doc-have-func 1
.    nr doc-is-func 0
.    rs
.
.    ie (\n[doc-in-synopsis-count] > 1) \
.      br
.    el \{\
.      if !\n[doc-indent-synopsis] \
.        nr doc-indent-synopsis (8u * \n[doc-fixed-width]u)
.    \}
.
.    in +\n[doc-indent-synopsis]u
.    ti -\n[doc-indent-synopsis]u
.    nr doc-in-synopsis-count +1
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-nesting-level +1
.    nr doc-func-arg-count 1
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    as doc-out-string \*[doc-Fn-font]\*[doc-arg\n[doc-arg-ptr]]
.    as doc-out-string \f[P]\s[0]\*[lp]
.    doc-reset-args
.  \}
..
.
.
.\" NS Fc user macro
.\" NS   function close
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-nesting-level,
.\" NS   doc-func-arg-count
.\" NS
.\" NS width register `Fc' set in doc-common
.
.de Fc
.  if !\n[doc-arg-limit] \{\
.    if \n[.$] \{\
.      ds doc-macro-name Fc
.      doc-parse-args \$@
.  \}\}
.
.  nr doc-func-arg-count 0
.  nr doc-nesting-level -1
.
.  ie \n[doc-in-synopsis-count] \
.    as doc-out-string \|\*[rp]\f[R];\f[P]
.  el \
.    as doc-out-string \|\*[rp]
.  ie (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
.    nr doc-arg-ptr +1
.    \*[doc-arg\n[doc-arg-ptr]]
.  \}
.  el \
.    doc-print-and-reset
.
.  if \n[doc-in-synopsis-count] \
.    in -\n[doc-indent-synopsis]u
.
.  hy
..
.
.
.\" NS doc-build-func-string macro
.\" NS   collect function arguments and set hard spaces inbetween
.\" NS
.\" NS modifies:
.\" NS   doc-func-arg, doc-num-func-args, doc-func-args-processed
.
.de doc-build-func-string
.  if !\n[doc-num-func-args] \{\
.    nr doc-num-func-args \n[.$]
.    nr doc-func-args-processed 0
.    ds doc-func-arg
.  \}
.
.  nr doc-func-args-processed +1
.  as doc-func-arg "\$1
.
.  if (\n[doc-func-args-processed] < \n[doc-num-func-args]) \{\
.    as doc-func-arg "\*[doc-hard-space]
.
.    shift
.    doc-build-func-string \$@
.  \}
..
.
.
.\" Very crude references, stash all reference info into strings (usual
.\" use of doc-out-string, then doc-out-string contents copied to
.\" string of retrievable naming convention), print out reference on .Re
.\" request and clean up.  Ordering very limited, no fancy citations, but
.\" can do articles, journals, and books -- need to add several missing
.\" options (like city etc).  Should be able to grab a refer entry, massage
.\" it a wee bit (prefix a `.' to the %[A-Z]) and not worry (ha!).
.
.
.\" NS doc-is-reference global register (bool)
.\" NS   set if in reference
.
.nr doc-is-reference 0
.
.
.\" NS doc-reference-count global register
.\" NS   reference element counter
.
.nr doc-reference-count 0
.
.
.\" NS doc-reference-string-name global string
.\" NS   contains current reference string name for handling in
.\" NS   `doc-do-references'
.
.ds doc-reference-string-name
.
.
.\" NS Rs user macro
.\" NS   reference start
.\" NS
.\" NS modifies:
.\" NS   doc-is-reference, doc-reference-count
.\" NS
.\" NS width register `Rs' set in doc-common
.
.de Rs
.  nr doc-is-reference 1
.  doc-reset-reference
.  if \n[doc-in-see-also-section] \
.    doc-paragraph
.  nr doc-reference-count 0
..
.
.
.\" NS Re user macro
.\" NS   reference end
.\" NS
.\" NS modifies:
.\" NS   doc-is-reference
.\" NS
.\" NS width register `Re' set in doc-common
.
.de Re
.  doc-print-reference
.  doc-reset-reference
.  nr doc-is-reference 0
..
.
.
.\" NS doc-reset-reference macro
.\" NS   reference cleanup
.\" NS
.\" NS modifies:
.\" NS   doc-author-count, doc-journal-count, doc-issue-count,
.\" NS   doc-optional-count, doc-corporate-count, doc-report-count,
.\" NS   doc-reference-title-count, doc-volume-count, doc-date-count,
.\" NS   doc-page-number-count, doc-book-count, doc-reference-string-name,
.\" NS   doc-journal-name, doc-issue-name, doc-optional-string,
.\" NS   doc-corporate-name, doc-report-name, doc-reference-title-name,
.\" NS   doc-volume-name, doc-date, doc-page-number-string, doc-book-name
.
.de doc-reset-reference
.  nr doc-author-count 0
.  nr doc-journal-count 0
.  nr doc-issue-count 0
.  nr doc-optional-count 0
.  nr doc-corporate-count 0
.  nr doc-report-count 0
.  nr doc-reference-title-count 0
.  nr doc-volume-count 0
.  nr doc-date-count 0
.  nr doc-page-number-count 0
.  nr doc-book-count 0
.
.  ds doc-reference-string-name
.
.  ds doc-journal-name
.  ds doc-issue-name
.  ds doc-optional-string
.  ds doc-corporate-name
.  ds doc-report-name
.  ds doc-reference-title-name
.  ds doc-volume-name
.  ds doc-date
.  ds doc-page-number-string
.  ds doc-book-name
..
.
.
.\" NS doc-finish-reference macro
.\" NS   auxiliary macro for doc-print-reference
.\" NS
.\" NS modifies:
.\" NS   doc-reference-count
.
.de doc-finish-reference
.  nr doc-reference-count -1
.  ie \n[doc-reference-count] \
.    nop \&,
.  el \
.    nop \&.
..
.
.
.\" NS doc-print-reference macro
.\" NS   reference print
.\" NS
.\" NS modifies:
.\" NS   doc-reference-count, doc-authors-processed
.
.de doc-print-reference
.  if \n[doc-author-count] \{\
.    nop \&\*[doc-author-name1],
.    nr doc-authors-processed 1
.    if (\n[doc-author-count] > 1) \
.      doc-print-reference-authors
.    nr doc-reference-count -\n[doc-author-count]
.  \}
.
.  if \n[doc-reference-title-count] \{\
.    ie ((\n[doc-journal-count] == 1) : (\n[doc-book-count] == 1)) \{\
.      nop \&\*[q]\*[doc-reference-title-name]\*[q]\c
.      doc-finish-reference
.    \}
.    el \{\
.      nop \*[doc-Em-font]\*[doc-reference-title-name]\*[doc-No-font]\c
.      doc-finish-reference
.  \}\}
.
.  if \n[doc-book-count] \{\
.    nop \*[doc-Em-font]\*[doc-book-name]\*[doc-No-font]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-publisher-count] \{\
.    nop \*[doc-Em-font]\*[doc-publisher-name]\*[doc-No-font]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-journal-count] \{\
.    nop \*[doc-Em-font]\*[doc-journal-name]\*[doc-No-font]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-report-count] \{\
.    nop \&\*[doc-report-name]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-issue-count] \{\
.    nop \&\*[doc-issue-name]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-volume-count] \{\
.    nop \&\*[doc-volume-name]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-page-number-count] \{\
.    nop \&\*[doc-page-number-string]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-corporate-count] \{\
.    nop \&\*[doc-corporate-name]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-date-count] \{\
.    nop \&\*[doc-date]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-optional-count] \{\
.    nop \&\*[doc-optional-string]\c
.    doc-finish-reference
.  \}
.
.  if \n[doc-reference-count] \
.    tm mdoc warning: unresolved reference problem
..
.
.
.\" NS doc-authors-processed global register
.\" NS   author references processed so far
.
.nr doc-authors-processed 0
.
.
.\" NS doc-print-reference-authors macro
.\" NS   print out reference authors
.\" NS
.\" NS modifies:
.\" NS   doc-authors-processed
.
.de doc-print-reference-authors
.  nr doc-authors-processed +1
.  ie (\n[doc-author-count] == \n[doc-authors-processed]) \
.    nop \&and \*[doc-author-name\n[doc-authors-processed]],
.  el \{\
.    nop \&\*[doc-author-name\n[doc-authors-processed]],
.    doc-print-reference-authors
.  \}
..
.
.
.\" NS doc-author-count global register
.\" NS   counter of author references
.
.nr doc-author-count 0
.
.
.\" NS doc-author-nameXXX global string
.\" NS   array of author names
.\" NS
.\" NS   limit: doc-author-count
.
.ds doc-author-name0
.
.
.\" NS %A user macro
.\" NS   reference author(s)
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" MS   doc-reference-count, doc-author-count, doc-reference-string-name
.\" NS
.\" NS width register `%A' set in doc-common
.
.de %A
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-author-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-author-name\n[doc-author-count]
.
.      ds doc-macro-name %A
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%A author_name (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-book-count global register
.\" NS   counter of book references
.
.nr doc-book-count 0
.
.
.\" NS doc-book-name global string
.\" NS   string of collected book references
.
.ds doc-book-name
.
.
.\" NS %B user macro
.\" NS   [reference] book name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size, doc-reference-count, doc-book-count,
.\" NS   doc-reference-string-name
.\" NS
.\" NS width register `%B' set in doc-common
.
.de %B
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      if \n[doc-is-reference] \{\
.        nr doc-book-count +1
.        nr doc-reference-count +1
.        ds doc-reference-string-name doc-book-name
.      \}
.
.      ds doc-macro-name %B
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%B book_name (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.
.    ie !\n[doc-is-reference] \{\
.      as doc-out-string \*[doc-Em-font]
.      doc-print-recursive
.    \}
.    el \
.      doc-do-references
.  \}
..
.
.
.\" NS doc-date-count global register
.\" NS   counter of date references
.
.nr doc-date-count 0
.
.
.\" NS doc-date global string
.\" NS   string of collected date references
.
.ds doc-date
.
.
.\" NS %D user macro
.\" NS   [reference] date
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-date-count, doc-reference-string-name
.\" NS
.\" NS width register `%D' set in doc-common
.
.de %D
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-date-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-date
.
.      ds doc-macro-name %D
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%D date (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-publisher-count global register
.\" NS   counter of publisher references
.
.nr doc-publisher-count 0
.
.
.\" NS doc-publisher-name global string
.\" NS   string of collected publisher references
.
.ds doc-publisher-name
.
.
.\" NS %I user macro
.\" NS   [reference] issuer/publisher name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-reference-string-name
.\" NS
.\" NS width register `%I' set in doc-common
.
.de %I
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-publisher-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-publisher-name
.
.      ds doc-macro-name %I
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%I issuer/publisher_name (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-journal-count global register
.\" NS   counter of journal references
.
.nr doc-journal-count 0
.
.
.\" NS doc-journal-name global string
.\" NS   string of collected journal references
.
.ds doc-journal-name
.
.
.\" NS %J user macro
.\" NS   [reference] Journal Name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-journal-count, doc-reference-string-name
.\" NS
.\" NS width register `%J' set in doc-common
.
.de %J
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-journal-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-journal-name
.
.      ds doc-macro-name %J
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%J journal_name (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-issue-count global register
.\" NS   counter of issue number references
.
.nr doc-issue-count 0
.
.
.\" NS doc-issue-name global string
.\" NS   string of collected issue number references
.
.ds doc-issue-name
.
.
.\" NS %N user macro
.\" NS   [reference] issue number
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-issue-count, doc-reference-string-name
.\" NS
.\" NS width register `%N' set in doc-common
.
.de %N
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-issue-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-issue-name
.
.      ds doc-macro-name %N
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%N issue_number (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-optional-count global register
.\" NS   counter of optional information references
.
.nr doc-optional-count 0
.
.
.\" NS doc-optional-string global string
.\" NS   string of collected optional information references
.
.ds doc-optional-string
.
.
.\" NS %O user macro
.\" NS   [reference] optional information
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-optional-count, doc-reference-string-name
.\" NS
.\" NS width register `%O' set in doc-common
.
.de %O
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-optional-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-optional-string
.
.      ds doc-macro-name %O
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%O optional_information ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-page-number-count global register
.\" NS   counter of page number references
.
.nr doc-page-number-count 0
.
.
.\" NS doc-page-number-string global string
.\" NS   string of collected page number references
.
.ds doc-page-number-string
.
.
.\" NS %P user macro
.\" NS   [reference] page numbers
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-page-number-count, doc-reference-string-name
.\" NS
.\" NS width register `%P' set in doc-common
.
.de %P
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-page-number-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-page-number-string
.
.      ds doc-macro-name %P
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%P page_numbers ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-corporate-count global register
.\" NS   counter of corporate references
.
.nr doc-corporate-count 0
.
.
.\" NS doc-corporate-name global string
.\" NS   string of collected corporate references
.
.ds doc-corporate-name
.
.
.\" NS %Q user macro
.\" NS   corporate or foreign author
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-corporate-count, doc-reference-string-name
.\" NS
.\" NS width register `%Q' set in doc-common
.
.de %Q
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-corporate-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-corporate-name
.
.      ds doc-macro-name %Q
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%Q corporate_or_foreign_author (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-report-count global register
.\" NS   counter of report references
.
.nr doc-report-count 0
.
.
.\" NS doc-report-name global string
.\" NS   string of collected report references
.
.ds doc-report-name
.
.
.\" NS %R user macro
.\" NS   [reference] report name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-report-count, doc-reference-string-name
.\" NS
.\" NS width register `%R' set in doc-common
.
.de %R
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      nr doc-report-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-report-name
.
.      ds doc-macro-name %R
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%R reference_report (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-reference-title-count global register
.\" NS   counter of reference title references
.
.nr doc-reference-title-count 0
.
.
.\" NS doc-reference-title-name global string
.\" NS   string of collected reference title references
.
.ds doc-reference-title-name
.
.
.\" NS %T user macro
.\" NS   reference title
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-out-string, doc-curr-font,
.\" NS   doc-curr-size, doc-reference-count, doc-reference-title-count,
.\" NS   doc-reference-string-name
.\" NS
.\" NS width register `%T' set in doc-common
.
.de %T
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      if \n[doc-is-reference] \{\
.        nr doc-reference-title-count +1
.        nr doc-reference-count +1
.        ds doc-reference-string-name doc-reference-title-name
.      \}
.
.      ds doc-macro-name %T
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%T reference_title (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    ie \n[doc-is-reference] \
.      doc-do-references
.    el \{\
.      as doc-out-string \*[doc-Em-font]
.      doc-print-recursive
.  \}\}
..
.
.
.\" NS doc-volume-count global register
.\" NS   counter of reference title references
.
.nr doc-volume-count 0
.
.
.\" NS doc-volume-name global string
.\" NS   string of collected volume references
.
.ds doc-volume-name
.
.
.\" NS %V user macro
.\" NS   reference volume
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-reference-count, doc-volume-count, doc-reference-string-name
.\" NS
.\" NS width register `%V' set in doc-common
.
.de %V
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name %V
.      nr doc-volume-count +1
.      nr doc-reference-count +1
.      ds doc-reference-string-name doc-volume-name
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .%V volume , ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-do-references
.  \}
..
.
.
.\" NS doc-do-references macro
.\" NS   reference recursion routine
.\" NS
.\" NS modifies:
.\" NS   doc-arg-ptr, doc-out-string, doc-reference-string-name,
.\" NS   doc-journal-name, doc-issue-name, doc-optional-string,
.\" NS   doc-corporate-name, doc-report-name, doc-reference-title-name,
.\" NS   doc-volume-name, doc-date, doc-page-number-string, doc-book-name
.\" NS
.\" NS local variables:
.\" NS   doc-reg-ddr, doc-reg-ddr1
.
.de doc-do-references
.  hy 0
.
.  nr doc-reg-ddr1 \n[doc-type\n[doc-arg-ptr]]
.
.  ie (\n[doc-reg-ddr1] == 1) \{\
.    \" .as doc-out-string \f[\n[doc-curr-font]]\s[\n[doc-curr-size]]
.    ie "\*[doc-arg\n[doc-arg-ptr]]"Tn" \
.      doc-reference-trademark
.    el \{\
.      doc-append-arg doc-do-references 1
.      \*[doc-arg\n[doc-arg-ptr]]
.  \}\}
.  el \{\
.    nr doc-reg-ddr \n[doc-arg-ptr]
.    as doc-out-string \&\*[doc-arg\n[doc-arg-ptr]]
.
.    ie (\n[doc-arg-limit] == \n[doc-arg-ptr]) \{\
.      as \*[doc-reference-string-name] \&\*[doc-out-string]
.      ds doc-out-string
.      ds doc-reference-string-name
.      doc-reset-args
.    \}
.    el \{\
.      nr doc-arg-ptr +1
.      as doc-out-string "\*[doc-space\n[doc-reg-ddr]]
.      doc-do-references
.  \}\}
..
.
.
.\" NS Hf user macro
.\" NS   source include header files.
.\" NS
.\" NS modifies:
.\" NS   doc-curr-font, doc-curr-size
.\" NS
.\" NS width register `Hf' set in doc-common
.
.de Hf
.  doc-paragraph
.  nop File:
.  Pa \$1
.  doc-paragraph
.
.  nr doc-curr-font \n[.f]
.  nr doc-curr-size \n[.s]
.
.  ie t \{\
.    nop \*[doc-Li-font]
.    br
.    ta T 9n
.  \}
.  el \
.    ta T 8n
.
.  nf
.  so \$1
.  fi
.
.  ft \n[doc-curr-font]
.  ps \n[doc-curr-size]
.  doc-paragraph
..
.
.
.\" NS doc-have-author global register (bool)
.\" NS   set in `An'
.
.nr doc-have-author 0
.
.
.\" NS An user macro
.\" NS   author name
.\" NS
.\" NS modifies:
.\" NS   doc-macro-name, doc-arg-ptr, doc-curr-font, doc-curr-size,
.\" NS   doc-have-author
.\" NS
.\" NS width register `An' set in doc-common
.
.de An
.  if \n[doc-in-authors-section] \{\
.    ie \n[doc-have-author] \
.      br
.    el \
.      nr doc-have-author 1
.  \}
.
.  if !\n[doc-arg-limit] \{\
.    ie \n[.$] \{\
.      ds doc-macro-name An
.      doc-parse-args \$@
.    \}
.    el \
.      tm Usage: .An author_name ... \*[doc-punct-chars] (#\n[.c])
.  \}
.
.  nr doc-arg-ptr +1
.  if (\n[doc-arg-limit] >= \n[doc-arg-ptr]) \{\
.    nr doc-curr-font \n[.f]
.    nr doc-curr-size \n[.s]
.    doc-print-recursive
.  \}
..
.
.
.\" NS Sf user macro
.\" NS   defunct
.\" NS
.\" NS width register `Sf' set in doc-common
.
.de Sf
.  tm mdoc error: .Sf defunct, use .Pf or .Ns (#\n[.c])
..
.
.
.ds doc-func-error-string "function returns the value\~0 if successful;
.as doc-func-error-string " otherwise the value\~-1 is returned and
.as doc-func-error-string " the global variable \*[doc-Va-font]errno\f[P]
.as doc-func-error-string " is set to indicate the error.
.
.
.\" NS Rv user macro
.\" NS   return values
.\" NS
.\" NS width register `Rv' set in doc-common
.\" NS
.\" NS local variables:
.\" NS   doc-str-Rv
.
.de Rv
.
.\" XXX: what does this function without `-std'?
.
.  ie !\n[.$] \
.    tm Usage: .Rv [-std] (#\n[.c])
.  el \{\
.    \" .ds doc-macro-name Rv
.    \" .nr doc-arg-ptr 0
.    \" .nr lR +1
.    \" .ds doc-arg1 \$2
.    \" .ds doc-arg2 \$3
.    \" .ds doc-arg3 \$4
.    \" .ds doc-arg4 \$5
.    \" .ds doc-arg5 \$6
.    \" .ds doc-arg6 \$7
.    \" .ds doc-arg7 \$8
.    \" .ds doc-arg8 \$9
.    \" .
.    \" .nr doc-num-args (\n[.$] - 1)
.
.    if "\$1"-std" \{\
.      doc-reg-Rv \*[doc-section]
.      if ((\n[doc-reg-Rv] < 2) : (\n[doc-reg-Rv] > 3)) \
.        tm Usage: .Rv -std in sections 2 and 3 only (#\n[.c])
.      br
.      nop \&The
.      Fn \$2
.      nop \&\*[doc-func-error-string]
.  \}\}
..
.
.
.\" NS Mt user macro
.\" NS   mailto (for conversion to HTML)
.
.de Mt
.  \" XXX: error handling missing
.  Pa \$@
..
.
.
.\" NS Lk user macro
.\" NS   link (for conversion to HTML)
.\" NS
.\" NS local variables:
.\" NS   doc-str-Lk, doc-reg-Lk
.
.de Lk
.  ds doc-str-Lk Sy \$@
.
.  ie (\n[.$] > 1) \{\
.    doc-get-arg-type \$2
.    ie (\[doc-arg-type] < 3) \{\
.      Em \&\$2:
.      ds doc-str-Lk Sy "\$1"
.      doc-get-width "\$1"
.      shift 2
.      if \n[.$] \
.        as doc-str-Lk " \$@
.    \}
.    el \
.      doc-get-width "\$1"
.  \}
.  el \
.    doc-get-width "\$1"
.
.  ie n \
.    nr doc-reg-Lk 26
.  el \
.    nr doc-reg-Lk 38
.  ie (\n[doc-width] >= \n[doc-reg-Lk]) \
.    D1 \*[doc-str-Lk]
.  el \
.    \*[doc-str-Lk]
..
.
.
.rn em e@
.
.de em
.  tm mdoc error: end-macro (.em) respecification is not allowed. (#\n[.c])
.  ab Should this have been `.Em ...'?
..
.
.
.ec
.
.\" EOF
