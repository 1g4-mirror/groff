.\" Define the PDFPIC macro.
.\"
.\" When used with output devices other than pdf, converted image to
.\" encapsulated PostScript and process it with PSPIC.
.\"
.\" Usage:
.\"
.\"   .PDFPIC [-L|-R|-C|-I <indentation>] <file> [<width> [<height>]]
.\"
.\" Requires the poppler-utils package (for pdfinfo and pdftops).
.\" Requires running groff in unsafe mode.
.
.do if d PDFPIC .nx
.
.do nr *groff_pdfpic_tmac_C \n[.cp]
.cp 0
.
.\" A user may wish to append an 'ab' to this macro using 'am'.  That
.\" is why we don't 'return X' from here to return from two scopes.
.de pdfpic@error
.  tm pdfpic.tmac:\\n[.F]:\\n[.c]: error: \\$*
..
.
.de PDFPIC
.  if !\\n[.U] \{\
.    pdfpic@error use of \\$0 requires GNU troff's unsafe mode \
(-U option)
.    return
.  \}
.
.  nr convert-pdf 0
.  if !'\\*[.T]'pdf' .nr convert-pdf 1
.
.  nr pdf-offset-mode 0
.
.  \" left-aligned?
.  ie '\\$1'-L' \{\
.    nr pdf-offset-mode 1
.    if \\n[convert-pdf] .ds pspic-args \\$1 \"
.    shift
.  \}
.  el \{\
.    \" right-aligned?
.    ie '\\$1'-R' \{\
.      nr pdf-offset-mode 2
.      if \\n[convert-pdf] .ds pspic-args \\$1 \"
.      shift
.    \}
.    el \{\
.      \" indented?
.      ie '\\$1'-I' \{\
.        nr pdf-offset-mode 3
.        nr pdf-offset (m;\\$2)
.        if \\n[convert-pdf] .ds pspic-args \\$1 \\$2 \"
.        shift 2
.      \}
.      el \{\
.        \" centered is the default
.        ie '\\$1'-C' \{\
.          if \\n[convert-pdf] .ds pspic-args \\$1 \"
.          shift
.        \}
.        el .nr pdf-offset-mode 0
.      \}
.    \}
.  \}
.  br
.
.  ds is-pdf \\$1
.  substring is-pdf -3
.  stringdown is-pdf
.  if !'\\*[is-pdf]'pdf' \{\
.    pdfpic@error '\\$1' lacks a '.pdf' extension; skipping
.    return
.  \}
.
.  \" Ensure the file exists and is readable.
.  \"
.  \" This test is subject to a time-of-check-to-time-of-use (TOCTTOU)
.  \" attack (or a simple race with a concurrent `rm` command, for
.  \" instance).
.  sy test -r \\$1
.  if \\n[systat] \{\
.    pdfpic@error '\\$1' does not exist or is not readable; skipping
.    return
.  \}
.
.  \" if driver is not gropdf, convert image to .eps
.  if \\n[convert-pdf] \{\
.    ds img-file \\$1
.    substring img-file 0 -5
.
.    sy pdftops -eps \\$1
.    shift
.
.    as pspic-args \\*[img-file].eps \\$*
.
.    PSPIC \\*[pspic-args]
.    return
.  \}
.
.  \" get image dimensions
.  ec @
.  sy pdfinfo @$1 | \
grep "Page *size" | \
sed -e 's/Page *size: *\\([[:digit:].]*\\) *x *\\([[:digit:].]*\\).*$/\
.nr pdf-wid (p;\\1)\\n\
.nr pdf-ht  (p;\\2)/' \
> /tmp/pdfpic\n[$$]
.  ec
.  if \\n[systat] \{\
.    pdfpic@error retrieval of '\\$1' image dimensions failed with \
exit status \\n[systat]; skipping
.    return
.  \}
.  so /tmp/pdfpic\\n[$$]
.  sy rm /tmp/pdfpic\\n[$$]
.
.  nr pdfpic*did-pdfinfo-work 1
.  if !r pdf-wid .nr pdfpic*did-pdfinfo-work 0
.  if !r pdf-ht .nr pdfpic*did-pdfinfo-work 0
.  if !\\n[pdfpic*did-pdfinfo-work] \{\
.    pdfpic@error retrieval of '\\$1' image dimensions failed; skipping
.    return
.  \}
.  rr pdfpic*did-pdfinfo-work
.
.  \" reject nonsense dimensions <= 0 (and avoid zero divide later)
.  if !\\n[pdf-wid] \{\
.    pdfpic@error '\\$1' reports image width of \\n[pdf-wid]u; skipping
.    return
.  \}
.  if !\\n[pdf-ht] \{\
.    pdfpic@error '\\$1' reports image height of \\n[pdf-ht]u; skipping
.    return
.  \}
.
.  \" if we have a <width> parameter, use it as the final
.  \" image width; otherwise we use the image's natural width
.  \" or the current line length, whatever is smaller
.  ie (\\n[.$] >= 2) \{\
.    nr pdf-deswid (i;\\$2)
.    if !\\n[pdf-deswid] \{\
.      pdfpic@error rejecting desired image width of \\n[pdf-deswid]u; \
skipping '\\$1'
.      return
.    \}
.  \}
.  el \
.    nr pdf-deswid ((\\n[.l] - \\n[.i]) <? \\n[pdf-wid])
.
.  if (\\n[.$] >= 3) \{\
.    nr pdf-desht (i;\\$3)
.    if !\\n[pdf-desht] \{\
.      pdfpic@error rejecting desired image height of \\n[pdf-desht]u; \
skipping '\\$1'
.      return
.    \}
.  \}
.  \" We have no else clause; pdf-desht will get clobbered anyway.
.
.  \" compute the final image height (with proper rounding),
.  \" based on the image's aspect
.  nr pdf-desht (\\n[pdf-deswid] * 1000 + (\\n[pdf-wid] / 2) \
                / \\n[pdf-wid] * \\n[pdf-ht] \
                + 500 / 1000)
.
.  \" if we have a <height> parameter, use it as the final
.  \" image height in case it is smaller than the height
.  \" value we have just computed
.  if ((\\n[.$] >= 3) & (\\n[pdf-desht] > (i;0\\$3))) \{\
.    nr pdf-desht (i;\\$3)
.    \" recompute the final image width since we always
.    \" keep the correct image aspect
.    nr pdf-deswid (\\n[pdf-desht] * 1000 + (\\n[pdf-ht] / 2) \
                   / \\n[pdf-ht] * \\n[pdf-wid] \
                   + 500 / 1000)
.  \}
.
.  \" reserve vertical space for image
.  ne (\\n[pdf-desht]u + 1v)
.
.  \" compute image offset w.r.t. the current left margin
.  if (\\n[pdf-offset-mode] == 0) \
.    nr pdf-offset (\\n[.l] - \\n[.i] - \\n[pdf-deswid] / 2)
.  if (\\n[pdf-offset-mode] == 1) \
.    nr pdf-offset 0
.  if (\\n[pdf-offset-mode] == 2) \
.    nr pdf-offset (\\n[.l] - \\n[.i] - \\n[pdf-deswid])
.
\h'\\n[pdf-offset]u'\
\X'pdf: pdfpic \\$1 -L \\n[pdf-deswid]z \\n[pdf-desht]z'
.  if !r PDFPIC_NOSPACE \{\
.    sy echo ".nr PDFPIC_NOSPACE 0$GROFF_PDFPIC_NOSPACE" > /tmp/x\n[$$]
.    so /tmp/x\n[$$]
.    sy rm /tmp/x\n[$$]
.  \}
.  if \\n[PDFPIC_NOSPACE]==0 \{\
.    br
.    sp \\n[pdf-desht]u
.  \}
..
.
.cp \n[*groff_pdfpic_tmac_C]
.do rr *groff_pdfpic_tmac_C
.
.\" Local Variables:
.\" mode: nroff
.\" fill-column: 72
.\" End:
.\" vim: set expandtab filetype=groff tabstop=2 textwidth=72:
