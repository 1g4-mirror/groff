.\"	-*- roff -*-
.ig

hdtbl.tmac

This file is part of groff, the GNU roff type-setting system.

Copyright (C) 2005, 2006 Free Software Foundation, Inc.
written by Joachim Walsdorff <Joachim.Walsdorff@urz.uni-heidelberg.de>.

groff is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

groff is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with groff; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin St - Fifth Floor, Boston, MA
02110-1301, USA.

..
.
.
.\"	*****************************************************************
.\"	*		hdtbl - Heidelberger table macros		*
.\"	*			Vers. 0.91 December 2005		*
.\"	*****************************************************************
.
.if (\n[?] == 1) \
.  tm HDroff: loading table macros file \n[.F].
.
.nr *hdtbl 1
.
.if !\n[*miscs] \
.  mso hdmisc.tmac
.
.wh 0 HM	\"	comment this, if a page header macro exists
.wh -1i BM	\"	comment this, if a bottom margin macro exists
.
.\" replace `HM' with the name of your pageheader macro, e.g., `pg@top' for MS
.am HM
.  t*hm
..
.
.
.\"	*****************************************************************
.\"	*		default values for some arguments		*
.\"	*****************************************************************
.
.ds t*hl s\"
.ds t*vl s\"
.ds t*tal l\"
.ds t*hal b\"
.ds t*val t\"
.ds t*ff \\n[.fam]\"
.ds t*fst \\n[.f]\"
.ds t*fsz 1 1\"
.ds t*fgc red4\"
.ds t*bgc bisque\"
.ds t*bc red4\"
.nr t*cpd .5n
.nr t*csp .5n
.nr t*b .1n
.nr t*cols 1
.
.
.\"			defaults for table captions
.nr t*cptn 0 1
.ds t*cptn "".sp .4" \
            ".pv 1.4 1.4" \
            ".ad l" \
            "\m[\\*[t*fgc]]Table \\n+[t*cptn]:\0\c\k*"\"
.
.
.\"			Running title, running footer
.ds t*HM //arbitrary text for pageheader, except on the first page//\"
.ds t*BM //arbitrary text for pagefooter, except on the last page/\\n[%]/\"
.
.
.\" %beginstrip%
.
.nr t*numb 0 1	\"	held table diversion #
.
.
.\"	*****************************************************************
.\"	*	The four base macros and the two optional macros	*
.\"	*****************************************************************
.
.\"	TBL:	table start
.\"		predecessor: 	text, TD or ETB
.\"		successor:	CPTN or TR
.de TBL
.  ds t*m\\n[t*#] \\n[.m]\"
.  ie \\n[t*#] \
.    br
.  el \{\
.    ds * \\n[.ev]\"
.    ev t*tbl
.    evc \\*[*]
.    di t*tbl0
.    sp .4
.    nr t*i \\n[.i]
.    ll -\\n[.i]u
.    in 0
.  \}
.  nr t*# +1
.
.  ds width
.  nr t*height\\n[t*#] 0
.
.  getarg cols \\$@\"	from here string `args' contains the rest of \\$@
.  ie "\\*[cols]"" \
.    nr t*cols\\n[t*#] \\n[t*cols]
.  el \
.    nr t*cols\\n[t*#] \\*[cols]
.
.  getarg cpd \\*[args]               \"	cellpadding
.  ie "\\*[cpd]"" \
.    nr t*cpd\\n[t*#] \\n[t*cpd]
.  el \
.    nr t*cpd\\n[t*#] \\*[cpd]
.
.  getarg csp \\*[args]               \"	cellspacing
.  ie "\\*[csp]"" \
.    nr t*csp\\n[t*#] \\n[t*csp]
.  el \
.    nr t*csp\\n[t*#] \\*[csp]
.
.  getarg border \\*[args]            \"	border
.  ie "\\*[border]"=" \
.    nr t*b\\n[t*#] 0-1
.  el \{\
.    ie "\\*[border]"" \
.      nr t*b\\n[t*#] \\n[t*b]
.    el \
.      nr t*b\\n[t*#] \\*[border]
.  \}
.
.  nr b/2\\n[t*#] (\\n[t*b\\n[t*#]] / 2)\"	shortcut
.
.  getarg bc \\*[args]                \"	border color
.  ds t*bc\\n[t*#] \\*[t*bc]\"
.  if !"\\*[bc]"" \{\
.    ie m\\*[bc] \
.      ds t*bc\\n[t*#] \\*[bc]\"
.    el \{\
.      ie "\\*[bc]"=" \
.        ds t*bc\\n[t*#] =\"
.      el \
.        tm \\n[.F]:\\n[.c]: invalid border color `\\*[bc]'.
.  \}\}
.  ie "\\*[bc]"=" \
.    ds t*bc\\n[t*#]
.  el \{\
.    ie "\\*[bc]"" \
.      ds t*bc\\n[t*#] \\*[t*bc]\"
.    el \
.      ds t*bc\\n[t*#] \\*[bc]\"
.  \}
.
.  getarg width \\*[args]             \"	table/col widths
.  if "\\*[width]"=" \
.    ds width
.
.  nr cscp\\n[t*#] (\\n[t*csp\\n[t*#]] + \\n[t*cpd\\n[t*#]])\"  aux. register
.
.  getarg height \\*[args]            \"	table outline height
.  if !"\\*[height]"" \
.    nr t*height\\n[t*#] (\\*[height] - \
                          ((2 * \\n[cscp\\n[t*#]]) + (3 * \\n[b/2\\n[t*#]])))
.  t*cl \\*[width]                    \"	calculate cellwidths and indents
.  t*args \\n[t*#]                    \"	look for common arguments
.
.  getarg tal \\*[args]               \"	table horizontal alignment
.  if "\\*[tal]"" \
.    ds tal \\*[t*tal]\"
.  ie "\\*[tal]"l" \
.    nr in\\n[t*#] \\n[.i]
.  el \{\
.    ie "\\*[tal]"c" \
.      nr in\\n[t*#] \\n[.l]-\\n[ll\\n[t*#]]/2+\\n[.i]
.    el \{\
.      ie "\\*[tal]"r" \
.        nr in\\n[t*#] \\n[.l]-\\n[ll\\n[t*#]]+\\n[.i]
.      el \
.        tm \\n[.F]:\\n[.c]: invalid tal-value `\\*[tal]': must be l, c or r
.  \}\}
.
.  nr t*r#\\n[t*#] 0 1		      \"	rowindex in TBL
.  mk toptbl\\n[t*#]
.
.  P1 \\*[args]
.\" \\..                              \"	XXX
..
.
.
.\"	CPTN:	optional table caption
.\"		predecessor:	TBL
.\"		successor:	TR
.de CPTN
.  ft 1
.
.  if "\\$0"CPTN" \
.    if \\n[t*r#\\n[t*#]] \{\
.      tmc \\n[.F]:\\n[.c]: Invalid placement of `.CPTN';
.      tm1 " must be called immediately after `.TBL'.
.      return
.    \}
.
.  getarg val \\$@
.  ds args\\n[t*#] "\\*[args]\"
.
.  index "\\*[args]" .TR
.  ie \\n[index] \{\
.    ds *a\\n[t*#] "\\*[args]
.    substring args\\n[t*#] 0 \\n[index]
.    substring *a\\n[t*#] \\n[index]-2 -1
.  \}
.  el \
.    ds *a\\n[t*#]
.
.  ie "\\*[val]"b" \{\
.    de t*cptn\\n[t*#]
.      *CPTN \\*[args\\n[t*#]]
.      rm t*cptn\\n[t*#]
\\..
.  \}
.  el \{\
.    ll (\\n[ll\\n[t*#]]u + \\n[in\\n[t*#]]u)
.    in \\n[in\\n[t*#]]u
.    P1 \\*[t*cptn]
'    in +\\n[*]u
.    P1 \\*[args\\n[t*#]]
.    pv 1 1
.    in
.    mk toptbl\\n[t*#]
.  \}
.
.  P1 \\*[*a\\n[t*#]]
..
.
.als *CPTN CPTN
.
.
.\"	TR:	table row
.\"		predecessor:	TBL, CPTN, text, TD or ETB
.\"		successor:	TD
.de TR
.  ft 1
.  if !\\n[t*#] \
.    tm \\n[.F]:\\n[.c]: table row (.TR) without preceding table start (.TBL).
.
.  if \\n[t*r#\\n[t*#]] \
.    t*dntr 1 \\n[c#\\*[#t#r]] \\n[t*cols\\n[t*#]] \\*[*#trc*]
.
.  nr t*r#\\n[t*#] +1			\"	row# of this table
.  ds #t#r \\n[t*#]*\\n[t*r#\\n[t*#]]\"
.  nr c#\\*[#t#r] 0 1			\"	clear cellcounter
.  nr dntr\\*[#t#r] 0 1			\"	clear accumulated row height1
.
.  getarg height \\$@
.  ie "\\*[height]"" \
.    nr t*height\\*[#t#r] 0
.  el \
.    nr t*height\\*[#t#r] \\*[height]
.
.  \"	Wenn ein TR mit height ist die Gesamthöhe der Tabelle um 3/2 b zu hoch,
.  \"	unabhängig von der Zahl der TR mit height.
.  t*args \\*[#t#r] \\n[t*#]
.
.  P1 \\*[args]
..
.
.
.\"	TH:	optional table header cell
.\"		predecessor:	text, TD or TR
.\"		successor:	text, TD, TR, TBL or ETB
.\"								
.\"		cell content bolded and horizontally and vertically centered,
.\"		else like .TD
.de TH
.  ft 1
.  TD val=m hal=c fst=B \\$@
..
.
.
.\"	TD:	table data cell
.\"		predecessor:	text, TD or TR
.\"		successor:	text, TD, TR, TBL or ETB
.de TD
.  ft 1
.  t*dntr 0 \\n[c#\\*[#t#r]]-1 \\\\n[c#\\*[#t#r]] \\*[*#trc*]\"	four backslashes!
.
.  ds *#trc* \\*[#t#r]*\\n[c#\\*[#t#r]]\"
.
.  getarg rowspan \\$@
.  nr rowspan (\\*[rowspan] >? 1)
.
.  getarg colspan \\*[args]
.  nr colspan (\\*[colspan] >? 1)
.
.  t*args \\*[#trc] \\*[#t#r]     \"  look for common arguments
.
.  nr in\\*[#trc] \\n[in\\n[t*#]*\\n[c#\\*[#t#r]]]
.  nr *cl \\n[cll\\n[t*#]*\\n[c#\\*[#t#r]]]
.  nr * 0 1
.  nr *r \\n[t*r#\\n[t*#]]
.
.  while ((\\n[rowspan] - 1) & (\\n+[*] <= \\n[rowspan])) \{\
.    nr rsp\\n[t*#]*\\n[*r]*\\n[c#\\*[#t#r]] \\n[colspan]
.    if (\\n[*] > 1) \
.      nr csp\\n[t*#]*\\n[*r]*\\n[c#\\*[#t#r]] \\n[colspan]
.    nr *r +1
.  \}
.
.  nr * 1 1
.  nr *c \\n[c#\\*[#t#r]]
.
.  if (\\n[colspan] - 1) \{\
.    nr vl\\*[*#trc*] 0-1	\"	no vl flag
.
.    while (\\n+[*] <= \\n[colspan]) \{\
.      nr *c +1
.      nr *cl +(2 * \\n[cscp\\n[t*#]] \
                + \\n[b/2\\n[t*#]] \
                + \\n[cll\\n[t*#]*\\n[*c]])
.      nr c#\\*[#t#r] +1
.    \}
.  \}
.
.  if (\\n[c#\\n[t*#]*\\n[t*r#\\n[t*#]]] > \\n[t*cols\\n[t*#]]) \{\
.    tmc \\n[.F]:\\n[.c]: \\n[c#\\*[#t#r]] table cols (.TD);
.    tm1 " only \\n[t*cols\\n[t*#]] were defined.
.    ds *
.    length * \\n[.F]:\\n[.c]:
.
.    while \\n-[*] \
.      ds * " \\*[*]\"
.
.    tm1 "\\*[*] Remaining .TDs and its contents are ignored.
.
.    di *t*dummy*                \"	bypass superfluous input
.    return
.  \}
.
.  di t*\\*[#trc]                \"	open cell diversion and set locals
.  in 0
.  nr cll\\*[#trc] \\n[*cl]
.  ll \\n[*cl]u
.  nr *cl\\n[t*#] \\n[.l]
.  gcolor \\*[t*fgc\\*[#trc]]
.  ad \\*[t*hal\\*[#trc]]
.  fam \\*[t*ff\\*[#trc]]
.  ft \\*[t*fst\\*[#trc]]
.  pv \\*[t*fsz\\*[#trc]]
.
.  P1 \\*[args]
..
.
.
.\"	ETB:	end of table
.\"		predecessor:	text, TD or ETB
.\"		successor:	text, TD, TR or TBL
.de ETB
.  ie \\n[t*#] \
.    if !\\n[t*r#\\n[t*#]] \{\
.      tmc \\n[.F]:\\n[.c]: each table (.TBL)
.      tm1 " should contain at least one table row (.TR)!
.    \}
.  el \{\
.    tmc \\n[.F]:\\n[.c]: table end (.ETB)
.    tm1 " without corresponding tablestart (.TBL)!
.  \}
.
.  ds #t#r \\n[t*#]*\\n[t*r#\\n[t*#]]\"	refresh #t#r
.  t*dntr 2 \\n[c#\\*[#t#r]] \\n[t*cols\\n[t*#]] \\*[*#trc*]
.
.  t*divs                        \"	print this table
.
.  sp \\n[b/2\\n[t*#]]u
.  t*cptn\\n[t*#]
.  nr t*# -1
.
.  ll \\n[*cl\\n[t*#]]u          \"	restore ll outside this table
.  in 0                          \"	reset indent
.  gcolor \\*[t*m\\n[t*#]]       \"	reset previous fgc
.
.  getarg hold \\$@
.  if !\\n[t*#] \{\
.    sp .5
.    di
.    in \\n[t*i]u
.    ie "\\*[hold]"" \{\
.      ie \\n[.t]-\\n[dn] \
.        DI t*tbl0
.      el \{\
.        rn t*tbl0 t*tbl\\n[t*numb]
.        ds t*kept \\*[t*kept] t*tbl\\n[t*numb] \\n[dn]\"
.      \}
.    \}
.    el \{\
.      rn t*tbl0 t*hold\\n+[t*numb]
.      tm \\n[.F]:\\n[.c]: table t*hold\\n[t*numb] held.
.      ds t*held \\*[t*held] t*hold\\n[t*numb] \\n[dn]\"
.    \}
.
.    ev				\"	restore previous environment
.  \}
.
.  P1 \\*[args]
..
.
.
.\"	*****************************************************************
.\"	*	Following the definition of five utility macros		*
.\"	*	special to hdtbl.					*
.\"	*	Other utility macros common to hdtbl and hdgroff	*
.\"	*	are defined in the file hdmisc.tmac.			*
.\"	*****************************************************************
.
.
.\"	.t*free [n]
.\"		print the next [n] held table[s].
.\"             Don't call it within a table!
.\"		If the table is higher than the remaining space
.\"		on the page, the table is printed on the next page.
.de t*free
.  if "\\$0"CPTN" \
.    if \\n[t*r#\\n[t*#]] \{\
.      tmc \\n[.F]:\\n[.c]: Invalid placement of `.t*free' within a table;
.      tm1 " it must be called outside of any table.
.      return
.    \}
.
.  if "\\*[t*held]"" \{\
.    tm \\n[.F]:\\n[.c]: no held tables
.    return
.  \}
.
.  nr ** (\\$1 >? 1)
.  while !""\\*[t*held]" \{\
.    pops * t*held
.    popr * t*held
.
.    ie (\\n[.t] - \\n[*]) \{\
.      ev t*tbl
.      DI \\*[*]
.      ev
.    \}
.    el \{\
.      rn \\*[*] t*tbl\\n+[t*numb]
.      ds t*kept \\*[t*kept] t*tbl\\n[t*numb] \\n[*]\"
.    \}
.
.    if !(\\n-[**] - 1) \
.      return
.  \}
..
.
.
.\"	The main utility macro for tables:
.\"		If a table is closed by ETB, this macro is called.  It
.\"		processes one complete table, i.e., all the table cell
.\"		diversions, paints the cell backgrounds, draws
.\"		horizontal and vertical table lines and the table border.
.\"
.\"		Nested tables are processed from inside to outside.
.
.de t*divs
.  ll (\\n[l]u + 1c)			\"	avoid warning `can't break line'
.  nf
.  nr #r 0 1
.
.  nr b/2 \\n[b/2\\n[t*#]]		\"	some abbrevs.
.  nr cscp \\n[cscp\\n[t*#]]
.  nr cscpb \\n[b/2]+\\n[cscp]
.
.  nr topdiv (\\n[.d] + \\n[b/2] - \\n[cscp]) \"	top of cell diversion
.  nr cscpb2 (\\n[b/2] / 2 + \\n[cscp])
.
.  \"	outer loop for rows
.  while (\\n+[#r] <= \\n[t*r#\\n[t*#]]) \{\
.    \"	hier code für mehrseitige Tabellen einfügen
.    nr * (\\n[#r] - 1)
.    nr topdiv +(\\n[dntr\\n[t*#]*\\n[*]] + \\n[cscp] + \\n[cscpb])
.
.    \"	if table still lower than specified table height, increase it.
.    if ((\\n[#r] == \\n[t*r#\\n[t*#]]) & \\n[t*height\\n[t*#]]) \
.      nr dntr\\n[t*#]*\\n[#r] (\\n[cscpb] \
                                + \\n[toptbl\\n[t*#]] \
                                + \\n[t*height\\n[t*#]] \
                                - (\\n[topdiv] >? \\n[dntr\\n[t*#]*\\n[#r]]))
.
.    nr #c 0 1
.    \"	inner loop for cells
.    while (\\n+[#c] <= \\n[t*cols\\n[t*#]]) \{\
.      ds #trc \\n[t*#]*\\n[#r]*\\n[#c]\"
.      if !dt*\\*[#trc] \
.        continue
.
.      sp |\\n[topdiv]u
.      in (\\n[in\\n[t*#]]u + \\n[in\\*[#trc]]u)	\"	cell indent
.      nr $1 \\n[dntr\\n[t*#]*\\n[#r]]	\"	cell height
.
.      \" if spanned rows calculate resulting row height and lower hl position
.      nr * \\n[#r] 1
.      if \\n[rsp\\*[#trc]] \{\
.        nr rsp\\*[#trc] 0-1			\"	set no hl flag
.        nr corr (\\n[dn\\*[#trc]] - \\n[dntr\\n[t*#]*\\n[#r]])
.
.        while \\n[rsp\\n[t*#]*\\n+[*]*\\n[#c]] \{\
.          nr rsp\\n[t*#]*\\n[*]*\\n[#c] 0	\"	clear rsp's in following rows
.          nr ** (\\n[dntr\\n[t*#]*\\n[*]] + \\n[cscp] + \\n[cscpb])
.          nr corr -\\n[**]
.          nr $1 +\\n[**]
.        \}
.
.        if (\\n-[*] == \\n[t*r#\\n[t*#]]) \
.          nr $1 (\\n[t*height\\n[t*#]] \
                  - \\n[.d] \
                  + \\n[toptbl\\n[t*#]] \
                  + (\\n[cscpb] >? \\n[$1]))
.        nr dntr\\n[t*#]*\\n[*] +(\\n[corr] >? 0)
.      \}
.
.      \"	paint cell background
.      nr * (2 * \\n[t*cpd\\n[t*#]] + \\n[cll\\*[#trc]])	\"	backgrond width
.      nr $1 (\\n[$1] >? \\n[dn\\*[#trc]])	\"	cell height
.
.      if !"\\*[t*bgc\\*[#trc]]"=" \{\
.        nop \h'\\n[t*csp\\n[t*#]]u'\
\M[\\*[t*bgc\\*[#trc]]]\
\v'(-.67v - \\n[t*cpd\\n[t*#]]u)'\
\D'P \\n[*]u 0 \
     0 (2u * \\n[t*cpd\\n[t*#]]u + \\n[$1]u) \
     -\\n[*]u 0'\
\M[]
.        sp -1
.      \}
.
.      \"	***   horizontal and vertical single or double lines   ***
.      \"	double- and single lines have the same thickness;
.      \"	the double lines distance is the line thickness.
.      \"	border=n: horizontal/vertical lines n/2 thick, minimum .1n.
.      \"	border=0: no border; horizontal/vertical lines .1n thick.
.      \"	border= : neither border nor hl/vl's.
.
.      nr *t (.1n >? \\n[b/2])		\"	thickness of hl/vl minimum .1n
.      in +\\n[cscp]u
.
.      if (1 + \\n[t*b\\n[t*#]]) \{\
.        if !"\\*[t*bc\\n[t*#]]"=" \{\
.          \"       possibly hl/vl's:
.          \"	draw horizontal line between this and the following table cell
.          if (\\n[t*r#\\n[t*#]] - \\n[#r] + \\n[rsp\\*[#trc]]) \{\
.            if !"\\*[t*hl\\*[#trc]]"=" \{\
.              sp \\n[$1]u
.              nr * (\\n[cscp] + \\n[cscpb] + \\n[cll\\*[#trc]])
.              nop \X'\*[g] 1 setlinecap'\
\h'(-\\n[cscpb2]u - \\n[*t]u)'\
\v'(\\n[cscpb2]u - .67v)'\
\m[\\*[t*bc\\n[t*#]]]\
\D't \\n[*t]u'\c
.
.              ie "\\*[t*hl\\*[#trc]]"d" \
.                nop \v'-\\n[*t]u'\
\D'l \\n[*]u 0'\
\v'(2u * \\n[*t]u)'\
\D'l -\\n[*]u 0'\
\D't 0'
.              el \
.                nop \D'l \\n[*]u 0'\
\D't 0'
.
.              sp (-\\n[$1]u - 1v)
.          \}\}
.
.          nr rsp\\*[#trc] 0
.
.          \" draw vertical line between this and the next (right) cell
.          if (\\n[t*cols\\n[t*#]] - \\n[#c] + \\n[vl\\*[#trc]]) \{\
.            if !"\\*[t*vl\\*[#trc]]"=" \{\
.              nop \X'\*[g] 1 setlinecap'\
\v'(-\\n[cscpb2]u - .67v)'\
\m[\\*[t*bc\\n[t*#]]]\
\h'(\\n[cscpb2]u - \\n[*t]u + \\n[cll\\*[#trc]]u)'\c
.
.              ie "\\*[t*vl\\*[#trc]]"d" \
.                nop \h'-\\n[*t]u'\
\D't \\n[*t]u'\
\D'l 0 (2u * \\n[cscp]u + \\n[$1]u + (\\n[*t]u / 2u))'\
\h'(2u * \\n[*t]u)'\
\D'l 0 -(2u * \\n[cscp]u + \\n[$1]u + (\\n[*t]u / 2u))'\
\D't 0'
.              el \
.                nop \D't \\n[*t]u'\
\D'l 0 (2u * \\n[cscp]u + \\n[$1]u + (\\n[*t]u / 2u))'\
\D't 0'
.              sp -1
.      \}\}\}\}
.
.      nr vl\\*[#trc] 0
.
.      \" vert. cell content alignment
.      nr ** 0
.
.      ie "\\*[t*val\\*[#trc]]"m" \
.        nr ** ((\\n[$1] - \\n[dn\\*[#trc]]) / 2)	\"		val=m
.      el \
.        if "\\*[t*val\\*[#trc]]"b" \
.          nr ** (\\n[$1] - \\n[dn\\*[#trc]])\"	val=b
.
.      sp \\n[**]u		 		\"	vertical content position
.
.      \" finally output the diversion
.      t*\\*[#trc]
.      rm t*\\*[#trc]
.    \}					\"	end of while loop for cols
.  \}					\"	                  and rows
.
.  \" draw the box border
.  in \\n[in\\n[t*#]]u
.  nr ** (\\n[topdiv] + \\n[dntr\\n[t*#]*\\n-[#r]])
.
.  if \\n[t*b\\n[t*#]] \{\
.    sp |(\\n[toptbl\\n[t*#]]u + \\n[b/2]u)
.    nr $1 (\\n[toptbl\\n[t*#]] - \\n[**] - \\n[cscp])
.    nr * (\\n[ll\\n[t*#]] - \\n[t*b\\n[t*#]])
.
.    if !"\\*[t*bc\\n[t*#]]"=" \
.      nop \X'\*[g] 0 setlinejoin 2 setlinecap'\
\v'-.67v'\
\h'-\\n[b/2]u'\
\m[\\*[t*bc\\n[t*#]]]\
\D't \\n[t*b\\n[t*#]]u'\
\D'l \\n[*]u 0'\
\D'l 0 -\\n[$1]u'\
\D'l -\\n[*]u 0'\
\D'l 0 \\n[$1]u'\
\D't 0'
.  \}
.
.  sp |(\\n[**]u + \\n[cscpb]u)
.  fi
..
.
.
.\"	Utility macro:	calculate cellwidths, tablewidth and indents
.de t*cl
.  nr t*cols\\n[t*#] (\\n[.$] >? \\n[t*cols\\n[t*#]])
.  nr ll\\n[t*#] 0 1
.  nr ** (\\n[.l] / \\n[t*cols\\n[t*#]])
.  nr * 0 1
.
.  \" while-loop: calculate
.  while (\\n[t*cols\\n[t*#]] >= \\n+[*]) \{\
.    ie "\\$[\\n[*]]"" \
.      nr $\\n[*] \\n[**]	\"	gross width of cells $\n[*] and
.    el \{\
.      ds * \\$\\n[*]\"			accumulate table width ll\n[t*#]
.      substring * -1 -1
.      ds ** \\$[\\n[*]]\"
.      substring ** 0 -2
.      ie "\\*[*]"%" \
.        nr $\\n[*] (\\*[**] * \\n[.l] / 100)
.      el \
.        nr $\\n[*] \\$[\\n[*]]
.    \}
.
.    nr ll\\n[t*#] +\\n[$\\n[*]]	\"	accumulated tablewidth
.    nr ** \\n[$\\n[*]]
.  \}
.
.  if (\\n[ll\\n[t*#]] > \\n[.l]) \
.    tm \\n[.F]:\\n[.c]: table width larger than column width.
.
.  nr ** (0 >? \\n[t*b\\n[t*#]])
.  nr * 0 1
.
.  \" second-while loop: calculate
.  while (\\n[t*cols\\n[t*#]] >= \\n+[*]) \{\
.    \" net cellwidths and indents.
.    if \\n[t*b\\n[t*#]] \{\
.      \" avoid multiplication overflow
.      nr #* (1000 * \\n[ll\\n[t*#]] / \\n[t*b\\n[t*#]])
.      nr $\\n[*] (\\n[$\\n[*]] - (1500 * \\n[$\\n[*]] / \\n[#*]))
.    \}
.
.    \"   VVV cellwidth
.    nr cll\\n[t*#]*\\n[*] (\\n[$\\n[*]] \
                            - (2 * \\n[cscp\\n[t*#]]) \
                            - \\n[b/2\\n[t*#]])
.
.    if !\\n[cll\\n[t*#]*\\n[*]] \{\
.      nr *h ((1000 \
               * \\n[ll\\n[t*#]] \
               / (\\n[ll\\n[t*#]] - (3 * \\n[t*b\\n[t*#]] / 2)) \
               * (2 * \\n[cscp\\n[t*#]] + \\n[b/2\\n[t*#]]) \
               / 1000 \
               + 50) / 10 * 10)
.      tmc \\n[.F]:\\n[.c]: the \\n[*]th width value (\\$\\n[*]) is too small.
.      tm1 " It should be greater than \\n[*h].
.    \}
.
.    nr in\\n[t*#]*\\n[*] \\n[**]		\"	cell indent
.    nr ** +\\n[$\\n[*]]
.  \}
..
.
.
.\"	Utility macro:	close TD-diversion, make some calculations and set
.\"			some help strings and registers
.de t*dntr
.  nr dn 0				\"	dn must be reset!
.  br					\"	finish last div
.
.  if "\\n[.z]"*t*dummy*" \
.    return
.
.  ds #t#r \\n[t*#]*\\n[t*r#\\n[t*#]]\"		refresh #t#r
.
.  if \\n[c#\\*[#t#r]] \{\
.    di
.    nr dn\\$4 \\n[dn]			\"	height of this cell
.    if !\\n[rsp\\*[#trc]] \{\
.      nr dntr\\*[#t#r] (\\n[dntr\\*[#t#r]] >? \\n[dn])
.      if \\$2 \
.        nr dntr\\*[#t#r] ((\\n[t*height\\*[#t#r]] \
                            - (2 * \\n[cscp\\n[t*#]] + \\n[b/2\\n[t*#]])) \
                            >? \\n[dntr\\*[#t#r]])
.  \}\}
.
.  nr c#\\*[#t#r] +1
.  nr * \\$2
.
.  while (\\n+[*] <= \\$3) \{\
.    nr c#\\*[#t#r] +\\n[csp\\*[#t#r]*\\n[*]]
.    nr csp\\*[#t#r]*\\n[*] 0
.  \}
.
.  ds #trc \\*[#t#r]*\\n[c#\\*[#t#r]]\"
.
.  if (\\$1 & (\\n[c#\\*[#t#r]] <= \\n[t*cols\\n[t*#]])) \{\
.    tmc \\n[.F]:\\n[.c]: only \\n-[c#\\*[#t#r]] cols in the \\n[t*r#\\n[t*#]]th row;
.    tm1 \\n[t*cols\\n[t*#]] were defined.
.  \}
..
.
.
.\"	Utility-macro:	get the arguments common for TBL, TR and TD
.de t*args
.  ds t*bgc\\$1 \\*[t*bgc\\$2]\"
.  ds t*fgc\\$1 \\*[t*fgc\\$2]\"
.  ds t*hl\\$1 \\*[t*hl\\$2]\"
.  ds t*vl\\$1 \\*[t*vl\\$2]\"
.  ds t*hal\\$1 \\*[t*hal\\$2]\"
.  ds t*val\\$1 \\*[t*val\\$2]\"
.  ds t*ff\\$1 \\*[t*ff\\$2]\"
.  ds t*fst\\$1 \\*[t*fst\\$2]\"
.  ds t*fsz\\$1 \\*[t*fsz\\$2]\"
.
.  if "\\*[args]"" \
.    return
.
.  getarg bgc \\*[args]         \"	background color
.  if !"\\*[bgc]"" \
.    ie m\\*[bgc] \
.      ds t*bgc\\$1 \\*[bgc]
.    el \
.      ie "\\*[bgc]"=" \
.        ds t*bgc\\$1 =\"
.      el \
.  tm \\n[.F]:\\n[.c]: invalid background color `\\*[bgc]'.
.
.  if "\\*[args]"" \
.    return
.
.  getarg fgc \\*[args]         \"	foreground color
.  if !"\\*[fgc]"" \
.    ie m\\*[fgc] \
.      ds t*fgc\\$1 \\*[fgc]\"
.    el \
.      ie "\\*[fgc]"=" \
.        ds t*fgc\\$1 =\"
.      el \
.      tm \\n[.F]:\\n[.c]: invalid foreground color `\\*[fgc]'.
.
.      if "\\*[args]"" \
.        return
.
.  getarg hl \\*[args]           \" horizontal line between cells ...
.  if !"\\*[hl]"" \
.    ds t*hl\\$1 \\*[hl]\"
.  if "\\*[args]"" \
.    return
.
.  getarg vl \\*[args]           \" vertical line between cells ...
.  if !"\\*[vl]"" \
.    ds t*vl\\$1 \\*[vl]\"
.  if "\\*[args]"" \
.    return
.
.  getarg hal \\*[args]
.  if !"\\*[hal]"" \{\
.    index bcrl \\*[hal]
.    ie \\n[index] \
.      ds t*hal\\$1 \\*[hal]\"
.    el \{\
.      tmc \\n[.F]:\\n[.c]: invalid hal-value `\\*[t*hal\\$1]':
.      tm1 " must be b, c, l or r.
.  \}\}
.
.  if "\\*[args]"" \
.    return
.
.  getarg val \\*[args]         \" vertical table cell alignment
.  if !"\\*[val]"" \{\
.    index tmb \\*[val]
.    ie \\n[index] \
.      ds t*val\\$1 \\*[val]\"
.    el \{\
.      tmc \\n[.F]:\\n[.c]: invalid val-value `\\*[t*val]':
.      tm1 must be t, m or b.
.  \}\}
.
.  if "\\*[args]"" \
.    return
.
.  getarg ff \\*[args]
.  if !"\\*[ff]"" \
.    ds t*ff\\$1 \\*[ff]\"
.  if "\\*[args]"" \
.    return
.
.  getarg fst \\*[args]
.  if !"\\*[fst]"" \
.    ds t*fst\\$1 \\*[fst]\"
.  if "\\*[args]"" \
.    return
.
.  getarg fsz \\*[args]
.  if !"\\*[fsz]"" \
.    ds t*fsz\\$1 \\*[fsz]\"
..
.
.
.de t*hm
.  ev t*tbl
.  nr ** \\n[.t]
.  while !""\\*[t*kept]" \{\
.    pops * t*kept
.    popr * t*kept
.    if (\\n[*] - \\n[**]) \{\
.      tm \\n[.F]:\\n[.c]: table \\*[*] higher than page -- ignored!
.      break
.    \}
.
.    if (\\n[*] - \\n[.t]) \{\
.      ds t*kept \\n[*] \\*[t*kept]
.      ds t*kept \\*[*] \\*[t*kept]
.      tmc \\n[.F]:\\n[.c]: remaining table(s),
.      tm1 " because not all fit onto this page.
.      break
.    \}
.
.    DI \\*[*]
.  \}
.  ev
..
.
.\" EOF
