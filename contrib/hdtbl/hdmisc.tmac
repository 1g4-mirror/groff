.\"	-*-	mode: roff	-*-
.ig

hdmisc.tmac

This file is part of groff, the GNU roff type-setting system.

Copyright (C) 2005, 2006 Free Software Foundation, Inc.
written by Joachim Walsdorff <Joachim.Walsdorff@urz.uni-heidelberg.de>.

groff is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

groff is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with groff; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin St - Fifth Floor, Boston, MA
02110-1301, USA.

..
.
.
.\" %beginstrip%
.
.if (\n[?] == 1) \
.  tm HDroff: loading misc. macros file \n[.F].
.
.nr *miscs 1
.
.
.\"	******************************************************************
.\"	**	Some macros and default settings needed by hdtbl	**
.\"	******************************************************************
.\"
.\"	******************************************************************
.\"	**	Macro getarg: process macro arguments			**
.\"	**								**
.\"	**	getarg argname targetname a1=v1 key1		 	**
.\"	**				  a2=v2 key2 ..., mixed		**
.\"	**	returns value of arg as string in target.		**
.\"     **      arg without value returns the argname.		 	**
.\"	**	`arg=' returns `='.				 	**
.\"	**	after return string `args' contains the remaining args.	**
.\"	******************************************************************
.de getarg
.  ds \\$1
.  ds args
.
.  if (\\n[.$] < 2) \
.    return				\"	speeds up significantly
.
.  ds $1 \\$1
.  shift
.
.  length * \\*[$1]
.  \" Change escape char to avoid conflicts with escapes in args.
.  \" Note that it is expected that trailing comments are stripped
.  \" before executing the HDtbl macros.
.  ec 
.  while n[.$] {
.    ds * "$1\"
.    ds ** "$1\"
.    shift
.    substring * 0 (n[*] - 1)
.    ie !"*[$1]"*[*]" {
.      as args " "*[**]"\"		arg not found, repeat
.      continue
.    }
.    el {
.      ie "*[**]"*[$1]" 
.        ds *[$1] *[$1]\"		return bare arg name as string
.      el {
.        ie "*[**]"*[$1]=" 
.          ds *[$1] =\"		return value `=' as string
.        el {
.          substring ** (n[*] + 1) -1
.          ds * *[**]\"
.          substring * 0 0
.
.          if "*[*]"'" {
.            substring ** 1 -1		\" remove 1st char from arg (')
.            ds * *[**]\"
.            substring * -1 -1    	\" remove 2nd char also (')
.
.            ie "*[*]"'" 
.              substring ** 0 -2	\" yes, skip next clause
.            el {
.              as *[$1] *[**] \" 	   no, append this arg
.
.              while 1 {
.                ds ** $1\"		   get next arg
.                ds * $1\"
.                shift
.                substring * -1 -1
.
.                if "*[*]"'" {
.                  substring ** 0 -2
.                  break		\" leave loop if last char isn't '
.                }
.
.                as *[$1] *[**] \" 	   otherwise append arg and repeat
.              }
.          }}
.
.          as *[$1] *[**]
.        }
.
.        as args " $@
.    }}
.
.    ec
.    return
.  \}					\" end of while
.  ec
..
.
.
.\"
.\"	******************************************************************
.\"	**		.index string1 string2				**
.\"	**			returns in reg `index' the index	**
.\"	**			of string2 in string1 or 0		**
.\"	**			without string2 reg `index' is -999	**
.\"	******************************************************************
.de index
.  if "\\$2"" \{\
.    nr index -999
.    return
.  \}
.
.  length ** \\$1
.  length $2 \\$2
.  nr * 0-1 1
.
.  while (\\n+[*] < \\n[**]) \{\
.    ds * \\$1\"
.    substring * \\n[*] (\\n[*] + \\n[$2] - 1)
.    \" The surrounding \? escapes emulate string comparison.
.    if "\?\\*[*]\?"\?\\$2\?" \
.      break
.  \}
.
.  ie (\\n[*] == \\n[**]) \
.    nr index 0
.  el \
.    nr index (\\n[*] + 1)
..
.
.
.\"	******************************************************************
.\"	********	non-accumulating space .SP [v]		**********
.\"	**                                                              **
.\"	**	nl vor erster Seite -1, oben auf Seite 0 resp. tH	**
.\"	**	.k nach .sp oder .br 0,					**
.\"	**		sonst Laenge der angefangenen Zeile		**
.\"	**	Der Merker M# fuer vorangegangenes .SP wird in .HM am	**
.\"	**	Seitenanfang zurueckgesetzt.				**
.\"	**	ganz richtig ist .sp + .br = .br + .sp = .sp		**
.\"	******************************************************************
.de SP
.  if (\\n[nl] < 0) \
.    br			\"	start very first page
.  nr * \\n[.p]		\"	save current page length
.
.  ie "\\$1"" \
.    pl +1		\"	without arg increase page length by 1v
.  el \
.    pl +\\$1		\"	otherwise use \\$1
.
.  nr ** (\\n[.p] - \\n[*])	\" ** now holds arg for .SP in base units
.  pl \\n[*]u		\"	restore page length
.
.  \" we do nothing at start of new page or column
.  if ((\\n[nl] - \\n[tH]) & (\\n[nl] - \\n[<<]) : \\n[.k]) \{\
.    ie ((\\n[.d] - \\n[M#]) : \\n[.k]) \{\
.      sp \\n[**]u	\"	execute .sp
.      nr S# \\n[**]	\"	store ** in S#
.    \}
.    el \{\
.      if (\\n[**] - \\n[S#]) \{\
.        sp (\\n[**]u - \\n[S#]u)\"	emit difference to previous .SP
.        nr S# \\n[**]	\"	store ** in S#
.    \}\}
.
.    nr M# \\n[.d]	\"	store vertical position .d in M#
.  \}
..
.
.
.\"	******************************************************************
.\"	**		Perform all arguments once			**
.\"	**			P1 is nestable				**
.\"	******************************************************************
.de P1
.  \" `while' command is about five times faster than recursion!
.  while \\n[.$] \{\
.    nop \\$1
.    shift
.  \}
..
.
.
.\"	******************************************************************
.\"	**	Hilfsmakro zum Einstellen von Schriftgroesse und	**
.\"	**	Zeilenabstand, bezogen auf Anfangswerte \n[s] und \n[v]	**
.\"	**	sowie fuer Hyphenation:					**
.\"	**		.pv s v hy# hart;  macht .br			**
.\"	**	Bei 4. Argument setzen der Register s und v und hy.	**
.\"	**	Fuer angefangene Zeile die vorgefundenen Einstellungen	**
.\"	******************************************************************
.de pv
.  br
.
.  if \\n[.$] \
.    ps (\\n[s]u * \\$1p / 1p)
.
.  ie (\\n[.$] - 1) \
.    vs (\\n[v]u * \\$2p / 1p)
.  el \{\
.    vs (\\n[v]u * \\$1p / 1p)
.    return
.  \}
.
.  if !""\\$3" \
.    hy \\$3
.
.  if !""\\$4" \{\
.    nr v \\n[.v]
.    nr s \\n[.s]p
.    nr hy \\n[.hy]
.  \}
..
.
.
.\"	******************************************************************
.\"	**		Hilfsmakros pop/pops/popr (pop stackelement):	**
.\"	**		pop or popr:	pop register			**
.\"	**		pops:		pop string			**
.\"	**		.pop[s|r] reg|string stackname			**
.\"	**		    reg|string: name of reg/string to get the	**
.\"	**			 popped element				**
.\"	**		    stack: name of stack			**
.\"	******************************************************************
.de *pop
.  ie "\\$1"pops" \
.    ds \\$2 \\$4\"		pop first stackelement
.  el \
.    nr \\$2 \\$4
.
.  ds $3 \\$3\"			remember stackname
.  shift 4		\"	shift four args
.
.  ds \\*[$3] "\\$@\"		fill stack with remaining elements
..
.
.de pop
.  *pop \\$0 \\$1 \\$2 \\*[\\$2]
..
.
.als popr pop
.als pops pop
.
.
.\"	******************************************************************
.\"	**		processs diversion				**
.\"	******************************************************************
.de DI
.  nr * \\n[.u]
.  nf		\"	diversion is already formatted - output it unchanged
.  \\$1		\"	output the diversion ...
.  rm \\$1	\"	... and remove it
.  if \\n[*] \
.    fi		\"	reactivate formatting
..
.
.
.\"	******************************************************************
.\"	**	Some macros and the page setup used by the examples	**
.\"	******************************************************************
.
.\"	******************************************************************
.\"	**	some of the following macros use system commands	**
.\"	**	and are therefore `unsafe': they need the `-U' argument **
.\"	**	when calling groff/troff				**
.\"	******************************************************************
.
.ie n \
.  ds g tty:
.el \
.  ds g ps: exec
.
.
.\"	******************************************************************
.\"	**		Header macro for the examples			**
.\"	******************************************************************
.de H
.  nr *w* (17 * \w\\$* / 10 + 4n)
.  TBL border=1n \
       bc=yellow \
       bgc=red4 \
       fgc=yellow \
       csp=0 \
       fst=TB \
       "fsz=1.7 1.5" \
       hal=c \
       tal=c \
       "width=(\\n[*w*]+4n)<?\n[.l]"
.  TR .TD
.  P1 \\$*
.  ETB
.  SP
..
.
.
.\"	******************************************************************
.\"	**	Utility macro for the date, requires UNIX date.		**
.\"	**	after return string *date contains the date in the	**
.\"	**	standard form of the Unix date-command,			**
.\"	**	for example "Sun Dec  5 22:27:57     2004"		**
.\"	******************************************************************
.de date
.  pso bash -c "echo -n .ds *date\ ;date"
.  tm \\*[*date] ***
..
.
.
.\"	******************************************************************
.\"	**	Utility macro for time measurement, requires UNIX date	**
.\"	**	.time s[tart]|[end]					**
.\"	**		.time start:					**
.\"	**			reg *time gets the start-time (seconds) **
.\"	**		.time [end]:					**
.\"	**			reg *time gets the difference of the	**
.\"	**				end- and start-time (seconds)	**
.\"	******************************************************************
.de time
.  ds * \\$1\"
.  substring * 0 0
.  ie "\\*[*]"s" \
.    pso bash -c "echo -n .nr *time 0+;date +%s"
.  el \{\
.   pso bash -c "echo -n .nr *time -;date +%s"
.   nr *time 0-\\n[*time]
.   tm elapsed time: \\n[*time] seconds
.  \}
..
.
.
.\"	******************************************************************
.\"	**		Perform n-times all the arbitrary arguments	**
.\"	**		.PN n a2 a3 ...					**
.\"	**			PN is nestable				**
.\"	******************************************************************
.de PN
.  nr *pn +1
.  nr PN\\n[*pn] (\\$1 + 1) 1
.  shift
.
.  while \\n-[PN\\n[*pn]] \
.    P1 \\$@
.
.  nr *pn -1
..
.
.
.de dzx 		\"	help macro for d2x - adds next hex item
.  nr * (\\$1 + 1) 1
.  while \\n-[*] \
.    shift
.  as hex# \\$1
..
.
.
.\"	******************************************************************
.\"	**	Utility macro; converts decimal number to another base	**
.\"	**		and puts result into a string.			**
.\"	**	usage:	.d2x decimal_number [base [string name]]	**
.\"	**			second arg: base; default: 16		**
.\"	**			third arg: name of the string,		**
.\"	**				default name: hex#		**
.\"	******************************************************************
.de d2x
.  if "\\$1"" \{\
.    tm \\n[.F]:\\n[.c]: missing argument.
.    tm1 "     usage: `.d2x decimal_number [base [string_name]]'
.    return
.  \}
.
.  nr i# (-1) 1
.  nr j# 1
.  ds hex#
.  nr dec# (\\$1) 1
.
.  if !\\$1 \
.    nr dec# (-\\n[dec#])
.
.  ie !"\\$2"" \
.    nr b# \\$2
.  el \
.    nr b# 16
.
.  nr xb# 1
.
.  ie ((\\n[b#] - 1) == 0) \
.    while (\\n-[dec#] + 1) \
.      as hex# |\"	bei base=1 Strichliste
.  el \{\
.    while (\\n[dec#] - \\n[xb#]) \{\
.      nr xb# (\\n[xb#] * \\n[b#])
.      nr j# +1
.    \}
.
.    while (\\n+[i#] < \\n[j#]) \{\
.      nr ** (\\n[dec#] / \\n[xb#])
.      dzx \\n[**] 1 2 3 4 5 6 7 8 9 A B C D E F
.      nr dec# (\\n[dec#] - (\\n[xb#] * \\n[**]))
.      nr xb# (\\n[xb#] / \\n[b#])
.    \}
.  \}
.
.  \"					leading 0 before 1 is suppressed! Why?
.  ds * \\*[hex#]\"			if leading zero, strip it
.  substring * 0 0
.  if "\\*[*]"0" \
.    substring hex# 1 -1
.
.  if (\\$1 < 0) \
.    ds hex# -\\*[hex#]\"
.
.  if !"\\$3"" \
.    ds \\$3 \\*[hex#]\"
..
.
.
.\"	******************************************************************
.\"	**	random#: (uses the BASH-variable $RANDOM)		**
.\"	**		 after completion: _string_ #random contains	**
.\"	**			a triple of two-digit-hexnumbers	**
.\"	**			(three random numbers 0...255)		**
.\"	******************************************************************
.de random#
.  pso bash -c "echo -e .ds ss \\\\$RANDOM \\\\$RANDOM \\\\$RANDOM"
.
.  popr *1 ss
.  nr * (\\n[*1] / 128)
.  d2x \\n[*] 16 $1
.  length * \\*[$1]
.  if (2 - \\n[*]) \
.    ds $1 0\\*[$1]\"
.
.  popr *2 ss
.  nr * (\\n[*2] / 128)
.  d2x \\n[*] 16 $2
.  length * \\*[$2]
.  if (2 - \\n[*]) \
.    ds $2 0\\*[$2]\"
.
.  popr *3 ss
.  nr * (\\n[*3] / 128)
.  d2x \\n[*] 16 $3
.  length * \\*[$3]
.  if (2 - \\n[*]) \
.    ds $3 0\\*[$3]\"
.
.  ds #random #\\*[$1]\\*[$2]\\*[$3]\"
..
.
.
.\"	******************************************************************
.\"	**			minimal Page setup			**
.\"	******************************************************************
.nr s \n[.s]p
.nr v \n[.v]
.pv 1.2 1.2 "" X
.nr l 6.6i
.ll \n[l]u
.nr o 2c
.po \n[o]u
.nr p 29.7c	\"	pagelength A4
.pl \n[p]u
.nr tH 1i
.sp |\n[tH]u	\"	text start on the first page
.
.ev 99
.lt \n[l]u
.ev
.
.
.de HM
.  sp |.5i
.  tl \\*[t*HM]
.  sp |\\n[tH]u
.  ev
..
.
.
.de BM
.  ev 99
.  sp |(\\n[p]u - .5i)
.  tl \\*[t*BM]
.  bp
..
.
.
.de EM
.  rm BM			\"	no page number at bottom of last page
.
.  if !""\\*[t*kept]" \
.    tm HDroff: kept table left over; add `.bp' at the end of your document.
.  if !""\\*[t*held]" \
.    tm HDroff: held table left over; add `.t*free' at the end of your document.
.  if \\n[t*#] \
.    tm  HDrofff: unclosed table (TBL).
..
.
.
.em EM
.
.if "\n[.m]"" \
.  gcolor black
.if "\n[.M]"" \
.  fcolor white
.if !\n[*hdtbl] \
.  mso hdtbl.tmac\"	load table macros
.
.\" EOF
