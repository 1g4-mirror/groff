Additional description for groffer.sh, the shell version of groffer


Shell Compatibility

This shell script is compatible to both the GNU and the POSIX shell
and utilities.  Care was taken to restrict the programming technics
used here in order to achieve POSIX compatibility as far back as POSIX
P1003.2 Draft 11.2 of September 1991.  This draft is available at
http://www.funet.fi/pub/doc/posix/p1003.2/d11.2 in the internet.

The POSIX draft does not include `local' variables for functions.  So
this concept was replaced by global variables with a prefix that
differs for each function.  The prefix is chosen from the function
name.  These quasi-local variables are unset before each return of the
function.

Some shells are not fully POSIX compatible.  For them the following
restrictions were done.  For more information look at the
documentation `Portable shells' in the `info' page of `autoconf'
(look-up in Emacs-Help-Manuals).

- The command parts `then', `else', and `do' are written each on a
  line of their own.

- Replace `for i in "$@"' by `for i'.

- Replace `set -- ...' by `set x ...; shift'.  After the first
  non-option argument, all arguments including those starting with `-'
  are accepted as non-option.

- The name of the variable in `for' is chosen as a single character.
  The content of such variables is not safe.  So it is often stored in
  an additional quasi-local variable.

The `groffer' script provides its own option parser.  It is compatible
to the usual GNU style command line (option clusters, long option
names with 2 `-' signs, mixing of options and non-option file names),
except that it is not possible to abbreviate long option names.

The flexible mixing of options and file names in GNU style is always
possible, even if the environment variable `$POSIXLY_CORRECT' is set
to a non-empty value.  This disables the rather wicked POSIX behavior
to terminate option parsing when the first non-option command line
argument is found.


Error Handling

Error handling and exit behavior is complicated by the fact that
`exit' can only escape from the current shell; trouble occurs in
subshells.  This was solved by sending kill signals, see $_PROCESS_ID
and error().


Survey of Functions defined in groffer.sh

Each funtion in groffer.sh has a description that starts with the
function name and symbols for its arguments in paranthesis `()'.  Each
`<>' construction gives an argument name that just gives a hint on
what the argument is meant to be; these argument names are otherwise
irrelevant.  The `>' sign can be followed by another character that
shows how many of these arguments are possible.

<arg>?     0 or 1 of these arguments
<arg>*     arbitrarily many such arguments, incl. none
<arg>+     one or more such arguments
<arg>      exactly 1 of this argument
[...]      optional arguments

A function that starts with an underscore `_' is an internal function
for some function.  The internal functions are defined just after
their corresponding function; they are not mentioned in the following.

abort (<text>*)
base_name (<path>)
catz (<file>)
clean_up ()
diag (<text>*)
dirname_append (<path> [<dir...>])
dirname_chop (<path>)
do_filearg (<filearg>)
do_nothing ()
echo2 (<text>*)
echo2n (<text>*)
error (<text>*)
get_first_essential (<arg>*)
is_dir (<name>)
is_empty (<string>)
is_equal (<string1> <string2>)
is_existing (<name>)
is_file (<name>)
is_non_empty_file (<name>)
is_not_dir (<name>)
is_not_empty (<string>)
is_not_equal (<string1> <string2>)
is_not_file (<name>)
is_not_prog (<name>)
is_not_writable (<name>)
is_not_yes (<string>)
is_prog (<name>)
is_writable (<name>)
is_yes (<string>)
leave ()
landmark (<text>)
list_append (<list> <element>...)
list_from_cmdline (<pre_name_of_opt_lists> [<cmdline_arg>...])
list_from_split (<string> <separator>)
list_get (<list>)
list_has (<list> <element>)
list_has_not (<list> <element>)
main_*(), see after the functions
man_do_filespec (<filespec>)
man_setup ()
man_register_file (<file> [<name> [<section>]])
man_search_section (<name> <section>)
man_set()
manpath_add_lang(<path> <language>)
manpath_add_system()
manpath_from_path ()
normalize_args (<shortopts> <longopts> <arg>*)
obj (<object> <call_name> <arg>...)
obj_data (<object>)
obj_from_output (<object> <call_name> <arg>...)
obj_set (<object> <data>)
path_chop (<path>)
path_clean (<path>)
path_contains (<path> <dir>)
path_not_contains (<path> <dir>)
path_split (<path>)
register_file (<filename>)
register_title (<filespec>)
res (<var_name> <function_name> <arg>...)
reset ()
save_stdin ()
string_contains (<string> <part>)
string_not_contains (<string> <part>)
tmp_cat ()
tmp_create (<suffix>?)
to_tmp (<filename>)
trap_clean ()
trap_set (<functionname>)
usage ()
version ()
warning (<string>)
whatis (<filename>)
where (<program>)


External Environment Variables

The groffer.sh script uses the following external system variables.
It is supposed that these variables are already exported outside of
groffer.sh; otherwise they do not have a value within the script.

external system environment variables that are explicitly used
$DISPLAY:		Presets the X display.
$LANG:			For language specific man pages.
$LC_ALL:		For language specific man pages.
$LC_MESSAGES:		For language specific man pages.
$PAGER:			Paging program for tty mode.
$PATH:			Path for the programs called (`:' separated list).

groffer native environment variables
$GROFFER_OPT		preset options for groffer.

all groff environment variables are used, see groff(1)
$GROFF_BIN_PATH:	Path for all groff programs.
$GROFF_COMMAND_PREFIX:	'' (normally) or 'g' (several troffs).
$GROFF_FONT_PATH:	Path to non-default groff fonts.
$GROFF_TMAC_PATH:	Path to non-default groff macro files.
$GROFF_TMPDIR:		Directory for groff temporary files.
$GROFF_TYPESETTER:	Preset default device.

all GNU man environment variables are used, see man(1).
$MANOPT:		Preset options for man pages.
$MANPATH:		Search path for man pages (: list).
$MANROFFSEQ:		Ignored because of grog guessing.
$MANSECT:		Search man pages only in sections (:).
$SYSTEM:		Man pages for different OS's (, list).


Object-oriented Functions

The groffer script provides an object-oriented construction (OOP).  In
object-oriented terminology, a type of object is called a `class'; a
function that handles objects from a class is named `method'.

In the groffer script, the object is a variable name whose content is
the object's data.  Methods are functions that have an object as first
argument.

The basic functions for object handling are obj_*().

The class `list' represents an array structure, see list_*().


####### License

Copyright (C) 2003,2004,2005 Free Software Foundation, Inc.
Written by Bernd Warken

This file is part of groffer, which is part of groff.

groff is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

groff is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with groff; see the files COPYING and LICENSE in the top
directory of the groff source.  If not, write to the Free Software
Foundation, 51 Franklin St - Fifth Floor, Boston, MA 02110-1301, USA.
